import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    calculateShardId: () => calculateShardId,
    getUserAgentAppendix: () => getUserAgentAppendix,
    isEquatable: () => isEquatable,
    isJSONEncodable: () => isJSONEncodable,
    lazy: () => lazy,
    polyfillDispose: () => polyfillDispose,
    range: () => range,
    shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  function lazy(cb) {
    let defaultValue;
    return () => defaultValue ??= cb();
  }
  __name(lazy, "lazy");
  function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
      rangeEnd = range2;
    } else {
      start = range2.start;
      rangeEnd = range2.end;
      step = range2.step ?? 1;
    }
    for (let index = start;index < rangeEnd; index += step) {
      yield index;
    }
  }
  __name(range, "range");
  function calculateShardId(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
  }
  __name(calculateShardId, "calculateShardId");
  function shouldUseGlobalFetchAndWebSocket() {
    if (typeof globalThis.process === "undefined") {
      return "fetch" in globalThis && "WebSocket" in globalThis;
    }
    if ("versions" in globalThis.process) {
      return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
    }
    return false;
  }
  __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
  function getUserAgentAppendix() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
      return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
      return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
      if (typeof globalThis.navigator === "object") {
        return globalThis.navigator.userAgent;
      }
      return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
      if ("deno" in globalThis.process.versions) {
        return `Deno/${globalThis.process.versions.deno}`;
      }
      if ("bun" in globalThis.process.versions) {
        return `Bun/${globalThis.process.versions.bun}`;
      }
      if ("node" in globalThis.process.versions) {
        return `Node.js/${globalThis.process.versions.node}`;
      }
    }
    return "UnknownEnvironment";
  }
  __name(getUserAgentAppendix, "getUserAgentAppendix");
  function polyfillDispose() {
    Symbol.dispose ??= Symbol("Symbol.dispose");
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
  }
  __name(polyfillDispose, "polyfillDispose");
  function isJSONEncodable(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
  }
  __name(isJSONEncodable, "isJSONEncodable");
  function isEquatable(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
  }
  __name(isEquatable, "isEquatable");
  var version = "1.1.1";
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class AbortError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "The operation was aborted";
    }
  }

  class RequestAbortedError extends AbortError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
  }

  class ResponseError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      this.name = "ResponseError";
      this.message = message || "Response error";
      this.code = "UND_ERR_RESPONSE";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
  }

  class SecureProxyConnectionError extends UndiciError {
    constructor(cause, message, options) {
      super(message, { cause, ...options ?? {} });
      this.name = "SecureProxyConnectionError";
      this.message = message || "Secure Proxy Connection failed";
      this.code = "UND_ERR_PRX_TLS";
      this.cause = cause;
    }
  }
  module.exports = {
    AbortError,
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError,
    ResponseError,
    SecureProxyConnectionError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {};
  var wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/undici/lib/core/tree.js
var require_tree = __commonJS((exports, module) => {
  var {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  } = require_constants();

  class TstNode {
    value = null;
    left = null;
    middle = null;
    right = null;
    code;
    constructor(key, value, index) {
      if (index === undefined || index >= key.length) {
        throw new TypeError("Unreachable");
      }
      const code = this.code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (key.length !== ++index) {
        this.middle = new TstNode(key, value, index);
      } else {
        this.value = value;
      }
    }
    add(key, value) {
      const length = key.length;
      if (length === 0) {
        throw new TypeError("Unreachable");
      }
      let index = 0;
      let node = this;
      while (true) {
        const code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (node.code === code) {
          if (length === ++index) {
            node.value = value;
            break;
          } else if (node.middle !== null) {
            node = node.middle;
          } else {
            node.middle = new TstNode(key, value, index);
            break;
          }
        } else if (node.code < code) {
          if (node.left !== null) {
            node = node.left;
          } else {
            node.left = new TstNode(key, value, index);
            break;
          }
        } else if (node.right !== null) {
          node = node.right;
        } else {
          node.right = new TstNode(key, value, index);
          break;
        }
      }
    }
    search(key) {
      const keylength = key.length;
      let index = 0;
      let node = this;
      while (node !== null && index < keylength) {
        let code = key[index];
        if (code <= 90 && code >= 65) {
          code |= 32;
        }
        while (node !== null) {
          if (code === node.code) {
            if (keylength === ++index) {
              return node;
            }
            node = node.middle;
            break;
          }
          node = node.code < code ? node.left : node.right;
        }
      }
      return null;
    }
  }

  class TernarySearchTree {
    node = null;
    insert(key, value) {
      if (this.node === null) {
        this.node = new TstNode(key, value, 0);
      } else {
        this.node.add(key, value);
      }
    }
    lookup(key) {
      return this.node?.search(key)?.value ?? null;
    }
  }
  var tree = new TernarySearchTree;
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
    tree.insert(key, key);
  }
  module.exports = {
    TernarySearchTree,
    tree
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols();
  var { IncomingMessage } = __require("node:http");
  var stream = __require("node:stream");
  var net = __require("node:net");
  var { Blob: Blob2 } = __require("node:buffer");
  var nodeUtil = __require("node:util");
  var { stringify } = __require("node:querystring");
  var { EventEmitter: EE } = __require("node:events");
  var { InvalidArgumentError } = require_errors();
  var { headerNameLowerCasedRecord } = require_constants();
  var { tree } = require_tree();
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  function wrapRequestBody(body) {
    if (isStream(body)) {
      if (bodyLength(body) === 0) {
        body.on("data", function() {
          assert(false);
        });
      }
      if (typeof body.readableDidRead !== "boolean") {
        body[kBodyUsed] = false;
        EE.prototype.on.call(body, "data", function() {
          this[kBodyUsed] = true;
        });
      }
      return body;
    } else if (body && typeof body.pipeTo === "function") {
      return new BodyAsyncIterable(body);
    } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
      return new BodyAsyncIterable(body);
    } else {
      return body;
    }
  }
  function nop() {}
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    if (object === null) {
      return false;
    } else if (object instanceof Blob2) {
      return true;
    } else if (typeof object !== "object") {
      return false;
    } else {
      const sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && (("stream" in object) && typeof object.stream === "function" || ("arrayBuffer" in object) && typeof object.arrayBuffer === "function");
    }
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function isValidPort(port) {
    const value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin[origin.length - 1] === "/") {
        origin = origin.slice(0, origin.length - 1);
      }
      if (path && path[0] !== "/") {
        path = `/${path}`;
      }
      return new URL(`${origin}${path}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert(typeof host === "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  }
  function isDestroyed(body) {
    return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      queueMicrotask(() => {
        stream2.emit("error", err);
      });
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(value) {
    return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function parseHeaders(headers, obj) {
    if (obj === undefined)
      obj = {};
    for (let i = 0;i < headers.length; i += 2) {
      const key = headerNameToString(headers[i]);
      let val = obj[key];
      if (val) {
        if (typeof val === "string") {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      } else {
        const headersValue = headers[i + 1];
        if (typeof headersValue === "string") {
          obj[key] = headersValue;
        } else {
          obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
        }
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers) {
    const len = headers.length;
    const ret = new Array(len);
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    let key;
    let val;
    let kLen = 0;
    for (let n = 0;n < headers.length; n += 2) {
      key = headers[n];
      val = headers[n + 1];
      typeof key !== "string" && (key = key.toString());
      typeof val !== "string" && (val = val.toString("utf8"));
      kLen = key.length;
      if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
        hasContentLength = true;
      } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = n + 1;
      }
      ret[n] = key;
      ret[n + 1] = val;
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
  }
  function isErrored(body) {
    return !!(body && stream.isErrored(body));
  }
  function isReadable(body) {
    return !!(body && stream.isReadable(body));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
            controller.byobRequest?.respond(0);
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          if (buf.byteLength) {
            controller.enqueue(new Uint8Array(buf));
          }
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      },
      type: "bytes"
    });
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  var hasToWellFormed = typeof String.prototype.toWellFormed === "function";
  var hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
  function toUSVString(val) {
    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
  }
  function isUSVString(val) {
    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i = 0;i < characters.length; ++i) {
      if (!isTokenCharCode(characters.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  function addListener(obj, name, listener) {
    const listeners = obj[kListeners] ??= [];
    listeners.push([name, listener]);
    obj.on(name, listener);
    return obj;
  }
  function removeAllListeners(obj) {
    for (const [name, listener] of obj[kListeners] ?? []) {
      obj.removeListener(name, listener);
    }
    obj[kListeners] = null;
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  var normalizedMethodRecordsBase = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  var normalizedMethodRecords = {
    ...normalizedMethodRecordsBase,
    patch: "patch",
    PATCH: "PATCH"
  };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isUSVString,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    bufferToLowerCasedHeaderName,
    addListener,
    removeAllListeners,
    errorRequest,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    addAbortListener,
    isValidHTTPToken,
    isValidHeaderValue,
    isTokenCharCode,
    parseRangeHeader,
    normalizedMethodRecordsBase,
    normalizedMethodRecords,
    isValidPort,
    isHttpOrHttpsPrefixed,
    nodeMajor,
    nodeMinor,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody
  };
});

// node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("node:diagnostics_channel");
  var util = __require("node:util");
  var undiciDebugLog = util.debuglog("undici");
  var fetchDebuglog = util.debuglog("fetch");
  var websocketDebuglog = util.debuglog("websocket");
  var isClientSet = false;
  var channels = {
    beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
    connected: diagnosticsChannel.channel("undici:client:connected"),
    connectError: diagnosticsChannel.channel("undici:client:connectError"),
    sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
    create: diagnosticsChannel.channel("undici:request:create"),
    bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
    headers: diagnosticsChannel.channel("undici:request:headers"),
    trailers: diagnosticsChannel.channel("undici:request:trailers"),
    error: diagnosticsChannel.channel("undici:request:error"),
    open: diagnosticsChannel.channel("undici:websocket:open"),
    close: diagnosticsChannel.channel("undici:websocket:close"),
    socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
    ping: diagnosticsChannel.channel("undici:websocket:ping"),
    pong: diagnosticsChannel.channel("undici:websocket:pong")
  };
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debuglog("connecting to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
    });
    diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt;
      debuglog("connected to %s using %s%s", `${host}${port ? `:${port}` : ""}`, protocol, version);
    });
    diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
      const {
        connectParams: { version, protocol, port, host },
        error
      } = evt;
      debuglog("connection to %s using %s%s errored - %s", `${host}${port ? `:${port}` : ""}`, protocol, version, error.message);
    });
    diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debuglog("sending request to %s %s/%s", method, origin, path);
    });
    diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
      const {
        request: { method, path, origin },
        response: { statusCode }
      } = evt;
      debuglog("received response to %s %s/%s - HTTP %d", method, origin, path, statusCode);
    });
    diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
      const {
        request: { method, path, origin }
      } = evt;
      debuglog("trailers received from %s %s/%s", method, origin, path);
    });
    diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
      const {
        request: { method, path, origin },
        error
      } = evt;
      debuglog("request to %s %s/%s errored - %s", method, origin, path, error.message);
    });
    isClientSet = true;
  }
  if (websocketDebuglog.enabled) {
    if (!isClientSet) {
      const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog("connecting to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
      });
      diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog("connected to %s%s using %s%s", host, port ? `:${port}` : "", protocol, version);
      });
      diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host },
          error
        } = evt;
        debuglog("connection to %s%s using %s%s errored - %s", host, port ? `:${port}` : "", protocol, version, error.message);
      });
      diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
        const {
          request: { method, path, origin }
        } = evt;
        debuglog("sending request to %s %s/%s", method, origin, path);
      });
    }
    diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
      const {
        address: { address, port }
      } = evt;
      websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
    });
    diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
      const { websocket, code, reason } = evt;
      websocketDebuglog("closed connection to %s - %s %s", websocket.url, code, reason);
    });
    diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
      websocketDebuglog("connection errored - %s", err.message);
    });
    diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
      websocketDebuglog("ping received");
    });
    diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
      websocketDebuglog("pong received");
    });
  }
  module.exports = {
    channels
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("node:assert");
  var {
    isValidHTTPToken,
    isValidHeaderValue,
    isStream,
    destroy,
    isBuffer,
    isFormDataLike,
    isIterable,
    isBlobLike,
    buildURL,
    validateHandler,
    getServerName,
    normalizedMethodRecords
  } = require_util();
  var { channels } = require_diagnostics();
  var { headerNameLowerCasedRecord } = require_constants();
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue,
      servername
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.test(path)) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? buildURL(path, query) : path;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = [];
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        if (headers[Symbol.iterator]) {
          for (const header of headers) {
            if (!Array.isArray(header) || header.length !== 2) {
              throw new InvalidArgumentError("headers must be in key-value pair format");
            }
            processHeader(this, header[0], header[1]);
          }
        } else {
          const keys = Object.keys(headers);
          for (let i = 0;i < keys.length; ++i) {
            processHeader(this, keys[i], headers[keys[i]]);
          }
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      validateHandler(handler, method, upgrade);
      this.servername = servername || getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  function processHeader(request, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === undefined) {
      headerName = key.toLowerCase();
      if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {
        throw new InvalidArgumentError("invalid header key");
      }
    }
    if (Array.isArray(val)) {
      const arr = [];
      for (let i = 0;i < val.length; i++) {
        if (typeof val[i] === "string") {
          if (!isValidHeaderValue(val[i])) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          arr.push(val[i]);
        } else if (val[i] === null) {
          arr.push("");
        } else if (typeof val[i] === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else {
          arr.push(`${val[i]}`);
        }
      }
      val = arr;
    } else if (typeof val === "string") {
      if (!isValidHeaderValue(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
    } else if (val === null) {
      val = "";
    } else {
      val = `${val}`;
    }
    if (request.host === null && headerName === "host") {
      if (typeof val !== "string") {
        throw new InvalidArgumentError("invalid host header");
      }
      request.host = val;
    } else if (request.contentLength === null && headerName === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && headerName === "content-type") {
      request.contentType = val;
      request.headers.push(key, val);
    } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
      throw new InvalidArgumentError(`invalid ${headerName} header`);
    } else if (headerName === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      }
      if (value === "close") {
        request.reset = true;
      }
    } else if (headerName === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers.push(key, val);
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...args) {
      const interceptors = Array.isArray(args[0]) ? args[0] : args;
      let dispatch = this.dispatch.bind(this);
      for (const interceptor of interceptors) {
        if (interceptor == null) {
          continue;
        }
        if (typeof interceptor !== "function") {
          throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
        }
        dispatch = interceptor(dispatch);
        if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
          throw new TypeError("invalid interceptor");
        }
      }
      return new ComposedDispatcher(this, dispatch);
    }
  }

  class ComposedDispatcher extends Dispatcher {
    #dispatcher = null;
    #dispatch = null;
    constructor(dispatcher, dispatch) {
      super();
      this.#dispatcher = dispatcher;
      this.#dispatch = dispatch;
    }
    dispatch(...args) {
      this.#dispatch(...args);
    }
    close(...args) {
      return this.#dispatcher.close(...args);
    }
    destroy(...args) {
      return this.#dispatcher.destroy(...args);
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = require_symbols();
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/util/timers.js
var require_timers = __commonJS((exports, module) => {
  var fastNow = 0;
  var RESOLUTION_MS = 1000;
  var TICK_MS = (RESOLUTION_MS >> 1) - 1;
  var fastNowTimeout;
  var kFastTimer = Symbol("kFastTimer");
  var fastTimers = [];
  var NOT_IN_LIST = -2;
  var TO_BE_CLEARED = -1;
  var PENDING = 0;
  var ACTIVE = 1;
  function onTick() {
    fastNow += TICK_MS;
    let idx = 0;
    let len = fastTimers.length;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer._state === PENDING) {
        timer._idleStart = fastNow - TICK_MS;
        timer._state = ACTIVE;
      } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
        timer._state = TO_BE_CLEARED;
        timer._idleStart = -1;
        timer._onTimeout(timer._timerArg);
      }
      if (timer._state === TO_BE_CLEARED) {
        timer._state = NOT_IN_LIST;
        if (--len !== 0) {
          fastTimers[idx] = fastTimers[len];
        }
      } else {
        ++idx;
      }
    }
    fastTimers.length = len;
    if (fastTimers.length !== 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTick, TICK_MS);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }

  class FastTimer {
    [kFastTimer] = true;
    _state = NOT_IN_LIST;
    _idleTimeout = -1;
    _idleStart = -1;
    _onTimeout;
    _timerArg;
    constructor(callback, delay, arg) {
      this._onTimeout = callback;
      this._idleTimeout = delay;
      this._timerArg = arg;
      this.refresh();
    }
    refresh() {
      if (this._state === NOT_IN_LIST) {
        fastTimers.push(this);
      }
      if (!fastNowTimeout || fastTimers.length === 1) {
        refreshTimeout();
      }
      this._state = PENDING;
    }
    clear() {
      this._state = TO_BE_CLEARED;
      this._idleStart = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, arg) {
      return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
    },
    clearTimeout(timeout) {
      if (timeout[kFastTimer]) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    },
    setFastTimeout(callback, delay, arg) {
      return new FastTimer(callback, delay, arg);
    },
    clearFastTimeout(timeout) {
      timeout.clear();
    },
    now() {
      return fastNow;
    },
    tick(delay = 0) {
      fastNow += delay - RESOLUTION_MS + 1;
      onTick();
      onTick();
    },
    reset() {
      fastNow = 0;
      fastTimers.length = 0;
      clearTimeout(fastNowTimeout);
      fastNowTimeout = null;
    },
    kFastTimer
  };
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var net = __require("node:net");
  var assert = __require("node:assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var timers = require_timers();
  function noop() {}
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("node:tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        assert(sessionKey);
        const session = customSession || sessionCache.get(sessionKey) || null;
        port = port || 443;
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        port = port || 80;
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    let s2 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  } : (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop;
    }
    let s1 = null;
    const fastTimer = timers.setFastTimeout(() => {
      s1 = setImmediate(() => {
        onConnectTimeout(socketWeakRef.deref(), opts);
      });
    }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer);
      clearImmediate(s1);
    };
  };
  function onConnectTimeout(socket, opts) {
    if (socket == null) {
      return;
    }
    let message = "Connect Timeout Error";
    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
      message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
    } else {
      message += ` (attempted address: ${opts.hostname}:${opts.port},`;
    }
    message += ` timeout: ${opts.timeout}ms)`;
    util.destroy(socket, new ConnectTimeoutError(message));
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  module.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  module.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK77MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
});

// node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "4190",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6679",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicySet = new Set(referrerPolicy);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  module.exports = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
  var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55;
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    for (let i = 0;i < length; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead)))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail)))
        trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result;
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType,
    removeChars,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode
  };
});

// node_modules/undici/lib/web/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types, inspect } = __require("node:util");
  var { markAsUncloneable } = __require("node:worker_threads");
  var { toUSVString } = require_util();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts) {
    if (opts?.strict !== false) {
      if (!(V instanceof I)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    } else {
      if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.markAsUncloneable = markAsUncloneable || (() => {});
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts?.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts?.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case "Symbol":
        return `Symbol(${V.description})`;
      case "Object":
        return inspect(V);
      case "String":
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
      const seq = [];
      let index = 0;
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, prefix, argument, opts) => {
      if (opts?.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = Object.hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value ??= defaultValue();
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.converters.DOMString = function(V, prefix, argument, opts) {
    if (V === null && opts?.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    const x = webidl.converters.DOMString(V, prefix, argument);
    for (let index = 0;index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", undefined, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.resizable || V.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${name} is not a DataView.`
      });
    }
    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, name, opts) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: ["BufferSource"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/web/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var zlib = __require("node:zlib");
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants3();
  var { getGlobalOrigin } = require_global();
  var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
  var { performance: performance2 } = __require("node:perf_hooks");
  var { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util();
  var assert = __require("node:assert");
  var { isUint8Array } = __require("node:util/types");
  var { webidl } = require_webidl();
  var supportedHashes = [];
  var crypto2;
  try {
    crypto2 = __require("node:crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {}
  function responseURL(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location", true);
    if (location !== null && isValidHeaderValue(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0;i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  var isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "\t" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "\t" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes(`
`) || potentialValue.includes("\r") || potentialValue.includes("\x00")) === false;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (serializedOrigin === "client" || serializedOrigin === undefined) {
      return;
    }
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      request.headersList.append("origin", serializedOrigin, true);
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      request.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert(url instanceof URL);
    url = new URL(url);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1;i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0;i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0;i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {

    class FastIterableIterator {
      #target;
      #kind;
      #index;
      constructor(target, kind) {
        this.#target = target;
        this.#kind = kind;
        this.#index = 0;
      }
      next() {
        if (typeof this !== "object" || this === null || !(#target in this)) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const index = this.#index;
        const values = this.#target[kInternalIterator];
        const len = values.length;
        if (index >= len) {
          return {
            value: undefined,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        this.#index = index + 1;
        let result;
        switch (this.#kind) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      successSteps(await readAllBytes(reader));
    } catch (e) {
      errorSteps(e);
    }
  }
  function isReadableStreamLike(stream) {
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
      controller.byobRequest?.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeStart = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints((char) => char === "\t" || char === " ", data, position);
    }
    const rangeEnd = collectASequenceOfCodePoints((char) => {
      const code = char.charCodeAt(0);
      return code >= 48 && code <= 57;
    }, data, position);
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }

  class InflateStream extends Transform {
    #zlibOptions;
    constructor(zlibOptions) {
      super();
      this.#zlibOptions = zlibOptions;
    }
    _transform(chunk, encoding, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints((char) => char !== '"' && char !== ",", input, position);
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(input, position);
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  var textDecoder = new TextDecoder;
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }

  class EnvironmentSettingsObjectBase {
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = makePolicyContainer();
  }

  class EnvironmentSettingsObject {
    settingsObject = new EnvironmentSettingsObjectBase;
  }
  var environmentSettingsObject = new EnvironmentSettingsObject;
  module.exports = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    createDeferredPromise,
    ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    parseMetadata,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    utf8DecodeBytes,
    environmentSettingsObject
  };
});

// node_modules/undici/lib/web/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kDispatcher: Symbol("dispatcher")
  };
});

// node_modules/undici/lib/web/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var { Blob: Blob2, File } = __require("node:buffer");
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  function isFileLike(object) {
    return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  module.exports = { FileLike, isFileLike };
});

// node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var { isBlobLike, iteratorMixin } = require_util2();
  var { kState } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var { FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { File: NativeFile } = __require("node:buffer");
  var nodeUtil = __require("node:util");
  var File = globalThis.File ?? NativeFile;

  class FormData2 {
    constructor(form) {
      webidl.util.markAsUncloneable(this);
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    [nodeUtil.inspect.custom](depth, options) {
      const state = this[kState].reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ??= depth;
      options.colors ??= true;
      const output = nodeUtil.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
  }
  iteratorMixin("FormData", FormData2, kState, "name", "value");
  Object.defineProperties(FormData2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") {} else {
      if (!isFileLike(value)) {
        value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = value instanceof NativeFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  module.exports = { FormData: FormData2, makeEntry };
});

// node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS((exports, module) => {
  var { isUSVString, bufferToLowerCasedHeaderName } = require_util();
  var { utf8DecodeBytes } = require_util2();
  var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
  var { isFileLike } = require_file();
  var { makeEntry } = require_formdata();
  var assert = __require("node:assert");
  var { File: NodeFile } = __require("node:buffer");
  var File = globalThis.File ?? NodeFile;
  var formDataNameBuffer = Buffer.from('form-data; name="');
  var filenameBuffer = Buffer.from("; filename");
  var dd = Buffer.from("--");
  var ddcrlf = Buffer.from(`--\r
`);
  function isAsciiString(chars) {
    for (let i = 0;i < chars.length; ++i) {
      if ((chars.charCodeAt(i) & ~127) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0;i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === undefined) {
      return "failure";
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    while (input[position.position] === 13 && input[position.position + 1] === 10) {
      position.position += 2;
    }
    let trailing = input.length;
    while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
      trailing -= 2;
    }
    if (trailing !== input.length) {
      input = input.subarray(0, trailing);
    }
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        return "failure";
      }
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      if (result === "failure") {
        return "failure";
      }
      let { name, filename, contentType, encoding } = result;
      position.position += 2;
      let body;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          return "failure";
        }
        body = input.subarray(position.position, boundaryIndex - 4);
        position.position += body.length;
        if (encoding === "base64") {
          body = Buffer.from(body.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ??= "text/plain";
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body));
      }
      assert(isUSVString(name));
      assert(typeof value === "string" && isUSVString(value) || isFileLike(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          return "failure";
        }
        return { name, filename, contentType, encoding };
      }
      let headerName = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 58, input, position);
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        return "failure";
      }
      if (input[position.position] !== 58) {
        return "failure";
      }
      position.position++;
      collectASequenceOfBytes((char) => char === 32 || char === 9, input, position);
      switch (bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition": {
          name = filename = null;
          if (!bufferStartsWith(input, formDataNameBuffer, position)) {
            return "failure";
          }
          position.position += 17;
          name = parseMultipartFormDataName(input, position);
          if (name === null) {
            return "failure";
          }
          if (bufferStartsWith(input, filenameBuffer, position)) {
            let check = position.position + filenameBuffer.length;
            if (input[check] === 42) {
              position.position += 1;
              check += 1;
            }
            if (input[check] !== 61 || input[check + 1] !== 34) {
              return "failure";
            }
            position.position += 12;
            filename = parseMultipartFormDataName(input, position);
            if (filename === null) {
              return "failure";
            }
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes((char) => char !== 10 && char !== 13, input, position);
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
    }
  }
  function parseMultipartFormDataName(input, position) {
    assert(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes((char) => char !== 10 && char !== 13 && char !== 34, input, position);
    if (input[position.position] !== 34) {
      return null;
    } else {
      position.position++;
    }
    name = new TextDecoder().decode(name).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"');
    return name;
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead]))
        lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(buf[trail]))
        trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i = 0;i < start.length; i++) {
      if (start[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  module.exports = {
    multipartFormDataParser,
    validateBoundary
  };
});

// node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody,
    extractMimeType,
    utf8DecodeBytes
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { Blob: Blob2 } = __require("node:buffer");
  var assert = __require("node:assert");
  var { isErrored, isDisturbed } = __require("node:stream");
  var { isArrayBuffer } = __require("node:util/types");
  var { serializeAMimeType } = require_data_url();
  var { multipartFormDataParser } = require_formdata_parser();
  var random;
  try {
    const crypto2 = __require("node:crypto");
    random = (max) => crypto2.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random(max));
  }
  var textEncoder = new TextEncoder;
  function noop() {}
  var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  var streamRegistry;
  if (hasFinalizationRegistry) {
    streamRegistry = new FinalizationRegistry((weakRef) => {
      const stream = weakRef.deref();
      if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
        stream.cancel("Response object has been garbage collected").catch(noop);
      }
    });
  }
  function extractBody(object, keepalive = false) {
    let stream = null;
    if (object instanceof ReadableStream) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        async pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {},
        type: "bytes"
      });
    }
    assert(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${random(100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`);
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
` + `Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--\r
`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
              controller.byobRequest?.respond(0);
            });
          } else {
            if (!isErrored(stream)) {
              const buffer = new Uint8Array(value);
              if (buffer.byteLength) {
                controller.enqueue(buffer);
              }
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    const body = { stream, source, length };
    return [body, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (object instanceof ReadableStream) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(instance, body) {
    const [out1, out2] = body.stream.tee();
    if (hasFinalizationRegistry) {
      streamRegistry.register(instance, new WeakRef(out1));
    }
    body.stream = out1;
    return {
      stream: out2,
      length: body.length,
      source: body.source
    };
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(this);
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                if (parsed === "failure") {
                  throw new TypeError("Failed to parse body as FormData.");
                }
                const fd = new FormData2;
                fd[kState] = parsed;
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData2;
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, instance);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance);
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function consumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    if (bodyUnusable(object)) {
      throw new TypeError("Body is unusable: Body has already been read");
    }
    throwIfAborted(object[kState]);
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(object) {
    const body = object[kState].body;
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(requestOrResponse) {
    const headers = requestOrResponse[kState].headersList;
    const mimeType = extractMimeType(headers);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    hasFinalizationRegistry,
    bodyUnusable
  };
});

// node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var util = require_util();
  var { channels } = require_diagnostics();
  var timers = require_timers();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kParser,
    kBlocking,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kMaxRequests,
    kCounter,
    kMaxResponseSize,
    kOnError,
    kResume,
    kHTTPContext
  } = require_symbols();
  var constants = require_constants2();
  var EMPTY_BUF = Buffer.alloc(0);
  var FastBuffer = Buffer[Symbol.species];
  var addListener = util.addListener;
  var removeAllListeners = util.removeAllListeners;
  var extractBody;
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(require_llhttp_simd_wasm());
    } catch (e) {
      mod = await WebAssembly.compile(llhttpWasmData || require_llhttp_wasm());
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert(currentParser.ptr === p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert(currentParser.ptr === p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert(currentParser.ptr === p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var USE_NATIVE_TIMER = 0;
  var USE_FAST_TIMER = 1;
  var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
  var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
  var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(delay, type) {
      if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
        if (this.timeout) {
          timers.clearTimeout(this.timeout);
          this.timeout = null;
        }
        if (delay) {
          if (type & USE_FAST_TIMER) {
            this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
          } else {
            this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
            this.timeout.unref();
          }
        }
        this.timeoutValue = delay;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.timeoutType = type;
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      this.timeout && timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      request.onResponseStarted();
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10) {
        const headerName = util.bufferToLowerCasedHeaderName(key);
        if (headerName === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (headerName === "connection") {
          this.connection += buf.toString();
        }
      } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      assert(client[kSocket] === socket);
      assert(!socket.destroyed);
      assert(!this.paused);
      assert((headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      removeAllListeners(socket);
      client[kSocket] = null;
      client[kHTTPContext] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      client[kResume]();
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert(this.timeoutType === TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert((this.headers.length & 1) === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      if (request.aborted) {
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        client[kResume]();
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      if (request.onData(buf) === false) {
        return constants.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      assert(statusCode >= 100);
      assert((this.headers.length & 1) === 0);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      request.onComplete(headers);
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert(client[kRunning] === 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] == null || client[kPipelining] === 1) {
        setImmediate(() => client[kResume]());
      } else {
        client[kResume]();
      }
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client, paused } = parser.deref();
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  async function connectH1(client, socket) {
    client[kSocket] = socket;
    if (!llhttpInstance) {
      llhttpInstance = await llhttpPromise;
      llhttpPromise = null;
    }
    socket[kNoRef] = false;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kBlocking] = false;
    socket[kParser] = new Parser(client, socket, llhttpInstance);
    addListener(socket, "error", function(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const parser = this[kParser];
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    addListener(socket, "readable", function() {
      const parser = this[kParser];
      if (parser) {
        parser.readMore();
      }
    });
    addListener(socket, "end", function() {
      const parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    });
    addListener(socket, "close", function() {
      const client2 = this[kClient];
      const parser = this[kParser];
      if (parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client2[kSocket] = null;
      client2[kHTTPContext] = null;
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        const requests = client2[kQueue].splice(client2[kRunningIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client2, request, err);
        }
      } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client2[kQueue][client2[kRunningIdx]];
        client2[kQueue][client2[kRunningIdx]++] = null;
        util.errorRequest(client2, request, err);
      }
      client2[kPendingIdx] = client2[kRunningIdx];
      assert(client2[kRunning] === 0);
      client2.emit("disconnect", client2[kUrl], [client2], err);
      client2[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h1",
      defaultPipelining: 1,
      write(...args) {
        return writeH1(client, ...args);
      },
      resume() {
        resumeH1(client);
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request) {
        if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return true;
        }
        if (request) {
          if (client[kRunning] > 0 && !request.idempotent) {
            return true;
          }
          if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
            return true;
          }
          if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
            return true;
          }
        }
        return false;
      }
    };
  }
  function resumeH1(client) {
    const socket = client[kSocket];
    if (socket && !socket.destroyed) {
      if (client[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref();
          socket[kNoRef] = true;
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref();
        socket[kNoRef] = false;
      }
      if (client[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
        }
      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request = client[kQueue][client[kRunningIdx]];
          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
        }
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH1(client, request) {
    const { method, path, host, upgrade, blocking, reset } = request;
    let { body, headers, contentLength } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
    if (util.isFormDataLike(body)) {
      if (!extractBody) {
        extractBody = require_body().extractBody;
      }
      const [bodyStream, contentType] = extractBody(body);
      if (request.contentType == null) {
        headers.push("content-type", contentType);
      }
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
      headers.push("content-type", body.type);
    }
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    contentLength = bodyLength ?? contentLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      util.errorRequest(client, request, err || new RequestAbortedError);
      util.destroy(body);
      util.destroy(socket, new InformationalError("aborted"));
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += `connection: keep-alive\r
`;
    } else {
      header += `connection: close\r
`;
    }
    if (Array.isArray(headers)) {
      for (let n = 0;n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0;i < val.length; i++) {
            header += `${key}: ${val[i]}\r
`;
          }
        } else {
          header += `${key}: ${val}\r
`;
        }
      }
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBuffer(body)) {
      writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
      } else {
        writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
      }
    } else if (util.isStream(body)) {
      writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else if (util.isIterable(body)) {
      writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
    } else {
      assert(false);
    }
    return true;
  }
  function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onClose = function() {
      queueMicrotask(() => {
        body.removeListener("error", onFinished);
      });
      if (!finished) {
        const err = new RequestAbortedError;
        queueMicrotask(() => onFinished(err));
      }
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
    if (body.errorEmitted ?? body.errored) {
      setImmediate(() => onFinished(body.errored));
    } else if (body.endEmitted ?? body.readableEnded) {
      setImmediate(() => onFinished(null));
    }
    if (body.closeEmitted ?? body.closed) {
      setImmediate(onClose);
    }
  }
  function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    try {
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
      }
      request.onRequestSent();
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload && request.reset !== false) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      this.abort = abort;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write(`\r
0\r
\r
`, "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      client[kResume]();
    }
    destroy(err) {
      const { socket, client, abort } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        abort(err);
      }
    }
  }
  module.exports = connectH1;
});

// node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { pipeline } = __require("node:stream");
  var util = require_util();
  var {
    RequestContentLengthMismatchError,
    RequestAbortedError,
    SocketError,
    InformationalError
  } = require_errors();
  var {
    kUrl,
    kReset,
    kClient,
    kRunning,
    kPending,
    kQueue,
    kPendingIdx,
    kRunningIdx,
    kError,
    kSocket,
    kStrictContentLength,
    kOnError,
    kMaxConcurrentStreams,
    kHTTP2Session,
    kResume,
    kSize,
    kHTTPContext
  } = require_symbols();
  var kOpenStreams = Symbol("open streams");
  var extractBody;
  var h2ExperimentalWarned = false;
  var http2;
  try {
    http2 = __require("node:http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  function parseH2Headers(headers) {
    const result = [];
    for (const [name, value] of Object.entries(headers)) {
      if (Array.isArray(value)) {
        for (const subvalue of value) {
          result.push(Buffer.from(name), Buffer.from(subvalue));
        }
      } else {
        result.push(Buffer.from(name), Buffer.from(value));
      }
    }
    return result;
  }
  async function connectH2(client, socket) {
    client[kSocket] = socket;
    if (!h2ExperimentalWarned) {
      h2ExperimentalWarned = true;
      process.emitWarning("H2 support is experimental, expect them to change at any time.", {
        code: "UNDICI-H2"
      });
    }
    const session = http2.connect(client[kUrl], {
      createConnection: () => socket,
      peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
    });
    session[kOpenStreams] = 0;
    session[kClient] = client;
    session[kSocket] = socket;
    util.addListener(session, "error", onHttp2SessionError);
    util.addListener(session, "frameError", onHttp2FrameError);
    util.addListener(session, "end", onHttp2SessionEnd);
    util.addListener(session, "goaway", onHTTP2GoAway);
    util.addListener(session, "close", function() {
      const { [kClient]: client2 } = this;
      const { [kSocket]: socket2 } = client2;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket2));
      client2[kHTTP2Session] = null;
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        const requests = client2[kQueue].splice(client2[kRunningIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client2, request, err);
        }
      }
    });
    session.unref();
    client[kHTTP2Session] = session;
    socket[kHTTP2Session] = session;
    util.addListener(socket, "error", function(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    });
    util.addListener(socket, "end", function() {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    });
    util.addListener(socket, "close", function() {
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (this[kHTTP2Session] != null) {
        this[kHTTP2Session].destroy(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    });
    let closed = false;
    socket.on("close", () => {
      closed = true;
    });
    return {
      version: "h2",
      defaultPipelining: Infinity,
      write(...args) {
        return writeH2(client, ...args);
      },
      resume() {
        resumeH2(client);
      },
      destroy(err, callback) {
        if (closed) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy() {
        return false;
      }
    };
  }
  function resumeH2(client) {
    const socket = client[kSocket];
    if (socket?.destroyed === false) {
      if (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0) {
        socket.unref();
        client[kHTTP2Session].unref();
      } else {
        socket.ref();
        client[kHTTP2Session].ref();
      }
    }
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2FrameError(type, code, id) {
    if (id === 0) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
  }
  function onHttp2SessionEnd() {
    const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
    this.destroy(err);
    util.destroy(this[kSocket], err);
  }
  function onHTTP2GoAway(code) {
    const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${code}`, util.getSocketInfo(this));
    const client = this[kClient];
    client[kSocket] = null;
    client[kHTTPContext] = null;
    if (this[kHTTP2Session] != null) {
      this[kHTTP2Session].destroy(err);
      this[kHTTP2Session] = null;
    }
    util.destroy(this[kSocket], err);
    if (client[kRunningIdx] < client[kQueue].length) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      util.errorRequest(client, request, err);
      client[kPendingIdx] = client[kRunningIdx];
    }
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    client[kResume]();
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH2(client, request) {
    const session = client[kHTTP2Session];
    const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
    let { body } = request;
    if (upgrade) {
      util.errorRequest(client, request, new Error("Upgrade not supported for H2"));
      return false;
    }
    const headers = {};
    for (let n = 0;n < reqHeaders.length; n += 2) {
      const key = reqHeaders[n + 0];
      const val = reqHeaders[n + 1];
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          if (headers[key]) {
            headers[key] += `,${val[i]}`;
          } else {
            headers[key] = val[i];
          }
        }
      } else {
        headers[key] = val;
      }
    }
    let stream;
    const { hostname, port } = client[kUrl];
    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
    headers[HTTP2_HEADER_METHOD] = method;
    const abort = (err) => {
      if (request.aborted || request.completed) {
        return;
      }
      err = err || new RequestAbortedError;
      util.errorRequest(client, request, err);
      if (stream != null) {
        util.destroy(stream, err);
      }
      util.destroy(body, err);
      client[kQueue][client[kRunningIdx]++] = null;
      client[kResume]();
    };
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request.onUpgrade(null, null, stream);
        ++session[kOpenStreams];
        client[kQueue][client[kRunningIdx]++] = null;
      } else {
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        });
      }
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0)
          session.unref();
      });
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path;
    headers[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (util.isFormDataLike(body)) {
      extractBody ??= require_body().extractBody;
      const [bodyStream, contentType] = extractBody(body);
      headers["content-type"] = contentType;
      body = bodyStream.stream;
      contentLength = bodyStream.length;
    }
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        util.errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++session[kOpenStreams];
    stream.once("response", (headers2) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      request.onResponseStarted();
      if (request.aborted) {
        const err = new RequestAbortedError;
        util.errorRequest(client, request, err);
        util.destroy(stream, err);
        return;
      }
      if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
    });
    stream.once("end", () => {
      if (stream.state?.state == null || stream.state.state < 6) {
        request.onComplete([]);
      }
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
      abort(new InformationalError("HTTP/2: stream half-closed (remote)"));
      client[kQueue][client[kRunningIdx]++] = null;
      client[kPendingIdx] = client[kRunningIdx];
      client[kResume]();
    });
    stream.once("close", () => {
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      abort(err);
    });
    stream.once("frameError", (type, code) => {
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    });
    return true;
    function writeBodyH2() {
      if (!body || contentLength === 0) {
        writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);
        } else {
          writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);
      } else if (util.isIterable(body)) {
        writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);
      } else {
        assert(false);
      }
    }
  }
  function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    try {
      if (body != null && util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        h2stream.cork();
        h2stream.write(body);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(body);
      }
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      request.onRequestSent();
      client[kResume]();
    } catch (error) {
      abort(error);
    }
  }
  function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    const pipe = pipeline(body, h2stream, (err) => {
      if (err) {
        util.destroy(pipe, err);
        abort(err);
      } else {
        util.removeAllListeners(pipe);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      }
    });
    util.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk) {
      request.onBodySent(chunk);
    }
  }
  async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      h2stream.cork();
      h2stream.write(buffer);
      h2stream.uncork();
      h2stream.end();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        const res = h2stream.write(chunk);
        request.onBodySent(chunk);
        if (!res) {
          await waitForDrain();
        }
      }
      h2stream.end();
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  module.exports = connectH2;
});

// node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS((exports, module) => {
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("node:assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("node:events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      this.redirectionLimitReached = false;
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        if (this.request) {
          this.request.abort(new Error("max redirects"));
        }
        this.redirectionLimitReached = true;
        this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {} else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0;i < headers.length; i += 2) {
      if (headers[i].length === 8 && util.headerNameToString(headers[i]) === "location") {
        return headers[i + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util.headerNameToString(header) === "host";
    }
    if (removeContent && util.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirect-interceptor.js
var require_redirect_interceptor = __commonJS((exports, module) => {
  var RedirectHandler = require_redirect_handler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var net = __require("node:net");
  var http = __require("node:http");
  var util = require_util();
  var { channels } = require_diagnostics();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    InvalidArgumentError,
    InformationalError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kServerName,
    kClient,
    kBusy,
    kConnect,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kOnError,
    kHTTPContext,
    kMaxConcurrentStreams,
    kResume
  } = require_symbols();
  var connectH1 = require_client_h1();
  var connectH2 = require_client_h2();
  var deprecatedInterceptorWarned = false;
  var kClosedResolve = Symbol("kClosedResolve");
  var noop = () => {};
  function getPipelining(client) {
    return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
  }

  class Client2 extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      maxConcurrentStreams,
      allowH2
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      if (interceptors?.Client && Array.isArray(interceptors.Client)) {
        this[kInterceptors] = interceptors.Client;
        if (!deprecatedInterceptorWarned) {
          deprecatedInterceptorWarned = true;
          process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
            code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
          });
        }
      } else {
        this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })];
      }
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
      this[kHTTPContext] = null;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
      this[kResume] = (sync) => resume(this, sync);
      this[kOnError] = (err) => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      this[kResume](true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = new Request(origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {} else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        queueMicrotask(() => resume(this));
      } else {
        this[kResume](true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (this[kSize]) {
          this[kClosedResolve] = resolve;
        } else {
          resolve(null);
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve(null);
        };
        if (this[kHTTPContext]) {
          this[kHTTPContext].destroy(err, callback);
          this[kHTTPContext] = null;
        } else {
          queueMicrotask(callback);
        }
        this[kResume]();
      });
    }
  }
  var createRedirectInterceptor = require_redirect_interceptor();
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        util.errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kHTTPContext]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", noop), new ClientDestroyedError);
        return;
      }
      assert(socket);
      try {
        client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
      } catch (err) {
        socket.destroy().on("error", noop);
        throw err;
      }
      client[kConnecting] = false;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          util.errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    client[kResume]();
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      if (client[kHTTPContext]) {
        client[kHTTPContext].resume();
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          queueMicrotask(() => emitDrain(client));
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (getPipelining(client) || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          client[kHTTPContext] = null;
          resume(client);
        });
      }
      if (client[kConnecting]) {
        return;
      }
      if (!client[kHTTPContext]) {
        connect(client);
        return;
      }
      if (client[kHTTPContext].destroyed) {
        return;
      }
      if (client[kHTTPContext].busy(request)) {
        return;
      }
      if (!request.aborted && client[kHTTPContext].write(request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  module.exports = Client2;
});

// node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/dispatcher/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        await Promise.all(this[kClients].map((c) => c.close()));
      } else {
        await new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      await Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        queueMicrotask(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client2 = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client2(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
      this.on("connectionError", (origin2, targets, error) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      for (const client of this[kClients]) {
        if (!client[kNeedDrain]) {
          return client;
        }
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
        return dispatcher;
      }
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (a === 0)
      return b;
    while (b !== 0) {
      const t = b;
      b = a % b;
      a = t;
    }
    return a;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      let result = 0;
      for (let i = 0;i < this[kClients].length; i++) {
        result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
      }
      this[kGreatestCommonDivisor] = result;
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client2 = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirect_interceptor();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const client of this[kClients].values()) {
        ret += client[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      let dispatcher = this[kClients].get(key);
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, dispatcher);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const client of this[kClients].values()) {
        closePromises.push(client.close());
      }
      this[kClients].clear();
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const client of this[kClients].values()) {
        destroyPromises.push(client.destroy(err));
      }
      this[kClients].clear();
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("node:url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors();
  var buildConnector = require_connect();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  var noop = () => {};

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super();
      if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
        throw new InvalidArgumentError("Proxy uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      const url = this.#getUrl(opts);
      const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
      this[kProxy] = { uri: href, protocol };
      this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(url, { connect });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedPath = opts2.host;
          if (!opts2.port) {
            requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedPath,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts2.host
              },
              servername: this[kProxyTls]?.servername || proxyHostname
            });
            if (statusCode !== 200) {
              socket.on("error", noop).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              callback(new SecureProxyConnectionError(err));
            } else {
              callback(err);
            }
          }
        }
      });
    }
    dispatch(opts, handler) {
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      if (headers && !("host" in headers) && !("Host" in headers)) {
        const { host } = new URL2(opts.origin);
        headers.host = host;
      }
      return this[kAgent].dispatch({
        ...opts,
        headers
      }, handler);
    }
    #getUrl(opts) {
      if (typeof opts === "string") {
        return new URL2(opts);
      } else if (opts instanceof URL2) {
        return opts;
      } else {
        return new URL2(opts.uri);
      }
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols();
  var ProxyAgent = require_proxy_agent();
  var Agent = require_agent();
  var DEFAULT_PORTS = {
    "http:": 80,
    "https:": 443
  };
  var experimentalWarned = false;

  class EnvHttpProxyAgent extends DispatcherBase {
    #noProxyValue = null;
    #noProxyEntries = null;
    #opts = null;
    constructor(opts = {}) {
      super();
      this.#opts = opts;
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
          code: "UNDICI-EHPA"
        });
      }
      const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
      this[kNoProxyAgent] = new Agent(agentOpts);
      const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      if (HTTP_PROXY) {
        this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
      } else {
        this[kHttpProxyAgent] = this[kNoProxyAgent];
      }
      const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      if (HTTPS_PROXY) {
        this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
      } else {
        this[kHttpsProxyAgent] = this[kHttpProxyAgent];
      }
      this.#parseNoProxy();
    }
    [kDispatch](opts, handler) {
      const url = new URL(opts.origin);
      const agent = this.#getProxyAgentForUrl(url);
      return agent.dispatch(opts, handler);
    }
    async[kClose]() {
      await this[kNoProxyAgent].close();
      if (!this[kHttpProxyAgent][kClosed]) {
        await this[kHttpProxyAgent].close();
      }
      if (!this[kHttpsProxyAgent][kClosed]) {
        await this[kHttpsProxyAgent].close();
      }
    }
    async[kDestroy](err) {
      await this[kNoProxyAgent].destroy(err);
      if (!this[kHttpProxyAgent][kDestroyed]) {
        await this[kHttpProxyAgent].destroy(err);
      }
      if (!this[kHttpsProxyAgent][kDestroyed]) {
        await this[kHttpsProxyAgent].destroy(err);
      }
    }
    #getProxyAgentForUrl(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!this.#shouldProxy(hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    }
    #shouldProxy(hostname, port) {
      if (this.#noProxyChanged) {
        this.#parseNoProxy();
      }
      if (this.#noProxyEntries.length === 0) {
        return true;
      }
      if (this.#noProxyValue === "*") {
        return false;
      }
      for (let i = 0;i < this.#noProxyEntries.length; i++) {
        const entry = this.#noProxyEntries[i];
        if (entry.port && entry.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry.hostname)) {
          if (hostname === entry.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    }
    #parseNoProxy() {
      const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i = 0;i < noProxySplit.length; i++) {
        const entry = noProxySplit[i];
        if (!entry) {
          continue;
        }
        const parsed = entry.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      this.#noProxyValue = noProxyValue;
      this.#noProxyEntries = noProxyEntries;
    }
    get #noProxyChanged() {
      if (this.#opts.noProxy !== undefined) {
        return false;
      }
      return this.#noProxyValue !== this.#noProxyEnv;
    }
    get #noProxyEnv() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  module.exports = EnvHttpProxyAgent;
});

// node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { kRetryHandlerDefaultRetry } = require_symbols();
  var { RequestRetryError } = require_errors();
  var {
    isDisturbed,
    parseHeaders,
    parseRangeHeader,
    wrapRequestBody
  } = require_util();
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }

  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1000,
        minTimeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      };
      this.retryCount = 0;
      this.retryCountCheckpoint = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
    }
    onConnect(abort) {
      if (this.aborted) {
        abort(this.reason);
      } else {
        this.abort = abort;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        minTimeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      const { counter } = state;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers?.["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = parseHeaders(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        if (this.retryOpts.statusCodes.includes(statusCode) === false) {
          return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
        } else {
          this.abort(new RequestRetryError("Request failed", statusCode, {
            headers,
            data: {
              count: this.retryCount
            }
          }));
          return false;
        }
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
          this.abort(new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        const contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) {
          this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        if (this.etag != null && this.etag !== headers.etag) {
          this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            data: { count: this.retryCount }
          }));
          return false;
        }
        const { start, size, end = size - 1 } = contentRange;
        assert(this.start === start, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          }
          const { start, size, end = size - 1 } = range;
          assert(start != null && Number.isFinite(start), "content-range mismatch");
          assert(end != null && Number.isFinite(end), "invalid content-length");
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) - 1 : null;
        }
        assert(Number.isFinite(this.start));
        assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
        this.resume = resume;
        this.etag = headers.etag != null ? headers.etag : null;
        if (this.etag != null && this.etag.startsWith("W/")) {
          this.etag = null;
        }
        return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers,
        data: { count: this.retryCount }
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      if (this.retryCount - this.retryCountCheckpoint > 0) {
        this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
      } else {
        this.retryCount += 1;
      }
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
          if (this.etag != null) {
            headers["if-match"] = this.etag;
          }
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...headers
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount;
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var RetryHandler = require_retry_handler();

  class RetryAgent extends Dispatcher {
    #agent = null;
    #options = null;
    constructor(agent, options = {}) {
      super(options);
      this.#agent = agent;
      this.#options = options;
    }
    dispatch(opts, handler) {
      const retry = new RetryHandler({
        ...opts,
        retryOptions: this.#options
      }, {
        dispatch: this.#agent.dispatch.bind(this.#agent),
        handler
      });
      return this.#agent.dispatch(opts, retry);
    }
    close() {
      return this.#agent.close();
    }
    destroy() {
      return this.#agent.destroy();
    }
  }
  module.exports = RetryAgent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = __require("node:stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom } = require_util();
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("kAbort");
  var kContentType = Symbol("kContentType");
  var kContentLength = Symbol("kContentLength");
  var noop = () => {};

  class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      contentLength,
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kContentLength] = contentLength;
      this[kReading] = false;
    }
    destroy(err) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    _destroy(err, callback) {
      if (!this[kReading]) {
        setImmediate(() => {
          callback(err);
        });
      } else {
        callback(err);
      }
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async bytes() {
      return consume(this, "bytes");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    async dump(opts) {
      let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;
      const signal = opts?.signal;
      if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
        throw new InvalidArgumentError("signal must be an AbortSignal");
      }
      signal?.throwIfAborted();
      if (this._readableState.closeEmitted) {
        return null;
      }
      return await new Promise((resolve, reject) => {
        if (this[kContentLength] > limit) {
          this.destroy(new AbortError);
        }
        const onAbort = () => {
          this.destroy(signal.reason ?? new AbortError);
        };
        signal?.addEventListener("abort", onAbort);
        this.on("close", function() {
          signal?.removeEventListener("abort", onAbort);
          if (signal?.aborted) {
            reject(signal.reason ?? new AbortError);
          } else {
            resolve(null);
          }
        }).on("error", noop).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  }
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      if (isUnusable(stream)) {
        const rState = stream._readableState;
        if (rState.destroyed && rState.closeEmitted === false) {
          stream.on("error", (err) => {
            reject(err);
          }).on("close", () => {
            reject(new TypeError("unusable"));
          });
        } else {
          reject(rState.errored ?? new TypeError("unusable"));
        }
      } else {
        queueMicrotask(() => {
          stream[kConsume] = {
            type,
            stream,
            resolve,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError);
            }
          });
          consumeStart(stream[kConsume]);
        });
      }
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    if (state.bufferIndex) {
      const start = state.bufferIndex;
      const end = state.buffer.length;
      for (let n = start;n < end; n++) {
        consumePush(consume2, state.buffer[n]);
      }
    } else {
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {}
  }
  function chunksDecode(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return "";
    }
    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
    const bufferLength = buffer.length;
    const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    return buffer.utf8Slice(start, bufferLength);
  }
  function chunksConcat(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return new Uint8Array(0);
    }
    if (chunks.length === 1) {
      return new Uint8Array(chunks[0]);
    }
    const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
    let offset = 0;
    for (let i = 0;i < chunks.length; ++i) {
      const chunk = chunks[i];
      buffer.set(chunk, offset);
      offset += chunk.length;
    }
    return buffer;
  }
  function consumeEnd(consume2) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(chunksDecode(body, length));
      } else if (type === "json") {
        resolve(JSON.parse(chunksDecode(body, length)));
      } else if (type === "arrayBuffer") {
        resolve(chunksConcat(body, length).buffer);
      } else if (type === "blob") {
        resolve(new Blob(body, { type: stream[kContentType] }));
      } else if (type === "bytes") {
        resolve(chunksConcat(body, length));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  module.exports = { Readable: BodyReadable, chunksDecode };
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { chunksDecode } = require_readable();
  var CHUNK_LIMIT = 128 * 1024;
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let length = 0;
    try {
      for await (const chunk of body) {
        chunks.push(chunk);
        length += chunk.length;
        if (length > CHUNK_LIMIT) {
          chunks = [];
          length = 0;
          break;
        }
      }
    } catch {
      chunks = [];
      length = 0;
    }
    const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
    if (statusCode === 204 || !contentType || !length) {
      queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)));
      return;
    }
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let payload;
    try {
      if (isContentTypeApplicationJson(contentType)) {
        payload = JSON.parse(chunksDecode(chunks, length));
      } else if (isContentTypeText(contentType)) {
        payload = chunksDecode(chunks, length);
      }
    } catch {} finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));
  }
  var isContentTypeApplicationJson = (contentType) => {
    return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
  };
  var isContentTypeText = (contentType) => {
    return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
  };
  module.exports = {
    getResolveErrorBodyCallback,
    isContentTypeApplicationJson,
    isContentTypeText
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { Readable } = require_readable();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("node:async_hooks");

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.method = method;
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      this.signal = signal;
      this.reason = null;
      this.removeAbortListener = null;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      if (this.signal) {
        if (this.signal.aborted) {
          this.reason = this.signal.reason ?? new RequestAbortedError;
        } else {
          this.removeAbortListener = util.addAbortListener(this.signal, () => {
            this.reason = this.signal.reason ?? new RequestAbortedError;
            if (this.res) {
              util.destroy(this.res.on("error", util.nop), this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
            if (this.removeAbortListener) {
              this.res?.off("close", this.removeAbortListener);
              this.removeAbortListener();
              this.removeAbortListener = null;
            }
          });
        }
      }
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const contentLength = parsedHeaders["content-length"];
      const res = new Readable({
        resume,
        abort,
        contentType,
        contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
        highWaterMark
      });
      if (this.removeAbortListener) {
        res.on("close", this.removeAbortListener);
      }
      this.callback = null;
      this.res = res;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        }
      }
    }
    onData(chunk) {
      return this.res.push(chunk);
    }
    onComplete(trailers) {
      util.parseHeaders(trailers, this.trailers);
      this.res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
      if (this.removeAbortListener) {
        res?.off("close", this.removeAbortListener);
        this.removeAbortListener();
        this.removeAbortListener = null;
      }
    }
  }
  function request(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var { addAbortListener } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort(self2[kSignal]?.reason);
    } else {
      self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError;
    }
    removeSignal(self2);
  }
  function addSignal(self2, signal) {
    self2.reason = null;
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { finished, PassThrough } = __require("node:stream");
  var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("node:async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("node:stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("node:async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("node:assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body?.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(!res, "pipeline cannot be retried");
      assert(!ret.destroyed);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var { InvalidArgumentError, SocketError } = require_errors();
  var { AsyncResource } = __require("node:async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("node:assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      assert(statusCode === 101);
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { AsyncResource } = __require("node:async_hooks");
  var { InvalidArgumentError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL } = require_util();
  var { STATUS_CODES } = __require("node:http");
  var {
    types: {
      isPromise
    }
  } = __require("node:util");
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?");
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    const keys = Object.keys(data);
    const result = [];
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      const value = data[key];
      const name = Buffer.from(`${key}`);
      if (Array.isArray(value)) {
        for (let j = 0;j < value.length; ++j) {
          result.push(name, Buffer.from(`${value[j]}`));
        }
      } else {
        result.push(name, Buffer.from(`${value}`));
      }
    }
    return result;
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.onConnect?.((err) => handler.onError(err), null);
      handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData?.(Buffer.from(responseData));
      handler.onComplete?.(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {}
    return true;
  }
  function buildMockDispatch() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName,
    buildHeadersFromArray
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode, data, responseOptions }) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(replyParameters) {
      if (typeof replyParameters.statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyOptionsCallbackOrStatusCode) {
      if (typeof replyOptionsCallbackOrStatusCode === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyOptionsCallbackOrStatusCode(opts);
          if (typeof resolvedData !== "object" || resolvedData === null) {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
          this.validateReplyParameters(replyParameters2);
          return {
            ...this.createMockScopeDispatchData(replyParameters2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const replyParameters = {
        statusCode: replyOptionsCallbackOrStatusCode,
        data: arguments[1] === undefined ? "" : arguments[1],
        responseOptions: arguments[2] === undefined ? {} : arguments[2]
      };
      this.validateReplyParameters(replyParameters);
      const dispatchData = this.createMockScopeDispatchData(replyParameters);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Client2 = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client2 {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("node:util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { Console } = __require("node:console");
  var PERSISTENT = process.versions.icu ? "✅" : "Y ";
  var NOT_PERSISTENT = process.versions.icu ? "❌" : "N ";
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts?.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts?.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, dispatcher);
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const client = this[kClients].get(origin);
      if (client) {
        return client;
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    #handler;
    constructor(handler) {
      if (typeof handler !== "object" || handler === null) {
        throw new TypeError("handler must be an object");
      }
      this.#handler = handler;
    }
    onConnect(...args) {
      return this.#handler.onConnect?.(...args);
    }
    onError(...args) {
      return this.#handler.onError?.(...args);
    }
    onUpgrade(...args) {
      return this.#handler.onUpgrade?.(...args);
    }
    onResponseStarted(...args) {
      return this.#handler.onResponseStarted?.(...args);
    }
    onHeaders(...args) {
      return this.#handler.onHeaders?.(...args);
    }
    onData(...args) {
      return this.#handler.onData?.(...args);
    }
    onComplete(...args) {
      return this.#handler.onComplete?.(...args);
    }
    onBodySent(...args) {
      return this.#handler.onBodySent?.(...args);
    }
  };
});

// node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS((exports, module) => {
  var RedirectHandler = require_redirect_handler();
  module.exports = (opts) => {
    const globalMaxRedirections = opts?.maxRedirections;
    return (dispatch) => {
      return function redirectInterceptor(opts2, handler) {
        const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts2;
        if (!maxRedirections) {
          return dispatch(opts2, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts2, handler);
        return dispatch(baseOpts, redirectHandler);
      };
    };
  };
});

// node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS((exports, module) => {
  var RetryHandler = require_retry_handler();
  module.exports = (globalOpts) => {
    return (dispatch) => {
      return function retryInterceptor(opts, handler) {
        return dispatch(opts, new RetryHandler({ ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } }, {
          handler,
          dispatch
        }));
      };
    };
  };
});

// node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS((exports, module) => {
  var util = require_util();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var DecoratorHandler = require_decorator_handler();

  class DumpHandler extends DecoratorHandler {
    #maxSize = 1024 * 1024;
    #abort = null;
    #dumped = false;
    #aborted = false;
    #size = 0;
    #reason = null;
    #handler = null;
    constructor({ maxSize }, handler) {
      super(handler);
      if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
        throw new InvalidArgumentError("maxSize must be a number greater than 0");
      }
      this.#maxSize = maxSize ?? this.#maxSize;
      this.#handler = handler;
    }
    onConnect(abort) {
      this.#abort = abort;
      this.#handler.onConnect(this.#customAbort.bind(this));
    }
    #customAbort(reason) {
      this.#aborted = true;
      this.#reason = reason;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = util.parseHeaders(rawHeaders);
      const contentLength = headers["content-length"];
      if (contentLength != null && contentLength > this.#maxSize) {
        throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);
      }
      if (this.#aborted) {
        return true;
      }
      return this.#handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
    }
    onError(err) {
      if (this.#dumped) {
        return;
      }
      err = this.#reason ?? err;
      this.#handler.onError(err);
    }
    onData(chunk) {
      this.#size = this.#size + chunk.length;
      if (this.#size >= this.#maxSize) {
        this.#dumped = true;
        if (this.#aborted) {
          this.#handler.onError(this.#reason);
        } else {
          this.#handler.onComplete([]);
        }
      }
      return true;
    }
    onComplete(trailers) {
      if (this.#dumped) {
        return;
      }
      if (this.#aborted) {
        this.#handler.onError(this.reason);
        return;
      }
      this.#handler.onComplete(trailers);
    }
  }
  function createDumpInterceptor({ maxSize: defaultMaxSize } = {
    maxSize: 1024 * 1024
  }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { dumpMaxSize = defaultMaxSize } = opts;
        const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize }, handler);
        return dispatch(opts, dumpHandler);
      };
    };
  }
  module.exports = createDumpInterceptor;
});

// node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS((exports, module) => {
  var { isIP } = __require("node:net");
  var { lookup } = __require("node:dns");
  var DecoratorHandler = require_decorator_handler();
  var { InvalidArgumentError, InformationalError } = require_errors();
  var maxInt = Math.pow(2, 31) - 1;

  class DNSInstance {
    #maxTTL = 0;
    #maxItems = 0;
    #records = new Map;
    dualStack = true;
    affinity = null;
    lookup = null;
    pick = null;
    constructor(opts) {
      this.#maxTTL = opts.maxTTL;
      this.#maxItems = opts.maxItems;
      this.dualStack = opts.dualStack;
      this.affinity = opts.affinity;
      this.lookup = opts.lookup ?? this.#defaultLookup;
      this.pick = opts.pick ?? this.#defaultPick;
    }
    get full() {
      return this.#records.size === this.#maxItems;
    }
    runLookup(origin, opts, cb) {
      const ips = this.#records.get(origin.hostname);
      if (ips == null && this.full) {
        cb(null, origin.origin);
        return;
      }
      const newOpts = {
        affinity: this.affinity,
        dualStack: this.dualStack,
        lookup: this.lookup,
        pick: this.pick,
        ...opts.dns,
        maxTTL: this.#maxTTL,
        maxItems: this.#maxItems
      };
      if (ips == null) {
        this.lookup(origin, newOpts, (err, addresses) => {
          if (err || addresses == null || addresses.length === 0) {
            cb(err ?? new InformationalError("No DNS entries found"));
            return;
          }
          this.setRecords(origin, addresses);
          const records = this.#records.get(origin.hostname);
          const ip = this.pick(origin, records, newOpts.affinity);
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
        });
      } else {
        const ip = this.pick(origin, ips, newOpts.affinity);
        if (ip == null) {
          this.#records.delete(origin.hostname);
          this.runLookup(origin, opts, cb);
          return;
        }
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
      }
    }
    #defaultLookup(origin, opts, cb) {
      lookup(origin.hostname, {
        all: true,
        family: this.dualStack === false ? this.affinity : 0,
        order: "ipv4first"
      }, (err, addresses) => {
        if (err) {
          return cb(err);
        }
        const results = new Map;
        for (const addr of addresses) {
          results.set(`${addr.address}:${addr.family}`, addr);
        }
        cb(null, results.values());
      });
    }
    #defaultPick(origin, hostnameRecords, affinity) {
      let ip = null;
      const { records, offset } = hostnameRecords;
      let family;
      if (this.dualStack) {
        if (affinity == null) {
          if (offset == null || offset === maxInt) {
            hostnameRecords.offset = 0;
            affinity = 4;
          } else {
            hostnameRecords.offset++;
            affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
          }
        }
        if (records[affinity] != null && records[affinity].ips.length > 0) {
          family = records[affinity];
        } else {
          family = records[affinity === 4 ? 6 : 4];
        }
      } else {
        family = records[affinity];
      }
      if (family == null || family.ips.length === 0) {
        return ip;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
        return this.pick(origin, hostnameRecords, affinity);
      }
      return ip;
    }
    setRecords(origin, addresses) {
      const timestamp = Date.now();
      const records = { records: { 4: null, 6: null } };
      for (const record of addresses) {
        record.timestamp = timestamp;
        if (typeof record.ttl === "number") {
          record.ttl = Math.min(record.ttl, this.#maxTTL);
        } else {
          record.ttl = this.#maxTTL;
        }
        const familyRecords = records.records[record.family] ?? { ips: [] };
        familyRecords.ips.push(record);
        records.records[record.family] = familyRecords;
      }
      this.#records.set(origin.hostname, records);
    }
    getHandler(meta, opts) {
      return new DNSDispatchHandler(this, meta, opts);
    }
  }

  class DNSDispatchHandler extends DecoratorHandler {
    #state = null;
    #opts = null;
    #dispatch = null;
    #handler = null;
    #origin = null;
    constructor(state, { origin, handler, dispatch }, opts) {
      super(handler);
      this.#origin = origin;
      this.#handler = handler;
      this.#opts = { ...opts };
      this.#state = state;
      this.#dispatch = dispatch;
    }
    onError(err) {
      switch (err.code) {
        case "ETIMEDOUT":
        case "ECONNREFUSED": {
          if (this.#state.dualStack) {
            this.#state.runLookup(this.#origin, this.#opts, (err2, newOrigin) => {
              if (err2) {
                return this.#handler.onError(err2);
              }
              const dispatchOpts = {
                ...this.#opts,
                origin: newOrigin
              };
              this.#dispatch(dispatchOpts, this);
            });
            return;
          }
          this.#handler.onError(err);
          return;
        }
        case "ENOTFOUND":
          this.#state.deleteRecord(this.#origin);
        default:
          this.#handler.onError(err);
          break;
      }
    }
  }
  module.exports = (interceptorOpts) => {
    if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
      throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
    }
    if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
      throw new InvalidArgumentError("Invalid maxItems. Must be a positive number and greater than zero");
    }
    if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
      throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
    }
    if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
      throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
    }
    if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
      throw new InvalidArgumentError("Invalid lookup. Must be a function");
    }
    if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
      throw new InvalidArgumentError("Invalid pick. Must be a function");
    }
    const dualStack = interceptorOpts?.dualStack ?? true;
    let affinity;
    if (dualStack) {
      affinity = interceptorOpts?.affinity ?? null;
    } else {
      affinity = interceptorOpts?.affinity ?? 4;
    }
    const opts = {
      maxTTL: interceptorOpts?.maxTTL ?? 1e4,
      lookup: interceptorOpts?.lookup ?? null,
      pick: interceptorOpts?.pick ?? null,
      dualStack,
      affinity,
      maxItems: interceptorOpts?.maxItems ?? Infinity
    };
    const instance = new DNSInstance(opts);
    return (dispatch) => {
      return function dnsInterceptor(origDispatchOpts, handler) {
        const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
        if (isIP(origin.hostname) !== 0) {
          return dispatch(origDispatchOpts, handler);
        }
        instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
          if (err) {
            return handler.onError(err);
          }
          let dispatchOpts = null;
          dispatchOpts = {
            ...origDispatchOpts,
            servername: origin.hostname,
            origin: newOrigin,
            headers: {
              host: origin.hostname,
              ...origDispatchOpts.headers
            }
          };
          dispatch(dispatchOpts, instance.getHandler({ origin, dispatch, handler }, origDispatchOpts));
        });
        return true;
      };
    };
  };
});

// node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols();
  var { kEnumerableProperty } = require_util();
  var {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("node:assert");
  var util = __require("node:util");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i) {
        appendHeader(headers, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers).append(name, value, false);
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name, isLowerCase) {
      return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ??= []).push(value);
      }
    }
    set(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name, isLowerCase) {
      this[kHeadersSortedMap] = null;
      if (!isLowerCase)
        name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    get(name, isLowerCase) {
      return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size !== 0) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
    rawValues() {
      return this[kHeadersMap].values();
    }
    get entriesList() {
      const headers = [];
      if (this[kHeadersMap].size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {
          if (lowerName === "set-cookie") {
            for (const cookie of this.cookies) {
              headers.push([name, cookie]);
            }
          } else {
            headers.push([name, value]);
          }
        }
      }
      return headers;
    }
    toSortedArray() {
      const size = this[kHeadersMap].size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this[kHeadersMap][Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
          array[i++] = [name, value];
          assert(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }

  class Headers2 {
    #guard;
    #headersList;
    constructor(init = undefined) {
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct) {
        return;
      }
      this.#headersList = new HeadersList;
      this.#guard = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this.#headersList.contains(name, false)) {
        return;
      }
      this.#headersList.delete(name, false);
    }
    get(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.get(name, false);
    }
    has(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.contains(name, false);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      this.#headersList.set(name, value, false);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers2);
      const list = this.#headersList.cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this.#headersList[kHeadersSortedMap]) {
        return this.#headersList[kHeadersSortedMap];
      }
      const headers = [];
      const names = this.#headersList.toSortedArray();
      const cookies = this.#headersList.cookies;
      if (cookies === null || cookies.length === 1) {
        return this.#headersList[kHeadersSortedMap] = names;
      }
      for (let i = 0;i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0;j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          headers.push([name, value]);
        }
      }
      return this.#headersList[kHeadersSortedMap] = headers;
    }
    [util.inspect.custom](depth, options) {
      options.depth ??= depth;
      return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
    }
    static getHeadersGuard(o) {
      return o.#guard;
    }
    static setHeadersGuard(o, guard) {
      o.#guard = guard;
    }
    static getHeadersList(o) {
      return o.#headersList;
    }
    static setHeadersList(o, list) {
      o.#headersList = list;
    }
  }
  var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers2;
  Reflect.deleteProperty(Headers2, "getHeadersGuard");
  Reflect.deleteProperty(Headers2, "setHeadersGuard");
  Reflect.deleteProperty(Headers2, "getHeadersList");
  Reflect.deleteProperty(Headers2, "setHeadersList");
  iteratorMixin("Headers", Headers2, kHeadersSortedMap, 0, 1);
  Object.defineProperties(Headers2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object") {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util.types.isProxy(V) && iterator === Headers2.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {}
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    compareHeaderName,
    Headers: Headers2,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
});

// node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var { Headers: Headers2, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
  var { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require_body();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode,
    environmentSettingsObject: relevantRealm
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus
  } = require_constants3();
  var { kState, kHeaders } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { types } = __require("node:util");
  var textEncoder = new TextEncoder("utf-8");

  class Response2 {
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value, true);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      webidl.util.markAsUncloneable(this);
      if (body === kConstruct) {
        return;
      }
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers2(kConstruct);
      setHeadersGuard(this[kHeaders], "response");
      setHeadersList(this[kHeaders], this[kState].headersList);
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response2);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response2);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response2);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response2);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response2);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response2);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response2);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response2);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response2);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response2);
      if (bodyUnusable(this)) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Response2);
  Object.defineProperties(Response2.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response2, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(newResponse, response.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList,
      urlList: init?.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response) {
    return response.type === "error" && response.status === 0;
  }
  function makeFilteredResponse(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response.status}`
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("content-type", true)) {
        response[kState].headersList.append("content-type", body.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    const response = new Response2(kConstruct);
    response[kState] = innerResponse;
    response[kHeaders] = new Headers2(kConstruct);
    setHeadersList(response[kHeaders], innerResponse.headersList);
    setHeadersGuard(response[kHeaders], guard);
    if (hasFinalizationRegistry && innerResponse.body?.stream) {
      streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
    }
    return response;
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, prefix, name, { strict: false });
    }
    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
      return webidl.converters.BufferSource(V, prefix, name);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, prefix, name, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V, prefix, name);
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V, prefix, argument);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response: Response2,
    cloneResponse,
    fromInnerResponse
  };
});

// node_modules/undici/lib/web/fetch/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
    unregister(key) {}
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
      process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return { WeakRef, FinalizationRegistry };
  };
});

// node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
  var { Headers: Headers2, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
  var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
  var util = require_util();
  var nodeUtil = __require("node:util");
  var {
    isValidHTTPToken,
    sameOrigin,
    environmentSettingsObject
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants3();
  var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
  var { kHeaders, kSignal, kState, kDispatcher } = require_symbols2();
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { kConstruct } = require_symbols();
  var assert = __require("node:assert");
  var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("node:events");
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  var dependentControllerMap = new WeakMap;
  function buildAbort(acRef) {
    return abort;
    function abort() {
      const ac = acRef.deref();
      if (ac !== undefined) {
        requestFinalizer.unregister(abort);
        this.removeEventListener("abort", abort);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== undefined) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== undefined) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  var patchMethodWarning = false;

  class Request {
    constructor(input, init = {}) {
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input, prefix, "input");
      init = webidl.converters.RequestInit(init, prefix, "init");
      let request = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this[kDispatcher] = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        this[kDispatcher] = init.dispatcher || input[kDispatcher];
        assert(input instanceof Request);
        request = input[kState];
        signal = input[kSignal];
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: environmentSettingsObject.settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords[method];
        if (mayBeNormalized !== undefined) {
          request.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase[upperCase] ?? method;
          request.method = method;
        }
        if (!patchMethodWarning && request.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = buildAbort(acRef);
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
          } catch {}
          util.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort }, abort);
        }
      }
      this[kHeaders] = new Headers2(kConstruct);
      setHeadersList(this[kHeaders], request.headersList);
      setHeadersGuard(this[kHeaders], "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        setHeadersGuard(this[kHeaders], "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this[kHeaders]);
        const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers instanceof HeadersList) {
          for (const { name, value } of headers.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers.cookies;
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(input)) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (bodyUnusable(this)) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === undefined) {
          list = new Set;
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util.addAbortListener(ac.signal, buildAbort(acRef));
      }
      return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
  }
  function cloneRequest(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(newRequest, request.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, signal, guard) {
    const request = new Request(kConstruct);
    request[kState] = innerRequest;
    request[kSignal] = signal;
    request[kHeaders] = new Headers2(kConstruct);
    setHeadersList(request[kHeaders], innerRequest.headersList);
    setHeadersGuard(request[kHeaders], guard);
    return request;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V, prefix, argument) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, argument);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V, prefix, argument);
    }
    return webidl.converters.USVString(V, prefix, argument);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, "RequestInit", "signal", { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    }
  ]);
  module.exports = { Request, makeRequest, fromInnerRequest, cloneRequest };
});

// node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse
  } = require_response();
  var { HeadersList } = require_headers();
  var { Request, cloneRequest } = require_request2();
  var zlib = __require("node:zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = require_util2();
  var { kState, kDispatcher } = require_symbols2();
  var assert = __require("node:assert");
  var { safelyExtractBody, extractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = require_constants3();
  var EE = __require("node:events");
  var { Readable, pipeline, finished } = __require("node:stream");
  var { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = require_util();
  var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("node:http");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  var resolveObjectURL;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  function handleFetchDone(response) {
    finalizeAndReportTiming(response, "fetch");
  }
  function fetch2(input, init = undefined) {
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      const realResponse = responseObject?.deref();
      abortFetch(p, request, realResponse, requestObject.signal.reason);
    });
    const processResponse = (response) => {
      if (locallyAborted) {
        return;
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: requestObject[kDispatcher]
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
  }
  var markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request, responseObject, error) {
    if (p) {
      p.reject(error);
    }
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher = getGlobalDispatcher()
  }) {
    assert(dispatcher);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept", true)) {
      const value = "*/*";
      request.headersList.append("accept", value, true);
    }
    if (!request.headersList.contains("accept-language", true)) {
      request.headersList.append("accept-language", "*", true);
    }
    if (request.priority === null) {}
    if (subresourceSet.has(request.destination)) {}
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {}
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("node:buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request.headersList.contains("range", true)) {
          const bodyWithType = extractBody(blob);
          response.statusText = "OK";
          response.body = bodyWithType[0];
          response.headersList.set("content-length", serializedFullLength, true);
          response.headersList.set("content-type", type, true);
        } else {
          response.rangeRequested = true;
          const rangeHeader = request.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
          const slicedBodyWithType = extractBody(slicedBlob);
          response.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response.status = 206;
          response.statusText = "Partial Content";
          response.headersList.set("content-length", serializedSlicedLength, true);
          response.headersList.set("content-type", type, true);
          response.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  }
  function fetchFinale(fetchParams, response) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (fetchParams.request.url.protocol !== "https:") {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response.cacheState;
        const bodyInfo = response.bodyInfo;
        if (!response.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
          responseStatus = response.status;
          const mimeType = extractMimeType(response.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {}
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy(undefined, false);
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization", true);
      request.headersList.delete("proxy-authorization", true);
      request.headersList.delete("cookie", true);
      request.headersList.delete("host", true);
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = cloneRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) {}
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    if (includeCredentials) {}
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {}
    if (response == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
      if (revalidatingFlag && forwardResponse.status === 304) {}
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {}
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort = true) {
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort) {
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {} else {}
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = async () => {
      await fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream = new ReadableStream({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      },
      type: "bytes"
    });
    response.body = { stream, source: null, length: null };
    fetchParams.controller.onAborted = onAborted;
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
          if (connection.destroyed) {
            abort(new DOMException("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onResponseStarted() {
          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onHeaders(status, rawHeaders, resume, statusText) {
          if (status < 200) {
            return;
          }
          let codings = [];
          let location = "";
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          const contentEncoding = headersList.get("content-encoding", true);
          if (contentEncoding) {
            codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
          }
          location = headersList.get("location", true);
          this.body = new Readable({ read: resume });
          const decoders = [];
          const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
          if (codings.length !== 0 && request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            for (let i = codings.length - 1;i >= 0; --i) {
              const coding = codings[i];
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(createInflate({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress({
                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                }));
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          const onError = this.onError.bind(this);
          resolve({
            status,
            statusText,
            headersList,
            body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
              if (err) {
                this.onError(err);
              }
            }).on("error", onError) : this.body.on("error", onError)
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          if (fetchParams.controller.onAborted) {
            fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error);
          fetchParams.controller.terminate(error);
          reject(error);
        },
        onUpgrade(status, rawHeaders, socket) {
          if (status !== 101) {
            return;
          }
          const headersList = new HeadersList;
          for (let i = 0;i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList,
            socket
          });
          return true;
        }
      }));
    }
  }
  module.exports = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/web/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/web/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/web/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/web/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { serializeAMimeType, parseMIMEType } = require_data_url();
  var { types } = __require("node:util");
  var { StringDecoder } = __require("string_decoder");
  var { btoa: btoa2 } = __require("node:buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa2(decoder.write(chunk));
        }
        dataURL += btoa2(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/web/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding, "FileReader.readAsText", "encoding");
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/web/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols().kConstruct
  };
});

// node_modules/undici/lib/web/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var assert = __require("node:assert");
  var { URLSerializer } = require_data_url();
  var { isValidHeaderName } = require_util2();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  module.exports = {
    urlEquals,
    getFieldValues
  };
});

// node_modules/undici/lib/web/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { webidl } = require_webidl();
  var { Response: Response2, cloneResponse, fromInnerResponse } = require_response();
  var { Request, fromInnerRequest } = require_request2();
  var { kState } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("node:assert");

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = this.#internalMatchAll(request, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.matchAll";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return this.#internalMatchAll(request, options);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request of requests) {
        if (request === undefined) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request = webidl.converters.RequestInfo(request);
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      response = webidl.converters.Response(response, prefix, "response");
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.keys";
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = fromInnerRequest(request2, new AbortController().signal, "immutable");
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
    #internalMatchAll(request, options, maxResponses = Infinity) {
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = fromInnerResponse(response, "immutable");
        responseList.push(responseObject.clone());
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response2);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/web/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    for (let i = 0;i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0;i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 60 || code === 62 || code === 64 || code === 44 || code === 59 || code === 58 || code === 92 || code === 47 || code === 91 || code === 93 || code === 63 || code === 61 || code === 123 || code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || code > 126 || code === 34 || code === 44 || code === 59 || code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path) {
    for (let i = 0;i < path.length; ++i) {
      const code = path.charCodeAt(i);
      if (code < 32 || code === 127 || code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  var IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  module.exports = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
});

// node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_data_url();
  var assert = __require("node:assert");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse();
  var { stringify } = require_util6();
  var { webidl } = require_webidl();
  var { Headers: Headers2 } = require_headers();
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    webidl.brandCheck(headers, Headers2, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.brandCheck(headers, Headers2, { strict: false });
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    webidl.brandCheck(headers, Headers2, { strict: false });
    const cookies = headers.getSetCookie();
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    webidl.brandCheck(headers, Headers2, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", str);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { kConstruct } = require_symbols();
  var { MessagePort } = __require("node:worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      if (type === kConstruct) {
        super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      const messageEvent = new MessageEvent(kConstruct, type, init);
      messageEvent.#eventInit = init;
      messageEvent.#eventInit.data ??= null;
      messageEvent.#eventInit.origin ??= "";
      messageEvent.#eventInit.lastEventId ??= "";
      messageEvent.#eventInit.source ??= null;
      messageEvent.#eventInit.ports ??= [];
      return messageEvent;
    }
  }
  var { createFastMessageEvent } = MessageEvent;
  delete MessageEvent.createFastMessageEvent;

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent,
    createFastMessageEvent
  };
});

// node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var sentCloseFrameState = {
    NOT_SENT: 0,
    PROCESSING: 1,
    SENT: 2
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  var sendHints = {
    string: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  module.exports = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
});

// node_modules/undici/lib/web/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/web/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants5();
  var { ErrorEvent, createFastMessageEvent } = require_events();
  var { isUtf8 } = __require("node:buffer");
  var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
  function isConnecting(ws) {
    return ws[kReadyState] === states.CONNECTING;
  }
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = utf8Decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = toArrayBuffer(data);
      }
    }
    fireEvent("message", ws, createFastMessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0;i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code === 58 || code === 59 || code === 60 || code === 61 || code === 62 || code === 63 || code === 64 || code === 91 || code === 92 || code === 93 || code === 123 || code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, (type, init) => new ErrorEvent(type, init), {
        error: new Error(reason),
        message: reason
      });
    }
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = new Map;
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=");
      extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0;i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  var hasIntl = typeof process.versions.icu === "string";
  var fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : undefined;
  var utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
    if (isUtf8(buffer)) {
      return buffer.toString("utf-8");
    }
    throw new TypeError("Invalid utf-8 received.");
  };
  module.exports = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits
  };
});

// node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants5();
  var BUFFER_SIZE = 16386;
  var crypto2;
  var buffer = null;
  var bufIdx = BUFFER_SIZE;
  try {
    crypto2 = __require("node:crypto");
  } catch {
    crypto2 = {
      randomFillSync: function randomFillSync(buffer2, _offset, _size) {
        for (let i = 0;i < buffer2.length; ++i) {
          buffer2[i] = Math.random() * 255 | 0;
        }
        return buffer2;
      }
    };
  }
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      crypto2.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength = frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0;i < bodyLength; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose,
    kResponse
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = require_util7();
  var { channels } = require_diagnostics();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers: Headers2, getHeadersList } = require_headers();
  var { getDecodeSplit } = require_util2();
  var { WebsocketFrameSend } = require_frame();
  var crypto2;
  try {
    crypto2 = __require("node:crypto");
  } catch {}
  function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      client,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers2(options.headers));
      request.headersList = headersList;
    }
    const keyValue = crypto2.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "permessage-deflate; client_max_window_bits";
    request.headersList.append("sec-websocket-extensions", permessageDeflate);
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
    if (isClosing(ws) || isClosed(ws)) {} else if (!isEstablished(ws)) {
      failWebsocketConnection(ws, "Connection was closed before it was established.");
      ws[kReadyState] = states.CLOSING;
    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
      ws[kSentClose] = sentCloseFrameState.PROCESSING;
      const frame = new WebsocketFrameSend;
      if (code !== undefined && reason === undefined) {
        frame.frameData = Buffer.allocUnsafe(2);
        frame.frameData.writeUInt16BE(code, 0);
      } else if (code !== undefined && reason !== undefined) {
        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
        frame.frameData.writeUInt16BE(code, 0);
        frame.frameData.write(reason, 2, "utf-8");
      } else {
        frame.frameData = emptyBuffer;
      }
      const socket = ws[kResponse].socket;
      socket.write(frame.createFrame(opcodes.CLOSE));
      ws[kSentClose] = sentCloseFrameState.SENT;
      ws[kReadyState] = states.CLOSING;
    } else {
      ws[kReadyState] = states.CLOSING;
    }
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const { [kResponse]: response } = ws;
    response.socket.off("data", onSocketData);
    response.socket.off("close", onSocketClose);
    response.socket.off("error", onSocketError);
    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result && !result.error) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kReceivedClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, (type, init) => new CloseEvent(type, init), {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  }
  module.exports = {
    establishWebSocketConnection,
    closeWebSocketConnection
  };
});

// node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __require("node:zlib");
  var { isValidClientWindowBits } = require_util7();
  var tail = Buffer.from([0, 0, 255, 255]);
  var kBuffer = Symbol("kBuffer");
  var kLength = Symbol("kLength");

  class PerMessageDeflate {
    #inflate;
    #options = {};
    constructor(extensions) {
      this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
      this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!this.#inflate) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (this.#options.serverMaxWindowBits) {
          if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
        }
        this.#inflate = createInflateRaw({ windowBits });
        this.#inflate[kBuffer] = [];
        this.#inflate[kLength] = 0;
        this.#inflate.on("data", (data) => {
          this.#inflate[kBuffer].push(data);
          this.#inflate[kLength] += data.length;
        });
        this.#inflate.on("error", (err) => {
          this.#inflate = null;
          callback(err);
        });
      }
      this.#inflate.write(chunk);
      if (fin) {
        this.#inflate.write(tail);
      }
      this.#inflate.flush(() => {
        const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
        this.#inflate[kBuffer].length = 0;
        this.#inflate[kLength] = 0;
        callback(null, full);
      });
    }
  }
  module.exports = { PerMessageDeflate };
});

// node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("node:stream");
  var assert = __require("node:assert");
  var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { channels } = require_diagnostics();
  var {
    isValidStatusCode,
    isValidOpcode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var { closeWebSocketConnection } = require_connection();
  var { PerMessageDeflate } = require_permessage_deflate();

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #loop = false;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    #extensions;
    constructor(ws, extensions) {
      super();
      this.ws = ws;
      this.#extensions = extensions == null ? new Map : extensions;
      if (this.#extensions.has("permessage-deflate")) {
        this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.#loop = true;
      this.run(callback);
    }
    run(callback) {
      while (this.#loop) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.ws, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.ws, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
            failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
            failWebsocketConnection(this.ws, "Expected continuation frame");
            return;
          }
          if (this.#info.fragmented && fragmented) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
            failWebsocketConnection(this.ws, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (isTextBinaryFrame(opcode)) {
            this.#info.binaryType = opcode;
            this.#info.compressed = rsv1 !== 0;
          }
          this.#info.opcode = opcode;
          this.#info.masked = masked;
          this.#info.fin = fin;
          this.#info.fragmented = fragmented;
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          }
          const body = this.consume(this.#info.payloadLength);
          if (isControlFrame(this.#info.opcode)) {
            this.#loop = this.parseControlFrame(body);
            this.#state = parserStates.INFO;
          } else {
            if (!this.#info.compressed) {
              this.#fragments.push(body);
              if (!this.#info.fragmented && this.#info.fin) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            } else {
              this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error, data) => {
                if (error) {
                  closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                  return;
                }
                this.#fragments.push(data);
                if (!this.#info.fin) {
                  this.#state = parserStates.INFO;
                  this.#loop = true;
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));
                this.#loop = true;
                this.#state = parserStates.INFO;
                this.#fragments.length = 0;
                this.run(callback);
              });
              this.#loop = false;
              break;
            }
          }
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(data) {
      assert(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    parseControlFrame(body) {
      const { opcode, payloadLength } = this.#info;
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
          return false;
        }
        this.#info.closeInfo = this.parseCloseBody(body);
        if (this.#info.closeInfo.error) {
          const { code, reason } = this.#info.closeInfo;
          closeWebSocketConnection(this.ws, code, reason, reason.length);
          failWebsocketConnection(this.ws, reason);
          return false;
        }
        if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
          let body2 = emptyBuffer;
          if (this.#info.closeInfo.code) {
            body2 = Buffer.allocUnsafe(2);
            body2.writeUInt16BE(this.#info.closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body2);
          this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this.ws[kSentClose] = sentCloseFrameState.SENT;
            }
          });
        }
        this.ws[kReadyState] = states.CLOSING;
        this.ws[kReceivedClose] = true;
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.ws[kReceivedClose]) {
          const frame = new WebsocketFrameSend(body);
          this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
          if (channels.ping.hasSubscribers) {
            channels.ping.publish({
              payload: body
            });
          }
        }
      } else if (opcode === opcodes.PONG) {
        if (channels.pong.hasSubscribers) {
          channels.pong.publish({
            payload: body
          });
        }
      }
      return true;
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS((exports, module) => {
  var { WebsocketFrameSend } = require_frame();
  var { opcodes, sendHints } = require_constants5();
  var FixedQueue = require_fixed_queue();
  var FastBuffer = Buffer[Symbol.species];

  class SendQueue {
    #queue = new FixedQueue;
    #running = false;
    #socket;
    constructor(socket) {
      this.#socket = socket;
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        const frame = createFrame(item, hint);
        if (!this.#running) {
          this.#socket.write(frame, cb);
        } else {
          const node2 = {
            promise: null,
            callback: cb,
            frame
          };
          this.#queue.push(node2);
        }
        return;
      }
      const node = {
        promise: item.arrayBuffer().then((ab) => {
          node.promise = null;
          node.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      this.#queue.push(node);
      if (!this.#running) {
        this.#run();
      }
    }
    async#run() {
      this.#running = true;
      const queue = this.#queue;
      while (!queue.isEmpty()) {
        const node = queue.shift();
        if (node.promise !== null) {
          await node.promise;
        }
        this.#socket.write(node.frame, node.callback);
        node.callback = node.frame = null;
      }
      this.#running = false;
    }
  }
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer(data, hint) {
    switch (hint) {
      case sendHints.string:
        return Buffer.from(data);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new FastBuffer(data);
      case sendHints.typedArray:
        return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  module.exports = { SendQueue };
});

// node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { URLSerializer } = require_data_url();
  var { environmentSettingsObject } = require_util2();
  var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = require_constants5();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var {
    isConnecting,
    isEstablished,
    isClosing,
    isValidSubprotocol,
    fireEvent
  } = require_util7();
  var { establishWebSocketConnection, closeWebSocketConnection } = require_connection();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("node:util");
  var { ErrorEvent, CloseEvent } = require_events();
  var { SendQueue } = require_sender();

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    #sendQueue;
    constructor(url, protocols = []) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url, prefix, "url");
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      const client = environmentSettingsObject.settingsObject;
      this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions) => this.#onConnectionEstablished(response, extensions), options);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kSentClose] = sentCloseFrameState.NOT_SENT;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.close";
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason, prefix, "reason");
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      closeWebSocketConnection(this, code, reason, reasonByteLength);
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(this)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      if (typeof data === "string") {
        const length = Buffer.byteLength(data);
        this.#bufferedAmount += length;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= length;
        }, sendHints.string);
      } else if (types.isArrayBuffer(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        this.#bufferedAmount += data.byteLength;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.byteLength;
        }, sendHints.typedArray);
      } else if (isBlobLike(data)) {
        this.#bufferedAmount += data.size;
        this.#sendQueue.add(data, () => {
          this.#bufferedAmount -= data.size;
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    #onConnectionEstablished(response, parsedExtensions) {
      this[kResponse] = response;
      const parser = new ByteParser(this, parsedExtensions);
      parser.on("drain", onParserDrain);
      parser.on("error", onParserError.bind(this));
      response.socket.ws = this;
      this[kByteParser] = parser;
      this.#sendQueue = new SendQueue(response.socket);
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  function onParserDrain() {
    this.ws[kResponse].socket.resume();
  }
  function onParserError(err) {
    let message;
    let code;
    if (err instanceof CloseEvent) {
      message = err.reason;
      code = err.code;
    } else {
      message = err.message;
    }
    fireEvent("error", this, () => new ErrorEvent("error", { error: err, message }));
    closeWebSocketConnection(this, code);
  }
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/lib/web/eventsource/util.js
var require_util8 = __commonJS((exports, module) => {
  function isValidLastEventId(value) {
    return value.indexOf("\x00") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0)
      return false;
    for (let i = 0;i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57)
        return false;
    }
    return true;
  }
  function delay(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms).unref();
    });
  }
  module.exports = {
    isValidLastEventId,
    isASCIINumber,
    delay
  };
});

// node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS((exports, module) => {
  var { Transform } = __require("node:stream");
  var { isASCIINumber, isValidLastEventId } = require_util8();
  var BOM = [239, 187, 191];
  var LF = 10;
  var CR = 13;
  var COLON = 58;
  var SPACE = 32;

  class EventSourceStream extends Transform {
    state = null;
    checkBOM = true;
    crlfCheck = false;
    eventEndCheck = false;
    buffer = null;
    pos = 0;
    event = {
      data: undefined,
      event: undefined,
      id: undefined,
      retry: undefined
    };
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === undefined) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== undefined) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: undefined,
        event: undefined,
        id: undefined,
        retry: undefined
      };
    }
  }
  module.exports = {
    EventSourceStream
  };
});

// node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS((exports, module) => {
  var { pipeline } = __require("node:stream");
  var { fetching } = require_fetch();
  var { makeRequest } = require_request2();
  var { webidl } = require_webidl();
  var { EventSourceStream } = require_eventsource_stream();
  var { parseMIMEType } = require_data_url();
  var { createFastMessageEvent } = require_events();
  var { isNetworkError } = require_response();
  var { delay } = require_util8();
  var { kEnumerableProperty } = require_util();
  var { environmentSettingsObject } = require_util2();
  var experimentalWarned = false;
  var defaultReconnectionTime = 3000;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSED = 2;
  var ANONYMOUS = "anonymous";
  var USE_CREDENTIALS = "use-credentials";

  class EventSource extends EventTarget {
    #events = {
      open: null,
      error: null,
      message: null
    };
    #url = null;
    #withCredentials = false;
    #readyState = CONNECTING;
    #request = null;
    #controller = null;
    #dispatcher;
    #state;
    constructor(url, eventSourceInitDict = {}) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url, prefix, "url");
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      this.#dispatcher = eventSourceInitDict.dispatcher;
      this.#state = {
        lastEventId: "",
        reconnectionTime: defaultReconnectionTime
      };
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        this.#state.origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      this.#url = urlRecord.href;
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials) {
        corsAttributeState = USE_CREDENTIALS;
        this.#withCredentials = true;
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(this.#url)];
      this.#request = makeRequest(initRequest);
      this.#connect();
    }
    get readyState() {
      return this.#readyState;
    }
    get url() {
      return this.#url;
    }
    get withCredentials() {
      return this.#withCredentials;
    }
    #connect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      const fetchParams = {
        request: this.#request,
        dispatcher: this.#dispatcher
      };
      const processEventSourceEndOfBody = (response) => {
        if (isNetworkError(response)) {
          this.dispatchEvent(new Event("error"));
          this.close();
        }
        this.#reconnect();
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response) => {
        if (isNetworkError(response)) {
          if (response.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#reconnect();
            return;
          }
        }
        const contentType = response.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.#readyState = OPEN;
        this.dispatchEvent(new Event("open"));
        this.#state.origin = response.urlList[response.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: this.#state,
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(event.type, event.options));
          }
        });
        pipeline(response.body.stream, eventSourceStream, (error) => {
          if (error?.aborted === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
          }
        });
      };
      this.#controller = fetching(fetchParams);
    }
    async#reconnect() {
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CONNECTING;
      this.dispatchEvent(new Event("error"));
      await delay(this.#state.reconnectionTime);
      if (this.#readyState !== CONNECTING)
        return;
      if (this.#state.lastEventId.length) {
        this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
      }
      this.#connect();
    }
    close() {
      webidl.brandCheck(this, EventSource);
      if (this.#readyState === CLOSED)
        return;
      this.#readyState = CLOSED;
      this.#controller.abort();
      this.#request = null;
    }
    get onopen() {
      return this.#events.open;
    }
    set onopen(fn) {
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onmessage() {
      return this.#events.message;
    }
    set onmessage(fn) {
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get onerror() {
      return this.#events.error;
    }
    set onerror(fn) {
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
  }
  var constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    EventSource,
    defaultReconnectionTime
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var Client2 = require_client();
  var Dispatcher = require_dispatcher();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var ProxyAgent = require_proxy_agent();
  var EnvHttpProxyAgent = require_env_http_proxy_agent();
  var RetryAgent = require_retry_agent();
  var errors = require_errors();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var RetryHandler = require_retry_handler();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_decorator_handler();
  var RedirectHandler = require_redirect_handler();
  var createRedirectInterceptor = require_redirect_interceptor();
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client2;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
  exports.RetryAgent = RetryAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.interceptors = {
    redirect: require_redirect(),
    retry: require_retry(),
    dump: require_dump(),
    dns: require_dns()
  };
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.util = {
    parseHeaders: util.parseHeaders,
    headerNameToString: util.headerNameToString
  };
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  var fetchImpl = require_fetch().fetch;
  exports.fetch = async function fetch(init, options = undefined) {
    try {
      return await fetchImpl(init, options);
    } catch (err) {
      if (err && typeof err === "object") {
        Error.captureStackTrace(err);
      }
      throw err;
    }
  };
  exports.Headers = require_headers().Headers;
  exports.Response = require_response().Response;
  exports.Request = require_request2().Request;
  exports.FormData = require_formdata().FormData;
  exports.File = globalThis.File ?? __require("node:buffer").File;
  exports.FileReader = require_filereader().FileReader;
  var { setGlobalOrigin, getGlobalOrigin } = require_global();
  exports.setGlobalOrigin = setGlobalOrigin;
  exports.getGlobalOrigin = getGlobalOrigin;
  var { CacheStorage } = require_cachestorage();
  var { kConstruct } = require_symbols4();
  exports.caches = new CacheStorage(kConstruct);
  var { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
  exports.deleteCookie = deleteCookie;
  exports.getCookies = getCookies;
  exports.getSetCookies = getSetCookies;
  exports.setCookie = setCookie;
  var { parseMIMEType, serializeAMimeType } = require_data_url();
  exports.parseMIMEType = parseMIMEType;
  exports.serializeAMimeType = serializeAMimeType;
  var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
  exports.WebSocket = require_websocket().WebSocket;
  exports.CloseEvent = CloseEvent;
  exports.ErrorEvent = ErrorEvent;
  exports.MessageEvent = MessageEvent;
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
  var { EventSource } = require_eventsource();
  exports.EventSource = EventSource;
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoiceChannelEffectSendAnimationType = exports.GatewayDispatchEvents = exports.GatewayIntentBits = exports.GatewayCloseCodes = exports.GatewayOpcodes = exports.GatewayVersion = undefined;
  exports.GatewayVersion = "10";
  var GatewayOpcodes;
  (function(GatewayOpcodes2) {
    GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
    GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
    GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
    GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
    GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
    GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
    GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
    GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
    GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
    GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
    GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    GatewayOpcodes2[GatewayOpcodes2["RequestSoundboardSounds"] = 31] = "RequestSoundboardSounds";
  })(GatewayOpcodes || (exports.GatewayOpcodes = GatewayOpcodes = {}));
  var GatewayCloseCodes;
  (function(GatewayCloseCodes2) {
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4000] = "UnknownError";
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
    GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
    GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
    GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
    GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
    GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
    GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
    GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
  })(GatewayCloseCodes || (exports.GatewayCloseCodes = GatewayCloseCodes = {}));
  var GatewayIntentBits;
  (function(GatewayIntentBits2) {
    GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
    GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
    GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
    GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
    GatewayIntentBits2[GatewayIntentBits2["GuildExpressions"] = 8] = "GuildExpressions";
    GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
    GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
    GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
    GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
    GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
    GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
    GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessagePolls"] = 16777216] = "GuildMessagePolls";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessagePolls"] = 33554432] = "DirectMessagePolls";
  })(GatewayIntentBits || (exports.GatewayIntentBits = GatewayIntentBits = {}));
  var GatewayDispatchEvents;
  (function(GatewayDispatchEvents2) {
    GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
    GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
    GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
    GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
    GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
    GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
    GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
    GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
    GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
    GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
    GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
    GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
    GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
    GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
    GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
    GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
    GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
    GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
    GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
    GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
    GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
    GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
    GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
    GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
    GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
    GatewayDispatchEvents2["GuildSoundboardSoundCreate"] = "GUILD_SOUNDBOARD_SOUND_CREATE";
    GatewayDispatchEvents2["GuildSoundboardSoundDelete"] = "GUILD_SOUNDBOARD_SOUND_DELETE";
    GatewayDispatchEvents2["GuildSoundboardSoundsUpdate"] = "GUILD_SOUNDBOARD_SOUNDS_UPDATE";
    GatewayDispatchEvents2["GuildSoundboardSoundUpdate"] = "GUILD_SOUNDBOARD_SOUND_UPDATE";
    GatewayDispatchEvents2["SoundboardSounds"] = "SOUNDBOARD_SOUNDS";
    GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
    GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
    GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
    GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
    GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
    GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
    GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
    GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
    GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
    GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
    GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
    GatewayDispatchEvents2["MessagePollVoteAdd"] = "MESSAGE_POLL_VOTE_ADD";
    GatewayDispatchEvents2["MessagePollVoteRemove"] = "MESSAGE_POLL_VOTE_REMOVE";
    GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
    GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
    GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
    GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
    GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
    GatewayDispatchEvents2["Ready"] = "READY";
    GatewayDispatchEvents2["Resumed"] = "RESUMED";
    GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
    GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
    GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
    GatewayDispatchEvents2["SubscriptionCreate"] = "SUBSCRIPTION_CREATE";
    GatewayDispatchEvents2["SubscriptionDelete"] = "SUBSCRIPTION_DELETE";
    GatewayDispatchEvents2["SubscriptionUpdate"] = "SUBSCRIPTION_UPDATE";
    GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
    GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
    GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
    GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
    GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
    GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
    GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
    GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
    GatewayDispatchEvents2["VoiceChannelEffectSend"] = "VOICE_CHANNEL_EFFECT_SEND";
    GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
    GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
    GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
  })(GatewayDispatchEvents || (exports.GatewayDispatchEvents = GatewayDispatchEvents = {}));
  var VoiceChannelEffectSendAnimationType;
  (function(VoiceChannelEffectSendAnimationType2) {
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Premium"] = 0] = "Premium";
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Basic"] = 1] = "Basic";
  })(VoiceChannelEffectSendAnimationType || (exports.VoiceChannelEffectSendAnimationType = VoiceChannelEffectSendAnimationType = {}));
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FormattingPatterns = undefined;
  exports.FormattingPatterns = {
    User: /<@(?<id>\d{17,20})>/,
    UserWithNickname: /<@!(?<id>\d{17,20})>/,
    UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
    Channel: /<#(?<id>\d{17,20})>/,
    Role: /<@&(?<id>\d{17,20})>/,
    SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
    Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
    DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
    StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/,
    GuildNavigation: /<id:(?<type>customize|browse|guide|linked-roles)>/,
    LinkedRole: /<id:linked-roles:(?<id>\d{17,20})>/
  };
  Object.freeze(exports.FormattingPatterns);
});

// node_modules/discord-api-types/payloads/common.js
var require_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionFlagsBits = undefined;
  exports.PermissionFlagsBits = {
    CreateInstantInvite: 1n << 0n,
    KickMembers: 1n << 1n,
    BanMembers: 1n << 2n,
    Administrator: 1n << 3n,
    ManageChannels: 1n << 4n,
    ManageGuild: 1n << 5n,
    AddReactions: 1n << 6n,
    ViewAuditLog: 1n << 7n,
    PrioritySpeaker: 1n << 8n,
    Stream: 1n << 9n,
    ViewChannel: 1n << 10n,
    SendMessages: 1n << 11n,
    SendTTSMessages: 1n << 12n,
    ManageMessages: 1n << 13n,
    EmbedLinks: 1n << 14n,
    AttachFiles: 1n << 15n,
    ReadMessageHistory: 1n << 16n,
    MentionEveryone: 1n << 17n,
    UseExternalEmojis: 1n << 18n,
    ViewGuildInsights: 1n << 19n,
    Connect: 1n << 20n,
    Speak: 1n << 21n,
    MuteMembers: 1n << 22n,
    DeafenMembers: 1n << 23n,
    MoveMembers: 1n << 24n,
    UseVAD: 1n << 25n,
    ChangeNickname: 1n << 26n,
    ManageNicknames: 1n << 27n,
    ManageRoles: 1n << 28n,
    ManageWebhooks: 1n << 29n,
    ManageEmojisAndStickers: 1n << 30n,
    ManageGuildExpressions: 1n << 30n,
    UseApplicationCommands: 1n << 31n,
    RequestToSpeak: 1n << 32n,
    ManageEvents: 1n << 33n,
    ManageThreads: 1n << 34n,
    CreatePublicThreads: 1n << 35n,
    CreatePrivateThreads: 1n << 36n,
    UseExternalStickers: 1n << 37n,
    SendMessagesInThreads: 1n << 38n,
    UseEmbeddedActivities: 1n << 39n,
    ModerateMembers: 1n << 40n,
    ViewCreatorMonetizationAnalytics: 1n << 41n,
    UseSoundboard: 1n << 42n,
    CreateGuildExpressions: 1n << 43n,
    CreateEvents: 1n << 44n,
    UseExternalSounds: 1n << 45n,
    SendVoiceMessages: 1n << 46n,
    SendPolls: 1n << 49n,
    UseExternalApps: 1n << 50n
  };
  Object.freeze(exports.PermissionFlagsBits);
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationWebhookEventStatus = exports.ApplicationRoleConnectionMetadataType = exports.ApplicationFlags = undefined;
  var ApplicationFlags;
  (function(ApplicationFlags2) {
    ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
    ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
    ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
    ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
    ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
    ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
    ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
    ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
    ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
    ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
    ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
    ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
  })(ApplicationFlags || (exports.ApplicationFlags = ApplicationFlags = {}));
  var ApplicationRoleConnectionMetadataType;
  (function(ApplicationRoleConnectionMetadataType2) {
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
  })(ApplicationRoleConnectionMetadataType || (exports.ApplicationRoleConnectionMetadataType = ApplicationRoleConnectionMetadataType = {}));
  var ApplicationWebhookEventStatus;
  (function(ApplicationWebhookEventStatus2) {
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Disabled"] = 1] = "Disabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Enabled"] = 2] = "Enabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["DisabledByDiscord"] = 3] = "DisabledByDiscord";
  })(ApplicationWebhookEventStatus || (exports.ApplicationWebhookEventStatus = ApplicationWebhookEventStatus = {}));
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuditLogOptionsType = exports.AuditLogEvent = undefined;
  var AuditLogEvent;
  (function(AuditLogEvent2) {
    AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
    AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
    AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
    AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
    AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
    AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
    AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
    AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
    AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
    AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
    AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
    AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
    AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
    AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
    AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
    AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
    AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
    AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
    AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
    AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
    AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
    AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
    AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
    AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
    AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
    AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
    AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
    AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
    AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
    AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
    AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
    AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
    AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
    AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
    AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundCreate"] = 130] = "SoundboardSoundCreate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundUpdate"] = 131] = "SoundboardSoundUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundDelete"] = 132] = "SoundboardSoundDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
    AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
    AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    AuditLogEvent2[AuditLogEvent2["AutoModerationQuarantineUser"] = 146] = "AutoModerationQuarantineUser";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptCreate"] = 163] = "OnboardingPromptCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptUpdate"] = 164] = "OnboardingPromptUpdate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptDelete"] = 165] = "OnboardingPromptDelete";
    AuditLogEvent2[AuditLogEvent2["OnboardingCreate"] = 166] = "OnboardingCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingUpdate"] = 167] = "OnboardingUpdate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsCreate"] = 190] = "HomeSettingsCreate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsUpdate"] = 191] = "HomeSettingsUpdate";
  })(AuditLogEvent || (exports.AuditLogEvent = AuditLogEvent = {}));
  var AuditLogOptionsType;
  (function(AuditLogOptionsType2) {
    AuditLogOptionsType2["Role"] = "0";
    AuditLogOptionsType2["Member"] = "1";
  })(AuditLogOptionsType || (exports.AuditLogOptionsType = AuditLogOptionsType = {}));
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoModerationActionType = exports.AutoModerationRuleEventType = exports.AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleTriggerType = undefined;
  var AutoModerationRuleTriggerType;
  (function(AutoModerationRuleTriggerType2) {
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MemberProfile"] = 6] = "MemberProfile";
  })(AutoModerationRuleTriggerType || (exports.AutoModerationRuleTriggerType = AutoModerationRuleTriggerType = {}));
  var AutoModerationRuleKeywordPresetType;
  (function(AutoModerationRuleKeywordPresetType2) {
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
  })(AutoModerationRuleKeywordPresetType || (exports.AutoModerationRuleKeywordPresetType = AutoModerationRuleKeywordPresetType = {}));
  var AutoModerationRuleEventType;
  (function(AutoModerationRuleEventType2) {
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MemberUpdate"] = 2] = "MemberUpdate";
  })(AutoModerationRuleEventType || (exports.AutoModerationRuleEventType = AutoModerationRuleEventType = {}));
  var AutoModerationActionType;
  (function(AutoModerationActionType2) {
    AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
    AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
    AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    AutoModerationActionType2[AutoModerationActionType2["BlockMemberInteraction"] = 4] = "BlockMemberInteraction";
  })(AutoModerationActionType || (exports.AutoModerationActionType = AutoModerationActionType = {}));
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelFlags = exports.SeparatorSpacingSize = exports.UnfurledMediaItemLoadingState = exports.SelectMenuDefaultValueType = exports.TextInputStyle = exports.ButtonStyle = exports.ComponentType = exports.AllowedMentionsTypes = exports.AttachmentFlags = exports.EmbedType = exports.ThreadMemberFlags = exports.ThreadAutoArchiveDuration = exports.OverwriteType = exports.MessageFlags = exports.MessageReferenceType = exports.MessageActivityType = exports.MessageType = exports.VideoQualityMode = exports.ChannelType = exports.ForumLayoutType = exports.SortOrderType = undefined;
  var SortOrderType;
  (function(SortOrderType2) {
    SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
    SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
  })(SortOrderType || (exports.SortOrderType = SortOrderType = {}));
  var ForumLayoutType;
  (function(ForumLayoutType2) {
    ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
    ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
    ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
  })(ForumLayoutType || (exports.ForumLayoutType = ForumLayoutType = {}));
  var ChannelType;
  (function(ChannelType2) {
    ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
    ChannelType2[ChannelType2["DM"] = 1] = "DM";
    ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
    ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
    ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
    ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
    ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
    ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
    ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
    ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
    ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
    ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
    ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
    ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
    ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
    ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
    ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
  })(ChannelType || (exports.ChannelType = ChannelType = {}));
  var VideoQualityMode;
  (function(VideoQualityMode2) {
    VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
    VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
  })(VideoQualityMode || (exports.VideoQualityMode = VideoQualityMode = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Default"] = 0] = "Default";
    MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
    MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
    MessageType2[MessageType2["Call"] = 3] = "Call";
    MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
    MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
    MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
    MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
    MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
    MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
    MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
    MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
    MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
    MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
    MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
    MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
    MessageType2[MessageType2["Reply"] = 19] = "Reply";
    MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
    MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
    MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
    MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
    MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
    MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
    MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
    MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
    MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
    MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
    MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
    MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
    MessageType2[MessageType2["GuildIncidentAlertModeEnabled"] = 36] = "GuildIncidentAlertModeEnabled";
    MessageType2[MessageType2["GuildIncidentAlertModeDisabled"] = 37] = "GuildIncidentAlertModeDisabled";
    MessageType2[MessageType2["GuildIncidentReportRaid"] = 38] = "GuildIncidentReportRaid";
    MessageType2[MessageType2["GuildIncidentReportFalseAlarm"] = 39] = "GuildIncidentReportFalseAlarm";
    MessageType2[MessageType2["PurchaseNotification"] = 44] = "PurchaseNotification";
    MessageType2[MessageType2["PollResult"] = 46] = "PollResult";
  })(MessageType || (exports.MessageType = MessageType = {}));
  var MessageActivityType;
  (function(MessageActivityType2) {
    MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
    MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
    MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
    MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
  })(MessageActivityType || (exports.MessageActivityType = MessageActivityType = {}));
  var MessageReferenceType;
  (function(MessageReferenceType2) {
    MessageReferenceType2[MessageReferenceType2["Default"] = 0] = "Default";
    MessageReferenceType2[MessageReferenceType2["Forward"] = 1] = "Forward";
  })(MessageReferenceType || (exports.MessageReferenceType = MessageReferenceType = {}));
  var MessageFlags;
  (function(MessageFlags2) {
    MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
    MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
    MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
    MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
    MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
    MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
    MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
    MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
    MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
    MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
    MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    MessageFlags2[MessageFlags2["HasSnapshot"] = 16384] = "HasSnapshot";
    MessageFlags2[MessageFlags2["IsComponentsV2"] = 32768] = "IsComponentsV2";
  })(MessageFlags || (exports.MessageFlags = MessageFlags = {}));
  var OverwriteType;
  (function(OverwriteType2) {
    OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
    OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
  })(OverwriteType || (exports.OverwriteType = OverwriteType = {}));
  var ThreadAutoArchiveDuration;
  (function(ThreadAutoArchiveDuration2) {
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
  })(ThreadAutoArchiveDuration || (exports.ThreadAutoArchiveDuration = ThreadAutoArchiveDuration = {}));
  var ThreadMemberFlags;
  (function(ThreadMemberFlags2) {
    ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
    ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
    ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
    ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
  })(ThreadMemberFlags || (exports.ThreadMemberFlags = ThreadMemberFlags = {}));
  var EmbedType;
  (function(EmbedType2) {
    EmbedType2["Rich"] = "rich";
    EmbedType2["Image"] = "image";
    EmbedType2["Video"] = "video";
    EmbedType2["GIFV"] = "gifv";
    EmbedType2["Article"] = "article";
    EmbedType2["Link"] = "link";
    EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    EmbedType2["PollResult"] = "poll_result";
  })(EmbedType || (exports.EmbedType = EmbedType = {}));
  var AttachmentFlags;
  (function(AttachmentFlags2) {
    AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
  })(AttachmentFlags || (exports.AttachmentFlags = AttachmentFlags = {}));
  var AllowedMentionsTypes;
  (function(AllowedMentionsTypes2) {
    AllowedMentionsTypes2["Everyone"] = "everyone";
    AllowedMentionsTypes2["Role"] = "roles";
    AllowedMentionsTypes2["User"] = "users";
  })(AllowedMentionsTypes || (exports.AllowedMentionsTypes = AllowedMentionsTypes = {}));
  var ComponentType;
  (function(ComponentType2) {
    ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
    ComponentType2[ComponentType2["Button"] = 2] = "Button";
    ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
    ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
    ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
    ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
    ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
    ComponentType2[ComponentType2["Section"] = 9] = "Section";
    ComponentType2[ComponentType2["TextDisplay"] = 10] = "TextDisplay";
    ComponentType2[ComponentType2["Thumbnail"] = 11] = "Thumbnail";
    ComponentType2[ComponentType2["MediaGallery"] = 12] = "MediaGallery";
    ComponentType2[ComponentType2["File"] = 13] = "File";
    ComponentType2[ComponentType2["Separator"] = 14] = "Separator";
    ComponentType2[ComponentType2["ContentInventoryEntry"] = 16] = "ContentInventoryEntry";
    ComponentType2[ComponentType2["Container"] = 17] = "Container";
    ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
  })(ComponentType || (exports.ComponentType = ComponentType = {}));
  var ButtonStyle;
  (function(ButtonStyle2) {
    ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
    ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
    ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
    ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
    ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    ButtonStyle2[ButtonStyle2["Premium"] = 6] = "Premium";
  })(ButtonStyle || (exports.ButtonStyle = ButtonStyle = {}));
  var TextInputStyle;
  (function(TextInputStyle2) {
    TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
    TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
  })(TextInputStyle || (exports.TextInputStyle = TextInputStyle = {}));
  var SelectMenuDefaultValueType;
  (function(SelectMenuDefaultValueType2) {
    SelectMenuDefaultValueType2["Channel"] = "channel";
    SelectMenuDefaultValueType2["Role"] = "role";
    SelectMenuDefaultValueType2["User"] = "user";
  })(SelectMenuDefaultValueType || (exports.SelectMenuDefaultValueType = SelectMenuDefaultValueType = {}));
  var UnfurledMediaItemLoadingState;
  (function(UnfurledMediaItemLoadingState2) {
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Unknown"] = 0] = "Unknown";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Loading"] = 1] = "Loading";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedSuccess"] = 2] = "LoadedSuccess";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedNotFound"] = 3] = "LoadedNotFound";
  })(UnfurledMediaItemLoadingState || (exports.UnfurledMediaItemLoadingState = UnfurledMediaItemLoadingState = {}));
  var SeparatorSpacingSize;
  (function(SeparatorSpacingSize2) {
    SeparatorSpacingSize2[SeparatorSpacingSize2["Small"] = 1] = "Small";
    SeparatorSpacingSize2[SeparatorSpacingSize2["Large"] = 2] = "Large";
  })(SeparatorSpacingSize || (exports.SeparatorSpacingSize = SeparatorSpacingSize = {}));
  var ChannelFlags;
  (function(ChannelFlags2) {
    ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
    ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
    ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
    ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
    ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
    ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
    ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
    ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
  })(ChannelFlags || (exports.ChannelFlags = ChannelFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ActivityFlags = exports.ActivityType = exports.ActivityPlatform = exports.PresenceUpdateStatus = undefined;
  var PresenceUpdateStatus;
  (function(PresenceUpdateStatus2) {
    PresenceUpdateStatus2["Online"] = "online";
    PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
    PresenceUpdateStatus2["Idle"] = "idle";
    PresenceUpdateStatus2["Invisible"] = "invisible";
    PresenceUpdateStatus2["Offline"] = "offline";
  })(PresenceUpdateStatus || (exports.PresenceUpdateStatus = PresenceUpdateStatus = {}));
  var ActivityPlatform;
  (function(ActivityPlatform2) {
    ActivityPlatform2["Desktop"] = "desktop";
    ActivityPlatform2["Xbox"] = "xbox";
    ActivityPlatform2["Samsung"] = "samsung";
    ActivityPlatform2["IOS"] = "ios";
    ActivityPlatform2["Android"] = "android";
    ActivityPlatform2["Embedded"] = "embedded";
    ActivityPlatform2["PS4"] = "ps4";
    ActivityPlatform2["PS5"] = "ps5";
  })(ActivityPlatform || (exports.ActivityPlatform = ActivityPlatform = {}));
  var ActivityType;
  (function(ActivityType2) {
    ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
    ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
    ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
    ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
    ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
    ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
  })(ActivityType || (exports.ActivityType = ActivityType = {}));
  var ActivityFlags;
  (function(ActivityFlags2) {
    ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
    ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
    ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
    ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
    ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
    ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
    ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
    ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
    ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
  })(ActivityFlags || (exports.ActivityFlags = ActivityFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildOnboardingPromptType = exports.GuildOnboardingMode = exports.MembershipScreeningFieldType = exports.GuildWidgetStyle = exports.IntegrationExpireBehavior = exports.GuildMemberFlags = exports.GuildFeature = exports.GuildSystemChannelFlags = exports.GuildHubType = exports.GuildPremiumTier = exports.GuildVerificationLevel = exports.GuildNSFWLevel = exports.GuildMFALevel = exports.GuildExplicitContentFilter = exports.GuildDefaultMessageNotifications = undefined;
  var GuildDefaultMessageNotifications;
  (function(GuildDefaultMessageNotifications2) {
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
  })(GuildDefaultMessageNotifications || (exports.GuildDefaultMessageNotifications = GuildDefaultMessageNotifications = {}));
  var GuildExplicitContentFilter;
  (function(GuildExplicitContentFilter2) {
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
  })(GuildExplicitContentFilter || (exports.GuildExplicitContentFilter = GuildExplicitContentFilter = {}));
  var GuildMFALevel;
  (function(GuildMFALevel2) {
    GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
    GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
  })(GuildMFALevel || (exports.GuildMFALevel = GuildMFALevel = {}));
  var GuildNSFWLevel;
  (function(GuildNSFWLevel2) {
    GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
    GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
    GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
    GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
  })(GuildNSFWLevel || (exports.GuildNSFWLevel = GuildNSFWLevel = {}));
  var GuildVerificationLevel;
  (function(GuildVerificationLevel2) {
    GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
    GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
    GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
    GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
    GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
  })(GuildVerificationLevel || (exports.GuildVerificationLevel = GuildVerificationLevel = {}));
  var GuildPremiumTier;
  (function(GuildPremiumTier2) {
    GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
    GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
    GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
    GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
  })(GuildPremiumTier || (exports.GuildPremiumTier = GuildPremiumTier = {}));
  var GuildHubType;
  (function(GuildHubType2) {
    GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
    GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
    GuildHubType2[GuildHubType2["College"] = 2] = "College";
  })(GuildHubType || (exports.GuildHubType = GuildHubType = {}));
  var GuildSystemChannelFlags;
  (function(GuildSystemChannelFlags2) {
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
  })(GuildSystemChannelFlags || (exports.GuildSystemChannelFlags = GuildSystemChannelFlags = {}));
  var GuildFeature;
  (function(GuildFeature2) {
    GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
    GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
    GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
    GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
    GuildFeature2["Banner"] = "BANNER";
    GuildFeature2["Community"] = "COMMUNITY";
    GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
    GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
    GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
    GuildFeature2["Discoverable"] = "DISCOVERABLE";
    GuildFeature2["Featurable"] = "FEATURABLE";
    GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
    GuildFeature2["Hub"] = "HUB";
    GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
    GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
    GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
    GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
    GuildFeature2["MoreSoundboard"] = "MORE_SOUNDBOARD";
    GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
    GuildFeature2["MoreStickers"] = "MORE_STICKERS";
    GuildFeature2["News"] = "NEWS";
    GuildFeature2["Partnered"] = "PARTNERED";
    GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
    GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
    GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
    GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
    GuildFeature2["RoleIcons"] = "ROLE_ICONS";
    GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
    GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
    GuildFeature2["Soundboard"] = "SOUNDBOARD";
    GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
    GuildFeature2["VanityURL"] = "VANITY_URL";
    GuildFeature2["Verified"] = "VERIFIED";
    GuildFeature2["VIPRegions"] = "VIP_REGIONS";
    GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    GuildFeature2["GuildTags"] = "GUILD_TAGS";
    GuildFeature2["EnhancedRoleColors"] = "ENHANCED_ROLE_COLORS";
  })(GuildFeature || (exports.GuildFeature = GuildFeature = {}));
  var GuildMemberFlags;
  (function(GuildMemberFlags2) {
    GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
    GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
    GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["IsGuest"] = 16] = "IsGuest";
    GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
    GuildMemberFlags2[GuildMemberFlags2["DmSettingsUpsellAcknowledged"] = 512] = "DmSettingsUpsellAcknowledged";
    GuildMemberFlags2[GuildMemberFlags2["AutoModQuarantinedGuildTag"] = 1024] = "AutoModQuarantinedGuildTag";
  })(GuildMemberFlags || (exports.GuildMemberFlags = GuildMemberFlags = {}));
  var IntegrationExpireBehavior;
  (function(IntegrationExpireBehavior2) {
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
  })(IntegrationExpireBehavior || (exports.IntegrationExpireBehavior = IntegrationExpireBehavior = {}));
  var GuildWidgetStyle;
  (function(GuildWidgetStyle2) {
    GuildWidgetStyle2["Shield"] = "shield";
    GuildWidgetStyle2["Banner1"] = "banner1";
    GuildWidgetStyle2["Banner2"] = "banner2";
    GuildWidgetStyle2["Banner3"] = "banner3";
    GuildWidgetStyle2["Banner4"] = "banner4";
  })(GuildWidgetStyle || (exports.GuildWidgetStyle = GuildWidgetStyle = {}));
  var MembershipScreeningFieldType;
  (function(MembershipScreeningFieldType2) {
    MembershipScreeningFieldType2["Terms"] = "TERMS";
  })(MembershipScreeningFieldType || (exports.MembershipScreeningFieldType = MembershipScreeningFieldType = {}));
  var GuildOnboardingMode;
  (function(GuildOnboardingMode2) {
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
  })(GuildOnboardingMode || (exports.GuildOnboardingMode = GuildOnboardingMode = {}));
  var GuildOnboardingPromptType;
  (function(GuildOnboardingPromptType2) {
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
  })(GuildOnboardingPromptType || (exports.GuildOnboardingPromptType = GuildOnboardingPromptType = {}));
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventStatus = exports.GuildScheduledEventEntityType = exports.GuildScheduledEventRecurrenceRuleMonth = exports.GuildScheduledEventRecurrenceRuleWeekday = exports.GuildScheduledEventRecurrenceRuleFrequency = undefined;
  var GuildScheduledEventRecurrenceRuleFrequency;
  (function(GuildScheduledEventRecurrenceRuleFrequency2) {
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Yearly"] = 0] = "Yearly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Monthly"] = 1] = "Monthly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Weekly"] = 2] = "Weekly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Daily"] = 3] = "Daily";
  })(GuildScheduledEventRecurrenceRuleFrequency || (exports.GuildScheduledEventRecurrenceRuleFrequency = GuildScheduledEventRecurrenceRuleFrequency = {}));
  var GuildScheduledEventRecurrenceRuleWeekday;
  (function(GuildScheduledEventRecurrenceRuleWeekday2) {
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Monday"] = 0] = "Monday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Tuesday"] = 1] = "Tuesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Wednesday"] = 2] = "Wednesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Thursday"] = 3] = "Thursday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Friday"] = 4] = "Friday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Saturday"] = 5] = "Saturday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Sunday"] = 6] = "Sunday";
  })(GuildScheduledEventRecurrenceRuleWeekday || (exports.GuildScheduledEventRecurrenceRuleWeekday = GuildScheduledEventRecurrenceRuleWeekday = {}));
  var GuildScheduledEventRecurrenceRuleMonth;
  (function(GuildScheduledEventRecurrenceRuleMonth2) {
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["January"] = 1] = "January";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["February"] = 2] = "February";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["March"] = 3] = "March";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["April"] = 4] = "April";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["May"] = 5] = "May";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["June"] = 6] = "June";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["July"] = 7] = "July";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["August"] = 8] = "August";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["September"] = 9] = "September";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["October"] = 10] = "October";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["November"] = 11] = "November";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["December"] = 12] = "December";
  })(GuildScheduledEventRecurrenceRuleMonth || (exports.GuildScheduledEventRecurrenceRuleMonth = GuildScheduledEventRecurrenceRuleMonth = {}));
  var GuildScheduledEventEntityType;
  (function(GuildScheduledEventEntityType2) {
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
  })(GuildScheduledEventEntityType || (exports.GuildScheduledEventEntityType = GuildScheduledEventEntityType = {}));
  var GuildScheduledEventStatus;
  (function(GuildScheduledEventStatus2) {
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
  })(GuildScheduledEventStatus || (exports.GuildScheduledEventStatus = GuildScheduledEventStatus = {}));
  var GuildScheduledEventPrivacyLevel;
  (function(GuildScheduledEventPrivacyLevel2) {
    GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(GuildScheduledEventPrivacyLevel || (exports.GuildScheduledEventPrivacyLevel = GuildScheduledEventPrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandOptionType = undefined;
  var ApplicationCommandOptionType;
  (function(ApplicationCommandOptionType2) {
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
  })(ApplicationCommandOptionType || (exports.ApplicationCommandOptionType = ApplicationCommandOptionType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_shared(), exports);
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIApplicationCommandPermissionsConstant = exports.ApplicationCommandPermissionType = undefined;
  var ApplicationCommandPermissionType;
  (function(ApplicationCommandPermissionType2) {
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
  })(ApplicationCommandPermissionType || (exports.ApplicationCommandPermissionType = ApplicationCommandPermissionType = {}));
  exports.APIApplicationCommandPermissionsConstant = {
    Everyone: (guildId) => String(guildId),
    AllChannels: (guildId) => String(BigInt(guildId) - 1n)
  };
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntryPointCommandHandlerType = exports.InteractionContextType = exports.ApplicationIntegrationType = exports.ApplicationCommandType = undefined;
  __exportStar(require_chatInput(), exports);
  __exportStar(require_permissions(), exports);
  var ApplicationCommandType;
  (function(ApplicationCommandType2) {
    ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
    ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
    ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    ApplicationCommandType2[ApplicationCommandType2["PrimaryEntryPoint"] = 4] = "PrimaryEntryPoint";
  })(ApplicationCommandType || (exports.ApplicationCommandType = ApplicationCommandType = {}));
  var ApplicationIntegrationType;
  (function(ApplicationIntegrationType2) {
    ApplicationIntegrationType2[ApplicationIntegrationType2["GuildInstall"] = 0] = "GuildInstall";
    ApplicationIntegrationType2[ApplicationIntegrationType2["UserInstall"] = 1] = "UserInstall";
  })(ApplicationIntegrationType || (exports.ApplicationIntegrationType = ApplicationIntegrationType = {}));
  var InteractionContextType;
  (function(InteractionContextType2) {
    InteractionContextType2[InteractionContextType2["Guild"] = 0] = "Guild";
    InteractionContextType2[InteractionContextType2["BotDM"] = 1] = "BotDM";
    InteractionContextType2[InteractionContextType2["PrivateChannel"] = 2] = "PrivateChannel";
  })(InteractionContextType || (exports.InteractionContextType = InteractionContextType = {}));
  var EntryPointCommandHandlerType;
  (function(EntryPointCommandHandlerType2) {
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["AppHandler"] = 1] = "AppHandler";
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["DiscordLaunchActivity"] = 2] = "DiscordLaunchActivity";
  })(EntryPointCommandHandlerType || (exports.EntryPointCommandHandlerType = EntryPointCommandHandlerType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InteractionResponseType = exports.InteractionType = undefined;
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
    InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
    InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
    InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
    InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
  })(InteractionType || (exports.InteractionType = InteractionType = {}));
  var InteractionResponseType;
  (function(InteractionResponseType2) {
    InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
    InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
    InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
    InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
    InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
    InteractionResponseType2[InteractionResponseType2["LaunchActivity"] = 12] = "LaunchActivity";
  })(InteractionResponseType || (exports.InteractionResponseType = InteractionResponseType = {}));
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_applicationCommands(), exports);
  __exportStar(require_responses(), exports);
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InviteTargetType = exports.InviteType = undefined;
  var InviteType;
  (function(InviteType2) {
    InviteType2[InviteType2["Guild"] = 0] = "Guild";
    InviteType2[InviteType2["GroupDM"] = 1] = "GroupDM";
    InviteType2[InviteType2["Friend"] = 2] = "Friend";
  })(InviteType || (exports.InviteType = InviteType = {}));
  var InviteTargetType;
  (function(InviteTargetType2) {
    InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
    InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
  })(InviteTargetType || (exports.InviteTargetType = InviteTargetType = {}));
});

// node_modules/discord-api-types/payloads/v10/monetization.js
var require_monetization = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SubscriptionStatus = exports.SKUType = exports.SKUFlags = exports.EntitlementType = undefined;
  var EntitlementType;
  (function(EntitlementType2) {
    EntitlementType2[EntitlementType2["Purchase"] = 1] = "Purchase";
    EntitlementType2[EntitlementType2["PremiumSubscription"] = 2] = "PremiumSubscription";
    EntitlementType2[EntitlementType2["DeveloperGift"] = 3] = "DeveloperGift";
    EntitlementType2[EntitlementType2["TestModePurchase"] = 4] = "TestModePurchase";
    EntitlementType2[EntitlementType2["FreePurchase"] = 5] = "FreePurchase";
    EntitlementType2[EntitlementType2["UserGift"] = 6] = "UserGift";
    EntitlementType2[EntitlementType2["PremiumPurchase"] = 7] = "PremiumPurchase";
    EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
  })(EntitlementType || (exports.EntitlementType = EntitlementType = {}));
  var SKUFlags;
  (function(SKUFlags2) {
    SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
    SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
    SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
  })(SKUFlags || (exports.SKUFlags = SKUFlags = {}));
  var SKUType;
  (function(SKUType2) {
    SKUType2[SKUType2["Durable"] = 2] = "Durable";
    SKUType2[SKUType2["Consumable"] = 3] = "Consumable";
    SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
    SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
  })(SKUType || (exports.SKUType = SKUType = {}));
  var SubscriptionStatus;
  (function(SubscriptionStatus2) {
    SubscriptionStatus2[SubscriptionStatus2["Active"] = 0] = "Active";
    SubscriptionStatus2[SubscriptionStatus2["Ending"] = 1] = "Ending";
    SubscriptionStatus2[SubscriptionStatus2["Inactive"] = 2] = "Inactive";
  })(SubscriptionStatus || (exports.SubscriptionStatus = SubscriptionStatus = {}));
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Scopes = undefined;
  var OAuth2Scopes;
  (function(OAuth2Scopes2) {
    OAuth2Scopes2["Bot"] = "bot";
    OAuth2Scopes2["Connections"] = "connections";
    OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
    OAuth2Scopes2["Email"] = "email";
    OAuth2Scopes2["Identify"] = "identify";
    OAuth2Scopes2["Guilds"] = "guilds";
    OAuth2Scopes2["GuildsJoin"] = "guilds.join";
    OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
    OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
    OAuth2Scopes2["MessagesRead"] = "messages.read";
    OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
    OAuth2Scopes2["RPC"] = "rpc";
    OAuth2Scopes2["RPCActivitiesWrite"] = "rpc.activities.write";
    OAuth2Scopes2["RPCVoiceRead"] = "rpc.voice.read";
    OAuth2Scopes2["RPCVoiceWrite"] = "rpc.voice.write";
    OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
    OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
    OAuth2Scopes2["Voice"] = "voice";
    OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
    OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
    OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
    OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
    OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
    OAuth2Scopes2["ActivitiesRead"] = "activities.read";
    OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
    OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
    OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
    OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
  })(OAuth2Scopes || (exports.OAuth2Scopes = OAuth2Scopes = {}));
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoleFlags = undefined;
  var RoleFlags;
  (function(RoleFlags2) {
    RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
  })(RoleFlags || (exports.RoleFlags = RoleFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/poll.js
var require_poll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollLayoutType = undefined;
  var PollLayoutType;
  (function(PollLayoutType2) {
    PollLayoutType2[PollLayoutType2["Default"] = 1] = "Default";
  })(PollLayoutType || (exports.PollLayoutType = PollLayoutType = {}));
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StageInstancePrivacyLevel = undefined;
  var StageInstancePrivacyLevel;
  (function(StageInstancePrivacyLevel2) {
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(StageInstancePrivacyLevel || (exports.StageInstancePrivacyLevel = StageInstancePrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StickerFormatType = exports.StickerType = undefined;
  var StickerType;
  (function(StickerType2) {
    StickerType2[StickerType2["Standard"] = 1] = "Standard";
    StickerType2[StickerType2["Guild"] = 2] = "Guild";
  })(StickerType || (exports.StickerType = StickerType = {}));
  var StickerFormatType;
  (function(StickerFormatType2) {
    StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
    StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
    StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
  })(StickerFormatType || (exports.StickerFormatType = StickerFormatType = {}));
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TeamMemberRole = exports.TeamMemberMembershipState = undefined;
  var TeamMemberMembershipState;
  (function(TeamMemberMembershipState2) {
    TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
    TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
  })(TeamMemberMembershipState || (exports.TeamMemberMembershipState = TeamMemberMembershipState = {}));
  var TeamMemberRole;
  (function(TeamMemberRole2) {
    TeamMemberRole2["Admin"] = "admin";
    TeamMemberRole2["Developer"] = "developer";
    TeamMemberRole2["ReadOnly"] = "read_only";
  })(TeamMemberRole || (exports.TeamMemberRole = TeamMemberRole = {}));
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NameplatePalette = exports.ConnectionVisibility = exports.ConnectionService = exports.UserPremiumType = exports.UserFlags = undefined;
  var UserFlags;
  (function(UserFlags2) {
    UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
    UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
    UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
    UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
    UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
    UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
    UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
    UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
    UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
    UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
    UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
    UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
    UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
    UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
    UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
    UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
    UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
    UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
    UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
    UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
  })(UserFlags || (exports.UserFlags = UserFlags = {}));
  var UserPremiumType;
  (function(UserPremiumType2) {
    UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
    UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
    UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
  })(UserPremiumType || (exports.UserPremiumType = UserPremiumType = {}));
  var ConnectionService;
  (function(ConnectionService2) {
    ConnectionService2["AmazonMusic"] = "amazon-music";
    ConnectionService2["BattleNet"] = "battlenet";
    ConnectionService2["Bluesky"] = "bluesky";
    ConnectionService2["BungieNet"] = "bungie";
    ConnectionService2["Crunchyroll"] = "crunchyroll";
    ConnectionService2["Domain"] = "domain";
    ConnectionService2["eBay"] = "ebay";
    ConnectionService2["EpicGames"] = "epicgames";
    ConnectionService2["Facebook"] = "facebook";
    ConnectionService2["GitHub"] = "github";
    ConnectionService2["Instagram"] = "instagram";
    ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
    ConnectionService2["Mastodon"] = "mastodon";
    ConnectionService2["PayPal"] = "paypal";
    ConnectionService2["PlayStationNetwork"] = "playstation";
    ConnectionService2["Reddit"] = "reddit";
    ConnectionService2["RiotGames"] = "riotgames";
    ConnectionService2["Roblox"] = "roblox";
    ConnectionService2["Spotify"] = "spotify";
    ConnectionService2["Skype"] = "skype";
    ConnectionService2["Steam"] = "steam";
    ConnectionService2["TikTok"] = "tiktok";
    ConnectionService2["Twitch"] = "twitch";
    ConnectionService2["X"] = "twitter";
    ConnectionService2["Twitter"] = "twitter";
    ConnectionService2["Xbox"] = "xbox";
    ConnectionService2["YouTube"] = "youtube";
  })(ConnectionService || (exports.ConnectionService = ConnectionService = {}));
  var ConnectionVisibility;
  (function(ConnectionVisibility2) {
    ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
    ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
  })(ConnectionVisibility || (exports.ConnectionVisibility = ConnectionVisibility = {}));
  var NameplatePalette;
  (function(NameplatePalette2) {
    NameplatePalette2["Berry"] = "berry";
    NameplatePalette2["BubbleGum"] = "bubble_gum";
    NameplatePalette2["Clover"] = "clover";
    NameplatePalette2["Cobalt"] = "cobalt";
    NameplatePalette2["Crimson"] = "crimson";
    NameplatePalette2["Forest"] = "forest";
    NameplatePalette2["Lemon"] = "lemon";
    NameplatePalette2["Sky"] = "sky";
    NameplatePalette2["Teal"] = "teal";
    NameplatePalette2["Violet"] = "violet";
    NameplatePalette2["White"] = "white";
  })(NameplatePalette || (exports.NameplatePalette = NameplatePalette = {}));
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookType = exports.ApplicationWebhookEventType = exports.ApplicationWebhookType = undefined;
  var ApplicationWebhookType;
  (function(ApplicationWebhookType2) {
    ApplicationWebhookType2[ApplicationWebhookType2["Ping"] = 0] = "Ping";
    ApplicationWebhookType2[ApplicationWebhookType2["Event"] = 1] = "Event";
  })(ApplicationWebhookType || (exports.ApplicationWebhookType = ApplicationWebhookType = {}));
  var ApplicationWebhookEventType;
  (function(ApplicationWebhookEventType2) {
    ApplicationWebhookEventType2["ApplicationAuthorized"] = "APPLICATION_AUTHORIZED";
    ApplicationWebhookEventType2["ApplicationDeauthorized"] = "APPLICATION_DEAUTHORIZED";
    ApplicationWebhookEventType2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    ApplicationWebhookEventType2["QuestUserEnrollment"] = "QUEST_USER_ENROLLMENT";
  })(ApplicationWebhookEventType || (exports.ApplicationWebhookEventType = ApplicationWebhookEventType = {}));
  var WebhookType;
  (function(WebhookType2) {
    WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
    WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
    WebhookType2[WebhookType2["Application"] = 3] = "Application";
  })(WebhookType || (exports.WebhookType = WebhookType = {}));
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common(), exports);
  __exportStar(require_application(), exports);
  __exportStar(require_auditLog(), exports);
  __exportStar(require_autoModeration(), exports);
  __exportStar(require_channel(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_guild(), exports);
  __exportStar(require_guildScheduledEvent(), exports);
  __exportStar(require_interactions(), exports);
  __exportStar(require_invite(), exports);
  __exportStar(require_monetization(), exports);
  __exportStar(require_oauth2(), exports);
  __exportStar(require_permissions2(), exports);
  __exportStar(require_poll(), exports);
  __exportStar(require_stageInstance(), exports);
  __exportStar(require_sticker(), exports);
  __exportStar(require_teams(), exports);
  __exportStar(require_user(), exports);
  __exportStar(require_webhook(), exports);
});

// node_modules/discord-api-types/utils/internals.js
var require_internals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.urlSafeCharacters = undefined;
  var pattern = /^[\d%A-Za-z-_]+$/g;
  exports.urlSafeCharacters = {
    test(input) {
      const result = pattern.test(input);
      pattern.lastIndex = 0;
      return result;
    }
  };
});

// node_modules/discord-api-types/rest/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Locale = exports.RESTJSONErrorCodes = undefined;
  var RESTJSONErrorCodes;
  (function(RESTJSONErrorCodes2) {
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAsset"] = 10021] = "UnknownAsset";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStickerPack"] = 10061] = "UnknownStickerPack";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSound"] = 10097] = "UnknownSound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfSoundboardSoundsReached"] = 30045] = "MaximumNumberOfSoundboardSoundsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyConsumableSKUsCanBeConsumed"] = 40018] = "OnlyConsumableSKUsCanBeConsumed";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCanOnlyDeleteSandboxEntitlements"] = 40019] = "YouCanOnlyDeleteSandboxEntitlements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnEntitlementHasAlreadyBeenGrantedForThisResource"] = 40074] = "AnEntitlementHasAlreadyBeenGrantedForThisResource";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages"] = 40094] = "ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CloudflareIsBlockingYourRequest"] = 40333] = "CloudflareIsBlockingYourRequest";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidSKU"] = 50057] = "InvalidSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileIsInvalid"] = 50110] = "ProvidedFileIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileTypeIsInvalid"] = 50123] = "ProvidedFileTypeIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDurationExceedsMaximumLength"] = 50124] = "ProvidedFileDurationExceedsMaximumLength";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SpecifiedEmojiIsInvalid"] = 50151] = "SpecifiedEmojiIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDoesNotHaveAValidDuration"] = 50192] = "ProvidedFileDoesNotHaveAValidDuration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserCannotUseBurstReactions"] = 90002] = "UserCannotUseBurstReactions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 130000] = "APIResourceOverloaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 180000] = "CannotUpdateAFinishedEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 200000] = "MessageWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 240000] = "MessageBlockedByHarmfulLinksFilter";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 350000] = "CannotEnableOnboardingRequirementsAreNotMet";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToBanUsers"] = 500000] = "FailedToBanUsers";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollVotingBlocked"] = 520000] = "PollVotingBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollExpired"] = 520001] = "PollExpired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidChannelTypeForPollCreation"] = 520002] = "InvalidChannelTypeForPollCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditAPollMessage"] = 520003] = "CannotEditAPollMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUseAnEmojiIncludedWithThePoll"] = 520004] = "CannotUseAnEmojiIncludedWithThePoll";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExpireANonPollMessage"] = 520006] = "CannotExpireANonPollMessage";
  })(RESTJSONErrorCodes || (exports.RESTJSONErrorCodes = RESTJSONErrorCodes = {}));
  var Locale;
  (function(Locale2) {
    Locale2["Indonesian"] = "id";
    Locale2["EnglishUS"] = "en-US";
    Locale2["EnglishGB"] = "en-GB";
    Locale2["Bulgarian"] = "bg";
    Locale2["ChineseCN"] = "zh-CN";
    Locale2["ChineseTW"] = "zh-TW";
    Locale2["Croatian"] = "hr";
    Locale2["Czech"] = "cs";
    Locale2["Danish"] = "da";
    Locale2["Dutch"] = "nl";
    Locale2["Finnish"] = "fi";
    Locale2["French"] = "fr";
    Locale2["German"] = "de";
    Locale2["Greek"] = "el";
    Locale2["Hindi"] = "hi";
    Locale2["Hungarian"] = "hu";
    Locale2["Italian"] = "it";
    Locale2["Japanese"] = "ja";
    Locale2["Korean"] = "ko";
    Locale2["Lithuanian"] = "lt";
    Locale2["Norwegian"] = "no";
    Locale2["Polish"] = "pl";
    Locale2["PortugueseBR"] = "pt-BR";
    Locale2["Romanian"] = "ro";
    Locale2["Russian"] = "ru";
    Locale2["SpanishES"] = "es-ES";
    Locale2["SpanishLATAM"] = "es-419";
    Locale2["Swedish"] = "sv-SE";
    Locale2["Thai"] = "th";
    Locale2["Turkish"] = "tr";
    Locale2["Ukrainian"] = "uk";
    Locale2["Vietnamese"] = "vi";
  })(Locale || (exports.Locale = Locale = {}));
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReactionType = undefined;
  var ReactionType;
  (function(ReactionType2) {
    ReactionType2[ReactionType2["Normal"] = 0] = "Normal";
    ReactionType2[ReactionType2["Super"] = 1] = "Super";
  })(ReactionType || (exports.ReactionType = ReactionType = {}));
});

// node_modules/discord-api-types/rest/v10/monetization.js
var require_monetization2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntitlementOwnerType = undefined;
  var EntitlementOwnerType;
  (function(EntitlementOwnerType2) {
    EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
    EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
  })(EntitlementOwnerType || (exports.EntitlementOwnerType = EntitlementOwnerType = {}));
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Routes = exports.RouteBases = exports.CDNRoutes = exports.ImageFormat = exports.StickerPackApplicationId = exports.Routes = exports.APIVersion = undefined;
  var internals_1 = require_internals();
  __exportStar(require_common2(), exports);
  __exportStar(require_channel2(), exports);
  __exportStar(require_monetization2(), exports);
  exports.APIVersion = "10";
  exports.Routes = {
    applicationRoleConnectionMetadata(applicationId) {
      return `/applications/${applicationId}/role-connections/metadata`;
    },
    guildAutoModerationRules(guildId) {
      return `/guilds/${guildId}/auto-moderation/rules`;
    },
    guildAutoModerationRule(guildId, ruleId) {
      return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
    },
    guildAuditLog(guildId) {
      return `/guilds/${guildId}/audit-logs`;
    },
    channel(channelId) {
      return `/channels/${channelId}`;
    },
    channelMessages(channelId) {
      return `/channels/${channelId}/messages`;
    },
    channelMessage(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}`;
    },
    channelMessageCrosspost(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/crosspost`;
    },
    channelMessageOwnReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
    },
    channelMessageUserReaction(channelId, messageId, emoji, userId) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
    },
    channelMessageReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
    },
    channelMessageAllReactions(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/reactions`;
    },
    channelBulkDelete(channelId) {
      return `/channels/${channelId}/messages/bulk-delete`;
    },
    channelPermission(channelId, overwriteId) {
      return `/channels/${channelId}/permissions/${overwriteId}`;
    },
    channelInvites(channelId) {
      return `/channels/${channelId}/invites`;
    },
    channelFollowers(channelId) {
      return `/channels/${channelId}/followers`;
    },
    channelTyping(channelId) {
      return `/channels/${channelId}/typing`;
    },
    channelMessagesPins(channelId) {
      return `/channels/${channelId}/messages/pins`;
    },
    channelMessagesPin(channelId, messageId) {
      return `/channels/${channelId}/messages/pins/${messageId}`;
    },
    channelPins(channelId) {
      return `/channels/${channelId}/pins`;
    },
    channelPin(channelId, messageId) {
      return `/channels/${channelId}/pins/${messageId}`;
    },
    channelRecipient(channelId, userId) {
      return `/channels/${channelId}/recipients/${userId}`;
    },
    guildEmojis(guildId) {
      return `/guilds/${guildId}/emojis`;
    },
    guildEmoji(guildId, emojiId) {
      return `/guilds/${guildId}/emojis/${emojiId}`;
    },
    guilds() {
      return "/guilds";
    },
    guild(guildId) {
      return `/guilds/${guildId}`;
    },
    guildPreview(guildId) {
      return `/guilds/${guildId}/preview`;
    },
    guildChannels(guildId) {
      return `/guilds/${guildId}/channels`;
    },
    guildMember(guildId, userId = "@me") {
      return `/guilds/${guildId}/members/${userId}`;
    },
    guildMembers(guildId) {
      return `/guilds/${guildId}/members`;
    },
    guildMembersSearch(guildId) {
      return `/guilds/${guildId}/members/search`;
    },
    guildCurrentMemberNickname(guildId) {
      return `/guilds/${guildId}/members/@me/nick`;
    },
    guildMemberRole(guildId, memberId, roleId) {
      return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
    },
    guildMFA(guildId) {
      return `/guilds/${guildId}/mfa`;
    },
    guildBans(guildId) {
      return `/guilds/${guildId}/bans`;
    },
    guildBan(guildId, userId) {
      return `/guilds/${guildId}/bans/${userId}`;
    },
    guildRoles(guildId) {
      return `/guilds/${guildId}/roles`;
    },
    guildRole(guildId, roleId) {
      return `/guilds/${guildId}/roles/${roleId}`;
    },
    guildPrune(guildId) {
      return `/guilds/${guildId}/prune`;
    },
    guildVoiceRegions(guildId) {
      return `/guilds/${guildId}/regions`;
    },
    guildInvites(guildId) {
      return `/guilds/${guildId}/invites`;
    },
    guildIntegrations(guildId) {
      return `/guilds/${guildId}/integrations`;
    },
    guildIntegration(guildId, integrationId) {
      return `/guilds/${guildId}/integrations/${integrationId}`;
    },
    guildWidgetSettings(guildId) {
      return `/guilds/${guildId}/widget`;
    },
    guildWidgetJSON(guildId) {
      return `/guilds/${guildId}/widget.json`;
    },
    guildVanityUrl(guildId) {
      return `/guilds/${guildId}/vanity-url`;
    },
    guildWidgetImage(guildId) {
      return `/guilds/${guildId}/widget.png`;
    },
    invite(code) {
      return `/invites/${code}`;
    },
    template(code) {
      return `/guilds/templates/${code}`;
    },
    guildTemplates(guildId) {
      return `/guilds/${guildId}/templates`;
    },
    guildTemplate(guildId, code) {
      return `/guilds/${guildId}/templates/${code}`;
    },
    pollAnswerVoters(channelId, messageId, answerId) {
      return `/channels/${channelId}/polls/${messageId}/answers/${answerId}`;
    },
    expirePoll(channelId, messageId) {
      return `/channels/${channelId}/polls/${messageId}/expire`;
    },
    threads(parentId, messageId) {
      const parts = ["", "channels", parentId];
      if (messageId)
        parts.push("messages", messageId);
      parts.push("threads");
      return parts.join("/");
    },
    guildActiveThreads(guildId) {
      return `/guilds/${guildId}/threads/active`;
    },
    channelThreads(channelId, archivedStatus) {
      return `/channels/${channelId}/threads/archived/${archivedStatus}`;
    },
    channelJoinedArchivedThreads(channelId) {
      return `/channels/${channelId}/users/@me/threads/archived/private`;
    },
    threadMembers(threadId, userId) {
      const parts = ["", "channels", threadId, "thread-members"];
      if (userId)
        parts.push(userId);
      return parts.join("/");
    },
    user(userId = "@me") {
      return `/users/${userId}`;
    },
    userApplicationRoleConnection(applicationId) {
      return `/users/@me/applications/${applicationId}/role-connection`;
    },
    userGuilds() {
      return `/users/@me/guilds`;
    },
    userGuildMember(guildId) {
      return `/users/@me/guilds/${guildId}/member`;
    },
    userGuild(guildId) {
      return `/users/@me/guilds/${guildId}`;
    },
    userChannels() {
      return `/users/@me/channels`;
    },
    userConnections() {
      return `/users/@me/connections`;
    },
    voiceRegions() {
      return `/voice/regions`;
    },
    channelWebhooks(channelId) {
      return `/channels/${channelId}/webhooks`;
    },
    guildWebhooks(guildId) {
      return `/guilds/${guildId}/webhooks`;
    },
    webhook(webhookId, webhookToken) {
      const parts = ["", "webhooks", webhookId];
      if (webhookToken)
        parts.push(webhookToken);
      return parts.join("/");
    },
    webhookMessage(webhookId, webhookToken, messageId = "@original") {
      return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
    },
    webhookPlatform(webhookId, webhookToken, platform) {
      return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
    },
    gateway() {
      return `/gateway`;
    },
    gatewayBot() {
      return `/gateway/bot`;
    },
    oauth2CurrentApplication() {
      return `/oauth2/applications/@me`;
    },
    oauth2CurrentAuthorization() {
      return `/oauth2/@me`;
    },
    oauth2Authorization() {
      return `/oauth2/authorize`;
    },
    oauth2TokenExchange() {
      return `/oauth2/token`;
    },
    oauth2TokenRevocation() {
      return `/oauth2/token/revoke`;
    },
    applicationCommands(applicationId) {
      return `/applications/${applicationId}/commands`;
    },
    applicationCommand(applicationId, commandId) {
      return `/applications/${applicationId}/commands/${commandId}`;
    },
    applicationGuildCommands(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands`;
    },
    applicationGuildCommand(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
    },
    interactionCallback(interactionId, interactionToken) {
      return `/interactions/${interactionId}/${interactionToken}/callback`;
    },
    guildMemberVerification(guildId) {
      return `/guilds/${guildId}/member-verification`;
    },
    guildVoiceState(guildId, userId = "@me") {
      return `/guilds/${guildId}/voice-states/${userId}`;
    },
    guildApplicationCommandsPermissions(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
    },
    applicationCommandPermissions(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
    },
    guildWelcomeScreen(guildId) {
      return `/guilds/${guildId}/welcome-screen`;
    },
    stageInstances() {
      return `/stage-instances`;
    },
    stageInstance(channelId) {
      return `/stage-instances/${channelId}`;
    },
    sticker(stickerId) {
      return `/stickers/${stickerId}`;
    },
    stickerPacks() {
      return "/sticker-packs";
    },
    stickerPack(packId) {
      return `/sticker-packs/${packId}`;
    },
    nitroStickerPacks() {
      return "/sticker-packs";
    },
    guildStickers(guildId) {
      return `/guilds/${guildId}/stickers`;
    },
    guildSticker(guildId, stickerId) {
      return `/guilds/${guildId}/stickers/${stickerId}`;
    },
    guildScheduledEvents(guildId) {
      return `/guilds/${guildId}/scheduled-events`;
    },
    guildScheduledEvent(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
    },
    guildScheduledEventUsers(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
    },
    guildOnboarding(guildId) {
      return `/guilds/${guildId}/onboarding`;
    },
    guildIncidentActions(guildId) {
      return `/guilds/${guildId}/incident-actions`;
    },
    currentApplication() {
      return "/applications/@me";
    },
    entitlements(applicationId) {
      return `/applications/${applicationId}/entitlements`;
    },
    entitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}`;
    },
    skus(applicationId) {
      return `/applications/${applicationId}/skus`;
    },
    guildBulkBan(guildId) {
      return `/guilds/${guildId}/bulk-ban`;
    },
    consumeEntitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}/consume`;
    },
    applicationEmojis(applicationId) {
      return `/applications/${applicationId}/emojis`;
    },
    applicationEmoji(applicationId, emojiId) {
      return `/applications/${applicationId}/emojis/${emojiId}`;
    },
    skuSubscriptions(skuId) {
      return `/skus/${skuId}/subscriptions`;
    },
    skuSubscription(skuId, subscriptionId) {
      return `/skus/${skuId}/subscriptions/${subscriptionId}`;
    },
    sendSoundboardSound(channelId) {
      return `/channels/${channelId}/send-soundboard-sound`;
    },
    soundboardDefaultSounds() {
      return "/soundboard-default-sounds";
    },
    guildSoundboardSounds(guildId) {
      return `/guilds/${guildId}/soundboard-sounds`;
    },
    guildSoundboardSound(guildId, soundId) {
      return `/guilds/${guildId}/soundboard-sounds/${soundId}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.Routes)) {
    exports.Routes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.Routes);
  exports.StickerPackApplicationId = "710982414301790216";
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["JPEG"] = "jpeg";
    ImageFormat2["PNG"] = "png";
    ImageFormat2["WebP"] = "webp";
    ImageFormat2["GIF"] = "gif";
    ImageFormat2["Lottie"] = "json";
  })(ImageFormat || (exports.ImageFormat = ImageFormat = {}));
  exports.CDNRoutes = {
    emoji(emojiId, format) {
      return `/emojis/${emojiId}.${format}`;
    },
    guildIcon(guildId, guildIcon, format) {
      return `/icons/${guildId}/${guildIcon}.${format}`;
    },
    guildSplash(guildId, guildSplash, format) {
      return `/splashes/${guildId}/${guildSplash}.${format}`;
    },
    guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
      return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
    },
    guildBanner(guildId, guildBanner, format) {
      return `/banners/${guildId}/${guildBanner}.${format}`;
    },
    userBanner(userId, userBanner, format) {
      return `/banners/${userId}/${userBanner}.${format}`;
    },
    defaultUserAvatar(index) {
      return `/embed/avatars/${index}.png`;
    },
    userAvatar(userId, userAvatar, format) {
      return `/avatars/${userId}/${userAvatar}.${format}`;
    },
    guildMemberAvatar(guildId, userId, memberAvatar, format) {
      return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
    },
    userAvatarDecoration(userId, userAvatarDecoration) {
      return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
    },
    avatarDecoration(avatarDecorationDataAsset) {
      return `/avatar-decoration-presets/${avatarDecorationDataAsset}.png`;
    },
    applicationIcon(applicationId, applicationIcon, format) {
      return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
    },
    applicationCover(applicationId, applicationCoverImage, format) {
      return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
    },
    applicationAsset(applicationId, applicationAssetId, format) {
      return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
    },
    achievementIcon(applicationId, achievementId, achievementIconHash, format) {
      return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
    },
    stickerPackBanner(stickerPackBannerAssetId, format) {
      return `/app-assets/${exports.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
    },
    storePageAsset(applicationId, assetId, format = ImageFormat.PNG) {
      return `/app-assets/${applicationId}/store/${assetId}.${format}`;
    },
    teamIcon(teamId, teamIcon, format) {
      return `/team-icons/${teamId}/${teamIcon}.${format}`;
    },
    sticker(stickerId, format) {
      return `/stickers/${stickerId}.${format}`;
    },
    roleIcon(roleId, roleIcon, format) {
      return `/role-icons/${roleId}/${roleIcon}.${format}`;
    },
    guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
      return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
    },
    guildMemberBanner(guildId, userId, guildMemberBanner, format) {
      return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
    },
    soundboardSound(soundId) {
      return `/soundboard-sounds/${soundId}`;
    },
    guildTagBadge(guildId, guildTagBadge, format) {
      return `/guild-tag-badges/${guildId}/${guildTagBadge}.${format}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.CDNRoutes)) {
    exports.CDNRoutes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.CDNRoutes);
  exports.RouteBases = {
    api: `https://discord.com/api/v${exports.APIVersion}`,
    cdn: "https://cdn.discordapp.com",
    media: "https://media.discordapp.net",
    invite: "https://discord.gg",
    template: "https://discord.new",
    gift: "https://discord.gift",
    scheduledEvent: "https://discord.com/events"
  };
  Object.freeze(exports.RouteBases);
  exports.OAuth2Routes = {
    authorizationURL: `${exports.RouteBases.api}${exports.Routes.oauth2Authorization()}`,
    tokenURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenExchange()}`,
    tokenRevocationURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenRevocation()}`
  };
  Object.freeze(exports.OAuth2Routes);
});

// node_modules/discord-api-types/rpc/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCCloseEventCodes = exports.RPCErrorCodes = exports.RelationshipType = exports.VoiceConnectionStates = exports.RPCVoiceShortcutKeyComboKeyType = exports.RPCVoiceSettingsModeType = exports.RPCDeviceType = undefined;
  var RPCDeviceType;
  (function(RPCDeviceType2) {
    RPCDeviceType2["AudioInput"] = "audioinput";
    RPCDeviceType2["AudioOutput"] = "audiooutput";
    RPCDeviceType2["VideoInput"] = "videoinput";
  })(RPCDeviceType || (exports.RPCDeviceType = RPCDeviceType = {}));
  var RPCVoiceSettingsModeType;
  (function(RPCVoiceSettingsModeType2) {
    RPCVoiceSettingsModeType2["PushToTalk"] = "PUSH_TO_TALK";
    RPCVoiceSettingsModeType2["VoiceActivity"] = "VOICE_ACTIVITY";
  })(RPCVoiceSettingsModeType || (exports.RPCVoiceSettingsModeType = RPCVoiceSettingsModeType = {}));
  var RPCVoiceShortcutKeyComboKeyType;
  (function(RPCVoiceShortcutKeyComboKeyType2) {
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardKey"] = 0] = "KeyboardKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["MouseButton"] = 1] = "MouseButton";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardModifierKey"] = 2] = "KeyboardModifierKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["GamepadButton"] = 3] = "GamepadButton";
  })(RPCVoiceShortcutKeyComboKeyType || (exports.RPCVoiceShortcutKeyComboKeyType = RPCVoiceShortcutKeyComboKeyType = {}));
  var VoiceConnectionStates;
  (function(VoiceConnectionStates2) {
    VoiceConnectionStates2["Disconnected"] = "DISCONNECTED";
    VoiceConnectionStates2["AwaitingEndpoint"] = "AWAITING_ENDPOINT";
    VoiceConnectionStates2["Authenticating"] = "AUTHENTICATING";
    VoiceConnectionStates2["Connecting"] = "CONNECTING";
    VoiceConnectionStates2["Connected"] = "CONNECTED";
    VoiceConnectionStates2["VoiceDisconnected"] = "VOICE_DISCONNECTED";
    VoiceConnectionStates2["VoiceConnecting"] = "VOICE_CONNECTING";
    VoiceConnectionStates2["VoiceConnected"] = "VOICE_CONNECTED";
    VoiceConnectionStates2["NoRoute"] = "NO_ROUTE";
    VoiceConnectionStates2["IceChecking"] = "ICE_CHECKING";
  })(VoiceConnectionStates || (exports.VoiceConnectionStates = VoiceConnectionStates = {}));
  var RelationshipType;
  (function(RelationshipType2) {
    RelationshipType2[RelationshipType2["None"] = 0] = "None";
    RelationshipType2[RelationshipType2["Friend"] = 1] = "Friend";
    RelationshipType2[RelationshipType2["Blocked"] = 2] = "Blocked";
    RelationshipType2[RelationshipType2["PendingIncoming"] = 3] = "PendingIncoming";
    RelationshipType2[RelationshipType2["PendingOutgoing"] = 4] = "PendingOutgoing";
    RelationshipType2[RelationshipType2["Implicit"] = 5] = "Implicit";
  })(RelationshipType || (exports.RelationshipType = RelationshipType = {}));
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1000] = "UnknownError";
    RPCErrorCodes2[RPCErrorCodes2["ServiceUnavailable"] = 1001] = "ServiceUnavailable";
    RPCErrorCodes2[RPCErrorCodes2["TransactionAborted"] = 1002] = "TransactionAborted";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4000] = "InvalidPayload";
    RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
    RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
    RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
    RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
    RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
    RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
    RPCErrorCodes2[RPCErrorCodes2["InvalidInvite"] = 4011] = "InvalidInvite";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivityJoinRequest"] = 4012] = "InvalidActivityJoinRequest";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEntitlement"] = 4013] = "InvalidEntitlement";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGiftCode"] = 4014] = "InvalidGiftCode";
    RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5000] = "OAuth2Error";
    RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
    RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivitySecret"] = 5005] = "InvalidActivitySecret";
    RPCErrorCodes2[RPCErrorCodes2["NoEligibleActivity"] = 5006] = "NoEligibleActivity";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseCanceled"] = 5007] = "PurchaseCanceled";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseError"] = 5008] = "PurchaseError";
    RPCErrorCodes2[RPCErrorCodes2["UnauthorizedForAchievement"] = 5009] = "UnauthorizedForAchievement";
    RPCErrorCodes2[RPCErrorCodes2["RateLimited"] = 5010] = "RateLimited";
  })(RPCErrorCodes || (exports.RPCErrorCodes = RPCErrorCodes = {}));
  var RPCCloseEventCodes;
  (function(RPCCloseEventCodes2) {
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseNormal"] = 1000] = "CloseNormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseUnsupported"] = 1003] = "CloseUnsupported";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseAbnormal"] = 1006] = "CloseAbnormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4000] = "InvalidClientId";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
    RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
    RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
  })(RPCCloseEventCodes || (exports.RPCCloseEventCodes = RPCCloseEventCodes = {}));
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCEvents = exports.RPCCommands = exports.RPCVersion = undefined;
  __exportStar(require_common3(), exports);
  exports.RPCVersion = "1";
  var RPCCommands;
  (function(RPCCommands2) {
    RPCCommands2["AcceptActivityInvite"] = "ACCEPT_ACTIVITY_INVITE";
    RPCCommands2["ActivityInviteUser"] = "ACTIVITY_INVITE_USER";
    RPCCommands2["Authenticate"] = "AUTHENTICATE";
    RPCCommands2["Authorize"] = "AUTHORIZE";
    RPCCommands2["BraintreePopupBridgeCallback"] = "BRAINTREE_POPUP_BRIDGE_CALLBACK";
    RPCCommands2["BrowserHandoff"] = "BROWSER_HANDOFF";
    RPCCommands2["CloseActivityJoinRequest"] = "CLOSE_ACTIVITY_JOIN_REQUEST";
    RPCCommands2["ConnectionsCallback"] = "CONNECTIONS_CALLBACK";
    RPCCommands2["CreateChannelInvite"] = "CREATE_CHANNEL_INVITE";
    RPCCommands2["DeepLink"] = "DEEP_LINK";
    RPCCommands2["Dispatch"] = "DISPATCH";
    RPCCommands2["GetApplicationTicket"] = "GET_APPLICATION_TICKET";
    RPCCommands2["GetChannel"] = "GET_CHANNEL";
    RPCCommands2["GetChannels"] = "GET_CHANNELS";
    RPCCommands2["GetEntitlementTicket"] = "GET_ENTITLEMENT_TICKET";
    RPCCommands2["GetEntitlements"] = "GET_ENTITLEMENTS";
    RPCCommands2["GetGuild"] = "GET_GUILD";
    RPCCommands2["GetGuilds"] = "GET_GUILDS";
    RPCCommands2["GetImage"] = "GET_IMAGE";
    RPCCommands2["GetNetworkingConfig"] = "GET_NETWORKING_CONFIG";
    RPCCommands2["GetRelationships"] = "GET_RELATIONSHIPS";
    RPCCommands2["GetSelectedVoiceChannel"] = "GET_SELECTED_VOICE_CHANNEL";
    RPCCommands2["GetSkus"] = "GET_SKUS";
    RPCCommands2["GetUser"] = "GET_USER";
    RPCCommands2["GetVoiceSettings"] = "GET_VOICE_SETTINGS";
    RPCCommands2["GiftCodeBrowser"] = "GIFT_CODE_BROWSER";
    RPCCommands2["GuildTemplateBrowser"] = "GUILD_TEMPLATE_BROWSER";
    RPCCommands2["InviteBrowser"] = "INVITE_BROWSER";
    RPCCommands2["NetworkingCreateToken"] = "NETWORKING_CREATE_TOKEN";
    RPCCommands2["NetworkingPeerMetrics"] = "NETWORKING_PEER_METRICS";
    RPCCommands2["NetworkingSystemMetrics"] = "NETWORKING_SYSTEM_METRICS";
    RPCCommands2["OpenOverlayActivityInvite"] = "OPEN_OVERLAY_ACTIVITY_INVITE";
    RPCCommands2["OpenOverlayGuildInvite"] = "OPEN_OVERLAY_GUILD_INVITE";
    RPCCommands2["OpenOverlayVoiceSettings"] = "OPEN_OVERLAY_VOICE_SETTINGS";
    RPCCommands2["Overlay"] = "OVERLAY";
    RPCCommands2["SelectTextChannel"] = "SELECT_TEXT_CHANNEL";
    RPCCommands2["SelectVoiceChannel"] = "SELECT_VOICE_CHANNEL";
    RPCCommands2["SendActivityJoinInvite"] = "SEND_ACTIVITY_JOIN_INVITE";
    RPCCommands2["SetActivity"] = "SET_ACTIVITY";
    RPCCommands2["SetCertifiedDevices"] = "SET_CERTIFIED_DEVICES";
    RPCCommands2["SetOverlayLocked"] = "SET_OVERLAY_LOCKED";
    RPCCommands2["SetUserVoiceSettings"] = "SET_USER_VOICE_SETTINGS";
    RPCCommands2["SetUserVoiceSettings2"] = "SET_USER_VOICE_SETTINGS_2";
    RPCCommands2["SetVoiceSettings"] = "SET_VOICE_SETTINGS";
    RPCCommands2["SetVoiceSettings2"] = "SET_VOICE_SETTINGS_2";
    RPCCommands2["StartPurchase"] = "START_PURCHASE";
    RPCCommands2["Subscribe"] = "SUBSCRIBE";
    RPCCommands2["Unsubscribe"] = "UNSUBSCRIBE";
    RPCCommands2["ValidateApplication"] = "VALIDATE_APPLICATION";
  })(RPCCommands || (exports.RPCCommands = RPCCommands = {}));
  var RPCEvents;
  (function(RPCEvents2) {
    RPCEvents2["ActivityInvite"] = "ACTIVITY_INVITE";
    RPCEvents2["ActivityJoin"] = "ACTIVITY_JOIN";
    RPCEvents2["ActivityJoinRequest"] = "ACTIVITY_JOIN_REQUEST";
    RPCEvents2["ActivitySpectate"] = "ACTIVITY_SPECTATE";
    RPCEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    RPCEvents2["CurrentUserUpdate"] = "CURRENT_USER_UPDATE";
    RPCEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    RPCEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    RPCEvents2["Error"] = "ERROR";
    RPCEvents2["GameJoin"] = "GAME_JOIN";
    RPCEvents2["GameSpectate"] = "GAME_SPECTATE";
    RPCEvents2["GuildCreate"] = "GUILD_CREATE";
    RPCEvents2["GuildStatus"] = "GUILD_STATUS";
    RPCEvents2["MessageCreate"] = "MESSAGE_CREATE";
    RPCEvents2["MessageDelete"] = "MESSAGE_DELETE";
    RPCEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    RPCEvents2["NotificationCreate"] = "NOTIFICATION_CREATE";
    RPCEvents2["Overlay"] = "OVERLAY";
    RPCEvents2["OverlayUpdate"] = "OVERLAY_UPDATE";
    RPCEvents2["Ready"] = "READY";
    RPCEvents2["RelationshipUpdate"] = "RELATIONSHIP_UPDATE";
    RPCEvents2["SpeakingStart"] = "SPEAKING_START";
    RPCEvents2["SpeakingStop"] = "SPEAKING_STOP";
    RPCEvents2["VoiceChannelSelect"] = "VOICE_CHANNEL_SELECT";
    RPCEvents2["VoiceConnectionStatus"] = "VOICE_CONNECTION_STATUS";
    RPCEvents2["VoiceSettingsUpdate"] = "VOICE_SETTINGS_UPDATE";
    RPCEvents2["VoiceSettingsUpdate2"] = "VOICE_SETTINGS_UPDATE_2";
    RPCEvents2["VoiceStateCreate"] = "VOICE_STATE_CREATE";
    RPCEvents2["VoiceStateDelete"] = "VOICE_STATE_DELETE";
    RPCEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
  })(RPCEvents || (exports.RPCEvents = RPCEvents = {}));
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDMInteraction = isDMInteraction;
  exports.isGuildInteraction = isGuildInteraction;
  exports.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
  exports.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
  exports.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
  exports.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
  exports.isLinkButton = isLinkButton;
  exports.isInteractionButton = isInteractionButton;
  exports.isMessageComponentInteraction = isMessageComponentInteraction;
  exports.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
  exports.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
  exports.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
  exports.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  var index_1 = require_v102();
  function isDMInteraction(interaction) {
    return Reflect.has(interaction, "user");
  }
  function isGuildInteraction(interaction) {
    return Reflect.has(interaction, "guild_id");
  }
  function isApplicationCommandDMInteraction(interaction) {
    return isDMInteraction(interaction);
  }
  function isApplicationCommandGuildInteraction(interaction) {
    return isGuildInteraction(interaction);
  }
  function isMessageComponentDMInteraction(interaction) {
    return isDMInteraction(interaction);
  }
  function isMessageComponentGuildInteraction(interaction) {
    return isGuildInteraction(interaction);
  }
  function isLinkButton(component) {
    return component.style === index_1.ButtonStyle.Link;
  }
  function isInteractionButton(component) {
    return ![index_1.ButtonStyle.Link, index_1.ButtonStyle.Premium].includes(component.style);
  }
  function isMessageComponentInteraction(interaction) {
    return interaction.type === index_1.InteractionType.MessageComponent;
  }
  function isMessageComponentButtonInteraction(interaction) {
    return interaction.data.component_type === index_1.ComponentType.Button;
  }
  function isMessageComponentSelectMenuInteraction(interaction) {
    return [
      index_1.ComponentType.StringSelect,
      index_1.ComponentType.UserSelect,
      index_1.ComponentType.RoleSelect,
      index_1.ComponentType.MentionableSelect,
      index_1.ComponentType.ChannelSelect
    ].includes(interaction.data.component_type);
  }
  function isChatInputApplicationCommandInteraction(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
  }
  function isContextMenuApplicationCommandInteraction(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
  }
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = undefined;
  __exportStar(require_v10(), exports);
  __exportStar(require_globals(), exports);
  __exportStar(require_v102(), exports);
  __exportStar(require_v103(), exports);
  __exportStar(require_v104(), exports);
  __exportStar(require_internals(), exports);
  exports.Utils = require_v105();
});

// node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// node_modules/@sapphire/snowflake/dist/cjs/index.cjs
var require_cjs = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
  var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
  var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
  var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
  var MaximumWorkerId = 0b11111n;
  var MaximumProcessId = 0b11111n;
  var MaximumIncrement = 0b111111111111n;
  var _a;
  var _b;
  var _c;
  var _d;
  var _Snowflake = class _Snowflake2 {
    constructor(epoch) {
      __publicField(this, "decode", this.deconstruct);
      __publicField(this, _a);
      __publicField(this, _b, 0n);
      __publicField(this, _c, 1n);
      __publicField(this, _d, 0n);
      this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    get epoch() {
      return this[EpochSymbol];
    }
    get processId() {
      return this[ProcessIdSymbol];
    }
    set processId(value) {
      this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    get workerId() {
      return this[WorkerIdSymbol];
    }
    set workerId(value) {
      this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    generate({
      increment,
      timestamp = Date.now(),
      workerId = this[WorkerIdSymbol],
      processId = this[ProcessIdSymbol]
    } = {}) {
      if (timestamp instanceof Date)
        timestamp = BigInt(timestamp.getTime());
      else if (typeof timestamp === "number")
        timestamp = BigInt(timestamp);
      else if (typeof timestamp !== "bigint") {
        throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
      }
      if (typeof increment !== "bigint") {
        increment = this[IncrementSymbol];
        this[IncrementSymbol] = increment + 1n & MaximumIncrement;
      }
      return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    deconstruct(id) {
      const bigIntId = BigInt(id);
      const epoch = this[EpochSymbol];
      return {
        id: bigIntId,
        timestamp: (bigIntId >> 22n) + epoch,
        workerId: bigIntId >> 17n & MaximumWorkerId,
        processId: bigIntId >> 12n & MaximumProcessId,
        increment: bigIntId & MaximumIncrement,
        epoch
      };
    }
    timestampFrom(id) {
      return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    static compare(a, b) {
      const typeA = typeof a;
      return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
  };
  _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
  __name(_Snowflake, "Snowflake");
  var Snowflake = _Snowflake;
  function cmpBigInt(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  __name(cmpBigInt, "cmpBigInt");
  function cmpString(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
  }
  __name(cmpString, "cmpString");
  var DiscordSnowflake = new Snowflake(1420070400000n);
  var TwitterSnowflake = new Snowflake(1288834974657n);
  exports.DiscordSnowflake = DiscordSnowflake;
  exports.MaximumIncrement = MaximumIncrement;
  exports.MaximumProcessId = MaximumProcessId;
  exports.MaximumWorkerId = MaximumWorkerId;
  exports.Snowflake = Snowflake;
  exports.TwitterSnowflake = TwitterSnowflake;
});

// node_modules/@vladfrangu/async_event_emitter/dist/index.cjs
var require_dist3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    AbortError: () => AbortError,
    AsyncEventEmitter: () => AsyncEventEmitter
  });
  module.exports = __toCommonJS(src_exports);
  function validateListener(input) {
    if (typeof input !== "function") {
      throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
  }
  __name(validateListener, "validateListener");
  function validateAbortSignal(input) {
    if (input && !(input instanceof AbortSignal)) {
      throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
  }
  __name(validateAbortSignal, "validateAbortSignal");
  function spliceOne(list, index) {
    for (;index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }
    list.pop();
  }
  __name(spliceOne, "spliceOne");
  function arrayClone(arr) {
    switch (arr.length) {
      case 2:
        return [arr[0], arr[1]];
      case 3:
        return [arr[0], arr[1], arr[2]];
      case 4:
        return [arr[0], arr[1], arr[2], arr[3]];
      case 5:
        return [arr[0], arr[1], arr[2], arr[3], arr[4]];
      case 6:
        return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
    }
    return arr.slice();
  }
  __name(arrayClone, "arrayClone");
  function identicalSequenceRange(a, b) {
    for (let i = 0;i < a.length - 3; i++) {
      const pos = b.indexOf(a[i]);
      if (pos !== -1) {
        const rest = b.length - pos;
        if (rest > 3) {
          let len = 1;
          const maxLen = Math.min(a.length - i, rest);
          while (maxLen > len && a[i + len] === b[pos + len]) {
            len++;
          }
          if (len > 3) {
            return [len, i];
          }
        }
      }
    }
    return [0, 0];
  }
  __name(identicalSequenceRange, "identicalSequenceRange");
  function enhanceStackTrace(err, own) {
    let ctorInfo = "";
    try {
      const { name } = this.constructor;
      if (name !== "AsyncEventEmitter")
        ctorInfo = ` on ${name} instance`;
    } catch {}
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split(`
`).slice(1);
    const ownStack = own.stack.split(`
`).slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
      ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join(`
`);
  }
  __name(enhanceStackTrace, "enhanceStackTrace");
  var brandSymbol = Symbol.for("async-event-emitter.ts-brand");
  var _AsyncEventEmitter = class _AsyncEventEmitter2 {
    constructor() {
      this._events = {
        __proto__: null
      };
      this._eventCount = 0;
      this._maxListeners = 10;
      this._internalPromiseMap = /* @__PURE__ */ new Map;
      this._wrapperId = 0n;
    }
    addListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    on(eventName, listener) {
      return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    removeListener(eventName, listener) {
      validateListener(listener);
      const events = this._events;
      const eventList = events[eventName];
      if (eventList === undefined) {
        return this;
      }
      if (eventList === listener || eventList.listener === listener) {
        if (--this._eventCount === 0) {
          this._events = { __proto__: null };
        } else {
          delete events[eventName];
          if (events.removeListener) {
            this.emit("removeListener", eventName, eventList.listener ?? eventList);
          }
        }
      } else if (typeof eventList !== "function") {
        let position = -1;
        for (let i = eventList.length - 1;i >= 0; i--) {
          if (eventList[i] === listener || eventList[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          eventList.shift();
        } else {
          spliceOne(eventList, position);
        }
        if (eventList.length === 0) {
          delete events[eventName];
          --this._eventCount;
        }
        if (events.removeListener !== undefined) {
          this.emit("removeListener", eventName, listener);
        }
      }
      return this;
    }
    off(eventName, listener) {
      return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
      const events = this._events;
      if (events.removeListener === undefined) {
        if (!event) {
          this._events = { __proto__: null };
          this._eventCount = 0;
        } else if (events[event] !== undefined) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[event];
          }
        }
        return this;
      }
      if (!event) {
        for (const key of Reflect.ownKeys(events)) {
          if (key === "removeListener") {
            continue;
          }
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = { __proto__: null };
        this._eventCount = 0;
        return this;
      }
      const listeners = events[event];
      if (typeof listeners === "function") {
        this.removeListener(event, listeners);
      } else if (listeners !== undefined) {
        for (let i = listeners.length - 1;i >= 0; i--) {
          this.removeListener(event, listeners[i]);
        }
      }
      return this;
    }
    setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
      }
      this._maxListeners = n;
      return this;
    }
    getMaxListeners() {
      return this._maxListeners;
    }
    listeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList.listener ?? eventList];
      }
      const ret = arrayClone(eventList);
      for (let i = 0;i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    rawListeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList];
      }
      return arrayClone(eventList);
    }
    emit(eventName, ...args) {
      let doError = eventName === "error";
      const events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, _AsyncEventEmitter2.prototype.emit);
            Object.defineProperty(er, "stack", {
              value: enhanceStackTrace.call(this, er, capture),
              configurable: true
            });
          } catch {}
          throw er;
        }
        const stringifiedError = String(er);
        const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
        err.context = er;
        throw err;
      }
      const handlers = events[eventName];
      if (handlers === undefined) {
        return false;
      }
      if (typeof handlers === "function") {
        const result = handlers.apply(this, args);
        if (result !== undefined && result !== null) {
          handleMaybeAsync(this, result);
        }
      } else {
        const len = handlers.length;
        const listeners = arrayClone(handlers);
        for (let i = 0;i < len; ++i) {
          const result = listeners[i].apply(this, args);
          if (result !== undefined && result !== null) {
            handleMaybeAsync(this, result);
          }
        }
      }
      return true;
    }
    listenerCount(eventName) {
      const events = this._events;
      if (events === undefined) {
        return 0;
      }
      const eventListeners = events[eventName];
      if (typeof eventListeners === "function") {
        return 1;
      }
      return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    prependOnceListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    eventNames() {
      return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
      const promises = [...this._internalPromiseMap.values()];
      if (promises.length === 0) {
        return false;
      }
      await Promise.all(promises);
      return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
      if (this._events.newListener !== undefined) {
        this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
      }
      let existing = this._events[eventName];
      if (existing === undefined) {
        existing = this._events[eventName] = wrappedListener;
        ++this._eventCount;
      } else if (typeof existing === "function") {
        existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
      } else if (prepend) {
        existing.unshift(wrappedListener);
      } else {
        existing.push(wrappedListener);
      }
      const existingWarnedAboutMaxListeners = Reflect.get(existing, "_hasWarnedAboutMaxListeners");
      if (this._maxListeners > 0 && existing.length > this._maxListeners && !existingWarnedAboutMaxListeners) {
        Reflect.set(existing, "_hasWarnedAboutMaxListeners", true);
        const warningMessage = [
          `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
          `Use emitter.setMaxListeners() to increase the limit.`
        ].join(" ");
        console.warn(warningMessage);
      }
    }
    _wrapListener(eventName, listener, once) {
      if (!once) {
        return listener;
      }
      const state = {
        fired: false,
        wrapFn: undefined,
        eventEmitter: this,
        eventName,
        listener
      };
      const aliased = onceWrapper;
      const wrapped = aliased.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    static listenerCount(emitter, eventName) {
      return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      return new Promise((resolve, reject) => {
        const errorListener = /* @__PURE__ */ __name((err) => {
          emitter.removeListener(eventName, resolver);
          if (signal) {
            eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = /* @__PURE__ */ __name((...args) => {
          emitter.removeListener("error", errorListener);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        emitter.once(eventName, resolver);
        if (eventName !== "error") {
          emitter.once("error", errorListener);
        }
        const abortListener = /* @__PURE__ */ __name(() => {
          eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(undefined, { cause: getReason(signal) }));
        }, "abortListener");
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
        }
      });
    }
    static on(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error = null;
      let finished = false;
      const abortListener = /* @__PURE__ */ __name(() => {
        errorHandler(new AbortError(undefined, { cause: getReason(signal) }));
      }, "abortListener");
      const eventHandler = /* @__PURE__ */ __name((...args) => {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }, "eventHandler");
      const errorHandler = /* @__PURE__ */ __name((err) => {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }, "errorHandler");
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error) {
            const p = Promise.reject(error);
            error = null;
            return p;
          }
          if (finished) {
            return Promise.resolve(createIterResult(undefined, true));
          }
          return new Promise((resolve, reject) => {
            unconsumedPromises.push({ resolve, reject });
          });
        },
        return() {
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          finished = true;
          const doneResult = createIterResult(undefined, true);
          for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
          }
          return Promise.resolve(doneResult);
        },
        throw(err) {
          if (!err || !(err instanceof Error)) {
            throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
          }
          error = err;
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      }, AsyncIteratorPrototype);
      emitter.on(eventName, eventHandler);
      if (eventName !== "error") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener);
      }
      return iterator;
    }
  };
  __name(_AsyncEventEmitter, "AsyncEventEmitter");
  var AsyncEventEmitter = _AsyncEventEmitter;
  function onceWrapper() {
    if (!this.fired) {
      this.eventEmitter.removeListener(this.eventName, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) {
        return this.listener.call(this.eventEmitter);
      }
      return this.listener.apply(this.eventEmitter, arguments);
    }
  }
  __name(onceWrapper, "onceWrapper");
  function getReason(signal) {
    return signal?.reason;
  }
  __name(getReason, "getReason");
  function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
      emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
      emitter.removeEventListener(name, listener, flags);
    }
  }
  __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags?.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, listener, flags);
    }
  }
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);
  function createIterResult(value, done) {
    return { value, done };
  }
  __name(createIterResult, "createIterResult");
  var _AbortError = class _AbortError2 extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(_AbortError, "AbortError");
  var AbortError = _AbortError;
  function handleMaybeAsync(emitter, result) {
    try {
      const the = result.then;
      const fin = result.finally;
      if (typeof the === "function") {
        the.call(result, undefined, (error) => {
          setTimeout(() => {
            emitter.emit("error", error);
          }, 0);
        });
      }
      if (typeof fin === "function") {
        const promiseId = String(++emitter["_wrapperId"]);
        emitter["_internalPromiseMap"].set(promiseId, result);
        fin.call(result, /* @__PURE__ */ __name(function final() {
          emitter["_internalPromiseMap"].delete(promiseId);
        }, "final"));
      }
    } catch (err) {
      emitter.emit("error", err);
    }
  }
  __name(handleMaybeAsync, "handleMaybeAsync");
});

// node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHex = exports.toHex = undefined;
  var hex = (num) => new Number(num).toString(16).toLowerCase();
  var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
  exports.toHex = toHex;
  var fromHex = (hex2) => new Number(hex2);
  exports.fromHex = fromHex;
});

// node_modules/magic-bytes.js/dist/model/tree.js
var require_tree2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createComplexNode = exports.createNode = exports.merge = undefined;
  var createMatch = (leaf) => ({
    typename: leaf.typename,
    mime: leaf.info.mime,
    extension: leaf.info.extension
  });
  var isLeafNode = (tree, path) => tree && path.length === 0;
  var merge = (node, tree) => {
    if (node.bytes.length === 0)
      return tree;
    const [currentByte, ...path] = node.bytes;
    const currentTree = tree.bytes[currentByte];
    if (isLeafNode(currentTree, path)) {
      const matchingNode = tree.bytes[currentByte];
      tree.bytes[currentByte] = {
        ...matchingNode,
        matches: [
          ...matchingNode.matches ?? [],
          createMatch(node)
        ]
      };
      return tree;
    }
    if (tree.bytes[currentByte]) {
      tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
    } else {
      tree.bytes[currentByte] = exports.createComplexNode(node.typename, path, node.info);
    }
    return tree;
  };
  exports.merge = merge;
  var createNode = (typename, bytes, info) => {
    return { typename, bytes, info: info ? info : {} };
  };
  exports.createNode = createNode;
  var createComplexNode = (typename, bytes, info) => {
    let obj = {
      bytes: {},
      matches: undefined
    };
    const [currentKey, ...path] = bytes;
    if (bytes.length === 0) {
      return {
        matches: [
          createMatch({
            typename,
            info: info ? { extension: info.extension, mime: info.mime } : {}
          })
        ],
        bytes: {}
      };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
  };
  exports.createComplexNode = createComplexNode;
});

// node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTree = exports.add = undefined;
  var toHex_1 = require_toHex();
  var tree_1 = require_tree2();
  var tree = {
    noOffset: null,
    offset: {}
  };
  var add = (typename, signature, additionalInfo, offset) => {
    if (offset) {
      const existing = tree.offset[toHex_1.toHex(offset)];
      if (!existing) {
        tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
        tree.offset[toHex_1.toHex(offset)] = merged;
      }
    } else {
      if (tree.noOffset === null) {
        tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
      }
    }
  };
  exports.add = add;
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("jpg", ["0xFF", "0xD8", "0xFF"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  exports.add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
  ], { mime: "image/webp", extension: "webp" });
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
  exports.add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
  exports.add("bin", ["0x53", "0x50", "0x30", "0x31"], {
    mime: "application/octet-stream",
    extension: "bin"
  });
  exports.add("pic", ["0x00"]);
  exports.add("pif", ["0x00"]);
  exports.add("sea", ["0x00"]);
  exports.add("ytr", ["0x00"]);
  exports.add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
  exports.add("ttf", ["0x00", "0x01", "0x00", "0x00", "0x00"], {
    mime: "font/ttf",
    extension: "ttf"
  });
  exports.add("otf", ["0x4F", "0x54", "0x54", "0x4F"], {
    mime: "font/otf",
    extension: "otf"
  });
  exports.add("eot", ["0x50", "0x4C"], {
    mime: "application/vnd.ms-fontobject",
    extension: "eot"
  });
  exports.add("woff", ["0x77", "0x4F", "0x46", "0x46"], {
    mime: "font/woff",
    extension: "woff"
  });
  exports.add("woff2", ["0x77", "0x4F", "0x46", "0x32"], {
    mime: "font/woff2",
    extension: "woff2"
  });
  exports.add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]);
  exports.add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
  exports.add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
  exports.add("tda", ["0x00", "0x01", "0x44", "0x54"]);
  exports.add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
  exports.add("ico", ["0x00", "0x00", "0x01", "0x00"], {
    mime: "image/x-icon",
    extension: "ico"
  });
  exports.add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
  exports.add("z", ["0x1F", "0x9D"]);
  exports.add("tar.z", ["0x1F", "0xA0"]);
  exports.add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
  ]);
  exports.add("bz2", ["0x42", "0x5A", "0x68"], {
    mime: "application/x-bzip2",
    extension: "bz2"
  });
  exports.add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
    mime: "image/tiff",
    extension: "tif"
  });
  exports.add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
    mime: "image/tiff",
    extension: "tiff"
  });
  exports.add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
  ]);
  exports.add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
  exports.add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
  exports.add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
  exports.add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
  exports.add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
  exports.add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
  exports.add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
  exports.add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
  ]);
  exports.add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
  ]);
  exports.add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
  ]);
  exports.add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
  ]);
  exports.add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
  ]);
  exports.add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
  ]);
  exports.add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
  ]);
  exports.add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
  ]);
  exports.add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
  ]);
  exports.add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
  ], { mime: "audio/x-aiff", extension: "aiff" });
  exports.add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
  exports.add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
  exports.add("exe", ["0x4D", "0x5A"]);
  exports.add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("apk", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("aar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/png",
    extension: "png"
  });
  exports.add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/apng",
    extension: "apng"
  });
  exports.add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
  exports.add("class", ["0xEF", "0xBB", "0xBF"]);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCE"], undefined, 4096);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCF"], undefined, 4096);
  exports.add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
  exports.add("ps", ["0x25", "0x21", "0x50", "0x53"], {
    mime: "application/postscript",
    extension: ".ps"
  });
  exports.add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
    mime: "application/pdf",
    extension: "pdf"
  });
  exports.add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
  ]);
  exports.add("ogv", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x80",
    "0x74",
    "0x68",
    "0x65",
    "0x6F",
    "0x72",
    "0x61"
  ], {
    mime: "video/ogg",
    extension: "ogv"
  });
  exports.add("ogm", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x69",
    "0x64",
    "0x65",
    "0x6F",
    "0x00"
  ], {
    mime: "video/ogg",
    extension: "ogm"
  });
  exports.add("oga", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x7F",
    "0x46",
    "0x4C",
    "0x41",
    "0x43"
  ], {
    mime: "audio/ogg",
    extension: "oga"
  });
  exports.add("spx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x70",
    "0x65",
    "0x65",
    "0x78",
    "0x20",
    "0x20"
  ], {
    mime: "audio/ogg",
    extension: "spx"
  });
  exports.add("ogg", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x6F",
    "0x72",
    "0x62",
    "0x69",
    "0x73"
  ], {
    mime: "audio/ogg",
    extension: "ogg"
  });
  exports.add("ogx", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "application/ogg",
    extension: "ogx"
  });
  exports.add("psd", ["0x38", "0x42", "0x50", "0x53"], {
    mime: "application/x-photoshop",
    extension: "psd"
  });
  exports.add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
  exports.add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
  ], { mime: "audio/x-wav", extension: "wav" });
  exports.add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
  ], { mime: "video/x-msvideo", extension: "avi" });
  exports.add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
  exports.add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
  exports.add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
  exports.add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "mid"
  });
  exports.add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "midi"
  });
  exports.add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/msword",
    extension: "doc"
  });
  exports.add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
  });
  exports.add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
  });
  exports.add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
  exports.add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
  exports.add("vmdk", ["0x4B", "0x44", "0x4D"]);
  exports.add("crx", ["0x43", "0x72", "0x32", "0x34"]);
  exports.add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
  exports.add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
  exports.add("xar", ["0x78", "0x61", "0x72", "0x21"]);
  exports.add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
  exports.add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
  exports.add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
  exports.add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
  ]);
  exports.add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
    mime: "application/x-7z-compressed",
    extension: "7z"
  });
  exports.add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
  exports.add("tar.gz", ["0x1F", "0x8B"], {
    mime: "application/gzip",
    extension: "tar.gz"
  });
  exports.add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "xz"
  });
  exports.add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "tar.xz"
  });
  exports.add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
  exports.add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
  exports.add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mkv"
  });
  exports.add("mka", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/x-matroska",
    extension: "mka"
  });
  exports.add("mks", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mks"
  });
  exports.add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
  exports.add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/webm",
    extension: "webm"
  });
  exports.add("dcm", ["0x44", "0x49", "0x43", "0x4D"], undefined, 128);
  exports.add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
    mime: "application/xml",
    extension: "xml"
  });
  exports.add("wasm", ["0x00", "0x61", "0x73", "0x6d"], {
    mime: "application/wasm",
    extension: "wasm"
  });
  exports.add("lep", ["0xCF", "0x84", "0x01"]);
  exports.add("swf", ["0x43", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("swf", ["0x46", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
  exports.add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
    mime: "application/rtf",
    extension: "rtf"
  });
  exports.add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpg"
  });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mov", ["0x66", "0x72", "0x65", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x64", "0x61", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x6F", "0x6F", "0x76"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x77", "0x69", "0x64", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x66", "0x74", "0x79", "0x70", "0x71", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("hl2demo", ["0x48", "0x4C", "0x32", "0x44", "0x45", "0x4D", "0x4F"]);
  exports.add("txt", ["0xEF", "0xBB", "0xBF"], {
    mime: "text/plain; charset=UTF-8",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE"], {
    mime: "text/plain; charset=UTF-16LE",
    extension: "txt"
  });
  exports.add("txt", ["0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-16BE",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE", "0x00", "0x00"], {
    mime: "text/plain; charset=UTF-32LE",
    extension: "txt"
  });
  exports.add("txt", ["0x00", "0x00", "0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-32BE",
    extension: "txt"
  });
  exports.add("SubRip", ["0x31", "0x0D", "0x0A", "0x30", "0x30", "0x3A"], {
    mime: "application/x-subrip",
    extension: "srt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0A"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0D"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x20"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x09"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("Json", ["0x7B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("Json", ["0x5B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("ELF", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/x-executable",
    extension: ".elf"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xC"], {
    mime: "application/x-mach-binary",
    extension: ".o"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xCF"], {
    mime: "application/x-executable",
    extension: "elf"
  });
  exports.add("EML", ["0x52", "0x65", "0x63", "0x65", "0x69", "0x76", "0x65", "0x64", "0x3A"], {
    mime: "message/rfc822",
    extension: ".eml"
  });
  exports.add("SVG", ["0x3c", "0x73", "0x76", "0x67"], {
    mime: "image/svg+xml",
    extension: "svg"
  });
  exports.add("avif", ["0x66", "0x74", "0x79", "0x70", "0x61", "0x76", "0x69", "0x66"], {
    mime: "image/avif",
    extension: "avif"
  }, 4);
  var createTree = () => tree;
  exports.createTree = createTree;
  exports.default = () => tree;
});

// node_modules/magic-bytes.js/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.register = exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = undefined;
  var pattern_tree_1 = require_pattern_tree();
  var toHex_1 = require_toHex();
  var patternTree = pattern_tree_1.createTree();
  var filetypeinfo = (bytes) => {
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)) {
      const offset = toHex_1.fromHex(k);
      const offsetExceedsFile = offset >= bytes.length;
      if (offsetExceedsFile) {
        continue;
      }
      const node = patternTree.offset[k];
      const guessed = walkTree(offset, bytes, node);
      if (guessed.length > 0) {
        return guessed;
      }
    }
    if (tree.noOffset === null) {
      return [];
    }
    return walkTree(0, bytes, tree.noOffset);
  };
  exports.filetypeinfo = filetypeinfo;
  var walkTree = (index, bytes, node) => {
    let step = node;
    let guessFile = [];
    while (true) {
      const currentByte = toHex_1.toHex(bytes[index]);
      if (step.bytes["?"] && !step.bytes[currentByte]) {
        step = step.bytes["?"];
      } else {
        step = step.bytes[currentByte];
      }
      if (!step) {
        return guessFile;
      }
      if (step && step.matches) {
        guessFile = step.matches.slice(0);
      }
      index += 1;
    }
  };
  exports.default = exports.filetypeinfo;
  var filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);
  exports.filetypename = filetypename;
  var filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => e.mime ? e.mime : null).filter((x) => x !== null);
  exports.filetypemime = filetypemime;
  var filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => e.extension ? e.extension : null).filter((x) => x !== null);
  exports.filetypeextension = filetypeextension;
  var register = (typename, signature, additionalInfo, offset) => {
    pattern_tree_1.add(typename, signature, additionalInfo, offset);
  };
  exports.register = register;
});

// node_modules/@sapphire/async-queue/dist/cjs/index.cjs
var require_cjs2 = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var _AsyncQueueEntry = class _AsyncQueueEntry2 {
    constructor(queue) {
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      __publicField(this, "queue");
      __publicField(this, "signal", null);
      __publicField(this, "signalListener", null);
      this.queue = queue;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    setSignal(signal) {
      if (signal.aborted)
        return this;
      this.signal = signal;
      this.signalListener = () => {
        const index = this.queue["promises"].indexOf(this);
        if (index !== -1)
          this.queue["promises"].splice(index, 1);
        this.reject(new Error("Request aborted manually"));
      };
      this.signal.addEventListener("abort", this.signalListener);
      return this;
    }
    use() {
      this.dispose();
      this.resolve();
      return this;
    }
    abort() {
      this.dispose();
      this.reject(new Error("Request aborted manually"));
      return this;
    }
    dispose() {
      if (this.signal) {
        this.signal.removeEventListener("abort", this.signalListener);
        this.signal = null;
        this.signalListener = null;
      }
    }
  };
  __name(_AsyncQueueEntry, "AsyncQueueEntry");
  var AsyncQueueEntry = _AsyncQueueEntry;
  var _AsyncQueue = class _AsyncQueue2 {
    constructor() {
      __publicField(this, "promises", []);
    }
    get remaining() {
      return this.promises.length;
    }
    get queued() {
      return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    wait(options) {
      const entry = new AsyncQueueEntry(this);
      if (this.promises.length === 0) {
        this.promises.push(entry);
        return Promise.resolve();
      }
      this.promises.push(entry);
      if (options?.signal)
        entry.setSignal(options.signal);
      return entry.promise;
    }
    shift() {
      if (this.promises.length === 0)
        return;
      if (this.promises.length === 1) {
        this.promises.shift();
        return;
      }
      this.promises.shift();
      this.promises[0].use();
    }
    abortAll() {
      if (this.queued === 0)
        return;
      for (let i = 1;i < this.promises.length; ++i) {
        this.promises[i].abort();
      }
      this.promises.length = 1;
    }
  };
  __name(_AsyncQueue, "AsyncQueue");
  var AsyncQueue = _AsyncQueue;
  exports.AsyncQueue = AsyncQueue;
});

// node_modules/@discordjs/rest/dist/index.js
var require_dist5 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
    ALLOWED_SIZES: () => ALLOWED_SIZES,
    ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
    BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
    CDN: () => CDN,
    DEPRECATION_WARNING_PREFIX: () => DEPRECATION_WARNING_PREFIX,
    DefaultRestOptions: () => DefaultRestOptions,
    DefaultUserAgent: () => DefaultUserAgent,
    DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
    DiscordAPIError: () => DiscordAPIError,
    HTTPError: () => HTTPError,
    OverwrittenMimeTypes: () => OverwrittenMimeTypes,
    REST: () => REST,
    RESTEvents: () => RESTEvents,
    RateLimitError: () => RateLimitError,
    RequestMethod: () => RequestMethod,
    calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
    makeURLSearchParams: () => makeURLSearchParams,
    parseResponse: () => parseResponse,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var import_node_buffer = __require("buffer");
  var import_util2 = require_dist();
  var import_undici2 = require_undici();
  var defaultStrategy;
  function setDefaultStrategy(newStrategy) {
    defaultStrategy = newStrategy;
  }
  __name(setDefaultStrategy, "setDefaultStrategy");
  function getDefaultStrategy() {
    return defaultStrategy;
  }
  __name(getDefaultStrategy, "getDefaultStrategy");
  var import_node_http = __require("http");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_undici = require_undici();
  async function makeRequest(url, init) {
    const options = {
      ...init,
      body: await resolveBody(init.body)
    };
    const res = await (0, import_undici.request)(url, options);
    return {
      body: res.body,
      async arrayBuffer() {
        return res.body.arrayBuffer();
      },
      async json() {
        return res.body.json();
      },
      async text() {
        return res.body.text();
      },
      get bodyUsed() {
        return res.body.bodyUsed;
      },
      headers: new import_undici.Headers(res.headers),
      status: res.statusCode,
      statusText: import_node_http.STATUS_CODES[res.statusCode],
      ok: res.statusCode >= 200 && res.statusCode < 300
    };
  }
  __name(makeRequest, "makeRequest");
  async function resolveBody(body) {
    if (body == null) {
      return null;
    } else if (typeof body === "string") {
      return body;
    } else if (import_node_util.types.isUint8Array(body)) {
      return body;
    } else if (import_node_util.types.isArrayBuffer(body)) {
      return new Uint8Array(body);
    } else if (body instanceof import_node_url.URLSearchParams) {
      return body.toString();
    } else if (body instanceof DataView) {
      return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
      return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
      return body;
    } else if (body[Symbol.iterator]) {
      const chunks = [...body];
      return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
      const chunks = [];
      for await (const chunk of body) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
  }
  __name(resolveBody, "resolveBody");
  var import_v102 = require_v106();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.5.1)`;
  var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
  var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15000,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: import_v10.APIVersion,
    hashSweepInterval: 14400000,
    hashLifetime: 86400000,
    handlerSweepInterval: 3600000,
    async makeRequest(...args) {
      return getDefaultStrategy()(...args);
    },
    mediaProxy: "https://media.discordapp.net"
  };
  var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
  })(RESTEvents || {});
  var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
  var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
  var ALLOWED_SIZES = [
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096
  ];
  var OverwrittenMimeTypes = {
    "image/apng": "image/png"
  };
  var BurstHandlerMajorIdKey = "burst";
  var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
  var RateLimitError = class _RateLimitError extends Error {
    static {
      __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    retryAfter;
    sublimitTimeout;
    scope;
    constructor({
      timeToReset,
      limit,
      method,
      hash,
      url,
      route,
      majorParameter,
      global: global2,
      retryAfter,
      sublimitTimeout,
      scope
    }) {
      super();
      this.timeToReset = timeToReset;
      this.limit = limit;
      this.method = method;
      this.hash = hash;
      this.url = url;
      this.route = route;
      this.majorParameter = majorParameter;
      this.global = global2;
      this.retryAfter = retryAfter;
      this.sublimitTimeout = sublimitTimeout;
      this.scope = scope;
    }
    get name() {
      return `${_RateLimitError.name}[${this.route}]`;
    }
  };
  var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
  })(RequestMethod || {});
  function serializeSearchParam(value) {
    switch (typeof value) {
      case "string":
        return value;
      case "number":
      case "bigint":
      case "boolean":
        return value.toString();
      case "object":
        if (value === null)
          return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }
        if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
          return value.toString();
        return null;
      default:
        return null;
    }
  }
  __name(serializeSearchParam, "serializeSearchParam");
  function makeURLSearchParams(options) {
    const params = new URLSearchParams;
    if (!options)
      return params;
    for (const [key, value] of Object.entries(options)) {
      const serialized = serializeSearchParam(value);
      if (serialized !== null)
        params.append(key, serialized);
    }
    return params;
  }
  __name(makeURLSearchParams, "makeURLSearchParams");
  async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
      return res.json();
    }
    return res.arrayBuffer();
  }
  __name(parseResponse, "parseResponse");
  function hasSublimit(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
      if (typeof body !== "object" || body === null)
        return false;
      if (method !== "PATCH")
        return false;
      const castedBody = body;
      return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
    }
    return true;
  }
  __name(hasSublimit, "hasSublimit");
  function shouldRetry(error) {
    if (error.name === "AbortError")
      return true;
    return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
  }
  __name(shouldRetry, "shouldRetry");
  async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit)
      return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
      throw new RateLimitError(rateLimitData);
    }
  }
  __name(onRateLimit, "onRateLimit");
  function calculateUserDefaultAvatarIndex(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
  }
  __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
  async function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), ms);
    });
  }
  __name(sleep, "sleep");
  function isBufferLike(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
  }
  __name(isBufferLike, "isBufferLike");
  function deprecationWarning(message) {
    if (typeof globalThis.process === "undefined") {
      console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
    } else {
      process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
    }
  }
  __name(deprecationWarning, "deprecationWarning");
  function normalizeRateLimitOffset(offset, route) {
    if (typeof offset === "number") {
      return Math.max(0, offset);
    }
    const result = offset(route);
    return Math.max(0, result);
  }
  __name(normalizeRateLimitOffset, "normalizeRateLimitOffset");
  var deprecationEmittedForEmoji = false;
  var CDN = class {
    constructor(cdn = DefaultRestOptions.cdn, mediaProxy = DefaultRestOptions.mediaProxy) {
      this.cdn = cdn;
      this.mediaProxy = mediaProxy;
    }
    static {
      __name(this, "CDN");
    }
    appAsset(clientId, assetHash, options) {
      return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    appIcon(clientId, iconHash, options) {
      return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    avatar(id, avatarHash, options) {
      return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userIdOrAsset, userAvatarDecoration, options) {
      if (userAvatarDecoration) {
        return this.makeURL(`/avatar-decorations/${userIdOrAsset}/${userAvatarDecoration}`, options);
      }
      return this.makeURL(`/avatar-decoration-presets/${userIdOrAsset}`, { extension: "png" });
    }
    banner(id, bannerHash, options) {
      return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    channelIcon(channelId, iconHash, options) {
      return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    defaultAvatar(index) {
      return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
    }
    discoverySplash(guildId, splashHash, options) {
      return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, options) {
      let resolvedOptions;
      if (typeof options === "string") {
        if (!deprecationEmittedForEmoji) {
          deprecationWarning("Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead.");
          deprecationEmittedForEmoji = true;
        }
        resolvedOptions = { extension: options };
      } else {
        resolvedOptions = options;
      }
      return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
    }
    guildMemberAvatar(guildId, userId, avatarHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    guildMemberBanner(guildId, userId, bannerHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banners/${bannerHash}`, bannerHash, options);
    }
    icon(id, iconHash, options) {
      return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    roleIcon(roleId, roleIconHash, options) {
      return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    splash(guildId, splashHash, options) {
      return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    sticker(stickerId, extension = "png") {
      return this.makeURL(`/stickers/${stickerId}`, {
        allowedExtensions: ALLOWED_STICKER_EXTENSIONS,
        base: extension === "gif" ? this.mediaProxy : this.cdn,
        extension
      });
    }
    stickerPackBanner(bannerId, options) {
      return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    teamIcon(teamId, iconHash, options) {
      return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    guildScheduledEventCover(scheduledEventId, coverHash, options) {
      return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    soundboardSound(soundId) {
      return `${this.cdn}${import_v102.CDNRoutes.soundboardSound(soundId)}`;
    }
    dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
      return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
    }
    makeURL(route, {
      allowedExtensions = ALLOWED_EXTENSIONS,
      base = this.cdn,
      extension = "webp",
      size
    } = {}) {
      extension = String(extension).toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
      }
      if (size && !ALLOWED_SIZES.includes(size)) {
        throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
      }
      const url = new URL(`${base}${route}.${extension}`);
      if (size) {
        url.searchParams.set("size", String(size));
      }
      return url.toString();
    }
  };
  function isErrorGroupWrapper(error) {
    return Reflect.has(error, "_errors");
  }
  __name(isErrorGroupWrapper, "isErrorGroupWrapper");
  function isErrorResponse(error) {
    return typeof Reflect.get(error, "message") === "string";
  }
  __name(isErrorResponse, "isErrorResponse");
  var DiscordAPIError = class _DiscordAPIError extends Error {
    constructor(rawError, code, status, method, url, bodyData) {
      super(_DiscordAPIError.getMessage(rawError));
      this.rawError = rawError;
      this.code = code;
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "DiscordAPIError");
    }
    requestBody;
    get name() {
      return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
      let flattened = "";
      if ("code" in error) {
        if (error.errors) {
          flattened = [...this.flattenDiscordError(error.errors)].join(`
`);
        }
        return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
      }
      return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
      if (isErrorResponse(obj)) {
        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
      }
      for (const [otherKey, val] of Object.entries(obj)) {
        const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
        if (typeof val === "string") {
          yield val;
        } else if (isErrorGroupWrapper(val)) {
          for (const error of val._errors) {
            yield* this.flattenDiscordError(error, nextKey);
          }
        } else {
          yield* this.flattenDiscordError(val, nextKey);
        }
      }
    }
  };
  var HTTPError = class _HTTPError extends Error {
    constructor(status, statusText, method, url, bodyData) {
      super(statusText);
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
  };
  var import_collection = require_dist2();
  var import_snowflake = require_cjs();
  var import_async_event_emitter = require_dist3();
  var import_magic_bytes = require_dist4();
  var invalidCount = 0;
  var invalidCountResetTime = null;
  function incrementInvalidCount(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
      invalidCountResetTime = Date.now() + 1000 * 60 * 10;
      invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
      manager.emit("invalidRequestWarning", {
        count: invalidCount,
        remainingTime: invalidCountResetTime - Date.now()
      });
    }
  }
  __name(incrementInvalidCount, "incrementInvalidCount");
  async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController;
    const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
    if (requestData.signal) {
      if (requestData.signal.aborted)
        controller.abort();
      else
        requestData.signal.addEventListener("abort", () => controller.abort());
    }
    let res;
    try {
      res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
    } catch (error) {
      if (!(error instanceof Error))
        throw error;
      if (shouldRetry(error) && retries !== manager.options.retries) {
        return null;
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
    if (manager.listenerCount("response")) {
      manager.emit("response", {
        method: options.method ?? "get",
        path: routeId.original,
        route: routeId.bucketRoute,
        options,
        data: requestData,
        retries
      }, res instanceof Response ? res.clone() : { ...res });
    }
    return res;
  }
  __name(makeNetworkRequest, "makeNetworkRequest");
  async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
      if (retries !== manager.options.retries) {
        return null;
      }
      throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
      if (status >= 400 && status < 500) {
        if (status === 401 && requestData.auth) {
          manager.setToken(null);
        }
        const data = await parseResponse(res);
        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
      }
      return res;
    }
  }
  __name(handleErrors, "handleErrors");
  var BurstHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "BurstHandler");
    }
    id;
    inactive = false;
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async queueRequest(routeId, url, options, requestData) {
      return this.runRequest(routeId, url, options, requestData);
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const retry = res.headers.get("Retry-After");
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (status >= 200 && status < 300) {
        return res;
      } else if (status === 429) {
        const isGlobal = res.headers.has("X-RateLimit-Global");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: Number.POSITIVE_INFINITY,
          timeToReset: retryAfter,
          retryAfter,
          sublimitTimeout: 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${Number.POSITIVE_INFINITY}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : None`,
          `  Scope          : ${scope}`
        ].join(`
`));
        await sleep(retryAfter);
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var import_async_queue = require_cjs2();
  var SequentialHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "SequentialHandler");
    }
    id;
    reset = -1;
    remaining = 1;
    limit = Number.POSITIVE_INFINITY;
    #asyncQueue = new import_async_queue.AsyncQueue;
    #sublimitedQueue = null;
    #sublimitPromise = null;
    #shiftSublimit = false;
    get inactive() {
      return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    get globalLimited() {
      return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    get localLimited() {
      return this.remaining <= 0 && Date.now() < this.reset;
    }
    get limited() {
      return this.globalLimited || this.localLimited;
    }
    getTimeToReset(routeId) {
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      return this.reset + offset - Date.now();
    }
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async globalDelayFor(time) {
      await sleep(time);
      this.manager.globalDelay = null;
    }
    async queueRequest(routeId, url, options, requestData) {
      let queue = this.#asyncQueue;
      let queueType = 0;
      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
        queue = this.#sublimitedQueue;
        queueType = 1;
      }
      await queue.wait({ signal: requestData.signal });
      if (queueType === 0) {
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          const wait = queue.wait();
          this.#asyncQueue.shift();
          await wait;
        } else if (this.#sublimitPromise) {
          await this.#sublimitPromise.promise;
        }
      }
      try {
        return await this.runRequest(routeId, url, options, requestData);
      } finally {
        queue.shift();
        if (this.#shiftSublimit) {
          this.#shiftSublimit = false;
          this.#sublimitedQueue?.shift();
        }
        if (this.#sublimitedQueue?.remaining === 0) {
          this.#sublimitPromise?.resolve();
          this.#sublimitedQueue = null;
        }
      }
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      while (this.limited) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        let delay;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
          if (!this.manager.globalDelay) {
            this.manager.globalDelay = this.globalDelayFor(timeout);
          }
          delay = this.manager.globalDelay;
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
          delay = sleep(timeout);
        }
        const rateLimitData = {
          global: isGlobal,
          method: options.method ?? "get",
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter: timeout,
          sublimitTimeout: 0,
          scope: "user"
        };
        this.manager.emit("rateLimited", rateLimitData);
        await onRateLimit(this.manager, rateLimitData);
        if (isGlobal) {
          this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
        } else {
          this.debug(`Waiting ${timeout}ms for rate limit to pass`);
        }
        await delay;
      }
      if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
        this.manager.globalReset = Date.now() + 1000;
        this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
      }
      this.manager.globalRemaining--;
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const limit = res.headers.get("X-RateLimit-Limit");
      const remaining = res.headers.get("X-RateLimit-Remaining");
      const reset = res.headers.get("X-RateLimit-Reset-After");
      const hash = res.headers.get("X-RateLimit-Bucket");
      const retry = res.headers.get("Retry-After");
      const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? Number(reset) * 1000 + Date.now() + offset : Date.now();
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (hash && hash !== this.hash) {
        this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join(`
`));
        this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
      } else if (hash) {
        const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
        if (hashData) {
          hashData.lastAccess = Date.now();
        }
      }
      let sublimitTimeout = null;
      if (retryAfter > 0) {
        if (res.headers.has("X-RateLimit-Global")) {
          this.manager.globalRemaining = 0;
          this.manager.globalReset = Date.now() + retryAfter;
        } else if (!this.localLimited) {
          sublimitTimeout = retryAfter;
        }
      }
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (res.ok) {
        return res;
      } else if (status === 429) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
        }
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter,
          sublimitTimeout: sublimitTimeout ?? 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal.toString()}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${limit2}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
          `  Scope          : ${scope}`
        ].join(`
`));
        if (sublimitTimeout) {
          const firstSublimit = !this.#sublimitedQueue;
          if (firstSublimit) {
            this.#sublimitedQueue = new import_async_queue.AsyncQueue;
            this.#sublimitedQueue.wait();
            this.#asyncQueue.shift();
          }
          this.#sublimitPromise?.resolve();
          this.#sublimitPromise = null;
          await sleep(sublimitTimeout);
          let resolve;
          const promise = new Promise((res2) => resolve = res2);
          this.#sublimitPromise = { promise, resolve };
          if (firstSublimit) {
            await this.#asyncQueue.wait();
            this.#shiftSublimit = true;
          }
        }
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "REST");
    }
    agent = null;
    cdn;
    globalRemaining;
    globalDelay = null;
    globalReset = -1;
    hashes = new import_collection.Collection;
    handlers = new import_collection.Collection;
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}) {
      super();
      this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn, options.mediaProxy ?? DefaultRestOptions.mediaProxy);
      this.options = { ...DefaultRestOptions, ...options };
      this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
      this.agent = options.agent ?? null;
      this.setupSweepers();
    }
    setupSweepers() {
      const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
        if (interval > 14400000) {
          throw new Error("Cannot set an interval greater than 4 hours");
        }
      }, "validateMaxInterval");
      if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.hashSweepInterval);
        this.hashTimer = setInterval(() => {
          const sweptHashes = new import_collection.Collection;
          const currentDate = Date.now();
          this.hashes.sweep((val, key) => {
            if (val.lastAccess === -1)
              return false;
            const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
            if (shouldSweep) {
              sweptHashes.set(key, val);
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
            }
            return shouldSweep;
          });
          this.emit("hashSweep", sweptHashes);
        }, this.options.hashSweepInterval);
        this.hashTimer.unref?.();
      }
      if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.handlerSweepInterval);
        this.handlerTimer = setInterval(() => {
          const sweptHandlers = new import_collection.Collection;
          this.handlers.sweep((val, key) => {
            const { inactive } = val;
            if (inactive) {
              sweptHandlers.set(key, val);
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
            }
            return inactive;
          });
          this.emit("handlerSweep", sweptHandlers);
        }, this.options.handlerSweepInterval);
        this.handlerTimer.unref?.();
      }
    }
    async get(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "GET" });
    }
    async delete(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "DELETE" });
    }
    async post(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "POST" });
    }
    async put(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PUT" });
    }
    async patch(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PATCH" });
    }
    async request(options) {
      const response = await this.queueRequest(options);
      return parseResponse(response);
    }
    setAgent(agent) {
      this.agent = agent;
      return this;
    }
    setToken(token) {
      this.#token = token;
      return this;
    }
    async queueRequest(request2) {
      const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
      const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
        value: `Global(${request2.method}:${routeId.bucketRoute})`,
        lastAccess: -1
      };
      const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
      const { url, fetchOptions } = await this.resolveRequest(request2);
      return handler.queueRequest(routeId, url, fetchOptions, {
        body: request2.body,
        files: request2.files,
        auth: request2.auth !== false,
        signal: request2.signal
      });
    }
    createHandler(hash, majorParameter) {
      const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
      this.handlers.set(queue.id, queue);
      return queue;
    }
    async resolveRequest(request2) {
      const { options } = this;
      let query = "";
      if (request2.query) {
        const resolvedQuery = request2.query.toString();
        if (resolvedQuery !== "") {
          query = `?${resolvedQuery}`;
        }
      }
      const headers = {
        ...this.options.headers,
        "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
      };
      if (request2.auth !== false) {
        if (!this.#token) {
          throw new Error("Expected token to be set for this request, but none was present");
        }
        headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
      }
      if (request2.reason?.length) {
        headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
      }
      const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
      let finalBody;
      let additionalHeaders = {};
      if (request2.files?.length) {
        const formData = new FormData;
        for (const [index, file] of request2.files.entries()) {
          const fileKey = file.key ?? `files[${index}]`;
          if (isBufferLike(file.data)) {
            let contentType = file.contentType;
            if (!contentType) {
              const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
              if (parsedType) {
                contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
              }
            }
            formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
          } else {
            formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
          }
        }
        if (request2.body != null) {
          if (request2.appendToFormData) {
            for (const [key, value] of Object.entries(request2.body)) {
              formData.append(key, value);
            }
          } else {
            formData.append("payload_json", JSON.stringify(request2.body));
          }
        }
        finalBody = formData;
      } else if (request2.body != null) {
        if (request2.passThroughBody) {
          finalBody = request2.body;
        } else {
          finalBody = JSON.stringify(request2.body);
          additionalHeaders = { "Content-Type": "application/json" };
        }
      }
      const method = request2.method.toUpperCase();
      const fetchOptions = {
        body: ["GET", "HEAD"].includes(method) ? null : finalBody,
        headers: { ...request2.headers, ...additionalHeaders, ...headers },
        method,
        dispatcher: request2.dispatcher ?? this.agent ?? undefined
      };
      return { url, fetchOptions };
    }
    clearHashSweeper() {
      clearInterval(this.hashTimer);
    }
    clearHandlerSweeper() {
      clearInterval(this.handlerTimer);
    }
    static generateRouteData(endpoint, method) {
      if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
        return {
          majorParameter: BurstHandlerMajorIdKey,
          bucketRoute: "/interactions/:id/:token/callback",
          original: endpoint
        };
      }
      const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(endpoint);
      const majorId = majorIdMatch?.[2] ?? majorIdMatch?.[1] ?? "global";
      const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
      let exceptions = "";
      if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
        const id = /\d{17,19}$/.exec(endpoint)[0];
        const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
        if (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {
          exceptions += "/Delete Old Message";
        }
      }
      return {
        majorParameter: majorId,
        bucketRoute: baseRoute + exceptions,
        original: endpoint
      };
    }
  };
  var version = "2.5.1";
  globalThis.FormData ??= import_undici2.FormData;
  globalThis.Blob ??= import_node_buffer.Blob;
  setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS((exports, module) => {
  var keys = [
    "ClientInvalidOption",
    "ClientInvalidProvidedShards",
    "ClientMissingIntents",
    "ClientNotReady",
    "TokenInvalid",
    "TokenMissing",
    "ApplicationCommandPermissionsTokenMissing",
    "WSCloseRequested",
    "WSConnectionExists",
    "WSNotOpen",
    "ManagerDestroyed",
    "BitFieldInvalid",
    "ShardingInvalid",
    "ShardingRequired",
    "InvalidIntents",
    "DisallowedIntents",
    "ShardingNoShards",
    "ShardingInProcess",
    "ShardingInvalidEvalBroadcast",
    "ShardingShardNotFound",
    "ShardingAlreadySpawned",
    "ShardingProcessExists",
    "ShardingWorkerExists",
    "ShardingReadyTimeout",
    "ShardingReadyDisconnected",
    "ShardingReadyDied",
    "ShardingNoChildExists",
    "ShardingShardMiscalculation",
    "ColorRange",
    "ColorConvert",
    "InviteOptionsMissingChannel",
    "ButtonLabel",
    "ButtonURL",
    "ButtonCustomId",
    "SelectMenuCustomId",
    "SelectMenuPlaceholder",
    "SelectOptionLabel",
    "SelectOptionValue",
    "SelectOptionDescription",
    "InteractionCollectorError",
    "FileNotFound",
    "UserBannerNotFetched",
    "UserNoDMChannel",
    "VoiceNotStageChannel",
    "VoiceStateNotOwn",
    "VoiceStateInvalidType",
    "ReqResourceType",
    "ImageFormat",
    "ImageSize",
    "MessageBulkDeleteType",
    "MessageContentType",
    "MessageNonceRequired",
    "MessageNonceType",
    "SplitMaxLen",
    "BanResolveId",
    "FetchBanResolveId",
    "PruneDaysType",
    "GuildChannelResolve",
    "GuildVoiceChannelResolve",
    "GuildChannelOrphan",
    "GuildChannelUnowned",
    "GuildOwned",
    "GuildMembersTimeout",
    "GuildSoundboardSoundsTimeout",
    "GuildUncachedMe",
    "ChannelNotCached",
    "StageChannelResolve",
    "GuildScheduledEventResolve",
    "FetchOwnerId",
    "InvalidType",
    "InvalidElement",
    "MessageThreadParent",
    "MessageExistingThread",
    "ThreadInvitableType",
    "WebhookMessage",
    "WebhookTokenUnavailable",
    "WebhookURLInvalid",
    "WebhookApplication",
    "MessageReferenceMissing",
    "EmojiType",
    "EmojiManaged",
    "MissingManageGuildExpressionsPermission",
    "MissingManageEmojisAndStickersPermission",
    "NotGuildSoundboardSound",
    "NotGuildSticker",
    "ReactionResolveUser",
    "VanityURL",
    "InviteResolveCode",
    "InviteNotFound",
    "DeleteGroupDMChannel",
    "FetchGroupDMChannel",
    "MemberFetchNonceLength",
    "GlobalCommandPermissions",
    "GuildUncachedEntityResolve",
    "InteractionAlreadyReplied",
    "InteractionNotReplied",
    "InteractionEphemeralReplied",
    "CommandInteractionOptionNotFound",
    "CommandInteractionOptionType",
    "CommandInteractionOptionEmpty",
    "CommandInteractionOptionNoSubcommand",
    "CommandInteractionOptionNoSubcommandGroup",
    "CommandInteractionOptionInvalidChannelType",
    "AutocompleteInteractionOptionNoFocusedOption",
    "ModalSubmitInteractionFieldNotFound",
    "ModalSubmitInteractionFieldType",
    "InvalidMissingScopes",
    "InvalidScopesWithPermissions",
    "NotImplemented",
    "SweepFilterReturn",
    "GuildForumMessageRequired",
    "EntitlementCreateInvalidOwner",
    "BulkBanUsersOptionEmpty",
    "PollAlreadyExpired"
  ];
  module.exports = Object.fromEntries(keys.map((key) => [key, key]));
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS((exports, module) => {
  var DjsErrorCodes = require_ErrorCodes();
  var Messages = {
    [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
    [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
    [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
    [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
    [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
    [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
    [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
    [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
    [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
    [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
    [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
    [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
    [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
    [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
    [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
    [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
    [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
    [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
    [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
    [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
    [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
    [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
    [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
    [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
    [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
    [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    [DjsErrorCodes.ColorConvert]: (color) => `Unable to convert "${color}" to a number.`,
    [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
    [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
    [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
    [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
    [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
    [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
    [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
    [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
    [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
    [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
    [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
    [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
    [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
    [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
    [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
    [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
    [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
    [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
    [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
    [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
    [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
    [DjsErrorCodes.MessageNonceRequired]: "Message nonce is required when enforceNonce is true.",
    [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
    [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
    [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
    [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
    [DjsErrorCodes.PruneDaysType]: "Days must be a number",
    [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
    [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
    [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
    [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
    [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
    [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
    [DjsErrorCodes.GuildSoundboardSoundsTimeout]: "Soundboard sounds didn't arrive in time.",
    [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
    [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
    [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
    [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
    [DjsErrorCodes.FetchOwnerId]: (type) => `Couldn't resolve the ${type} ownerId to fetch the ${type} ${type === "group DM" ? "owner" : "member"}.`,
    [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
    [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
    [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
    [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
    [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
    [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
    [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
    [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
    [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
    [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
    [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.NotGuildSoundboardSound]: (action) => `Soundboard sound is a default (non-guild) soundboard sound and can't be ${action}.`,
    [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
    [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
    [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
    [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
    [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
    [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
    [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
    [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
    [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable " + "or from a guild's application command manager.",
    [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
    [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
    [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
    [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
    [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
    [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
    [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
    [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
    [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
    [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
    [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
    [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
    [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
    [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread",
    [DjsErrorCodes.EntitlementCreateInvalidOwner]: "You must provide either a guild or a user to create an entitlement, but not both",
    [DjsErrorCodes.BulkBanUsersOptionEmpty]: 'Option "users" array or collection is empty',
    [DjsErrorCodes.PollAlreadyExpired]: "This poll has already expired."
  };
  module.exports = Messages;
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports, module) => {
  var ErrorCodes = require_ErrorCodes();
  var Messages = require_Messages();
  function makeDiscordjsError(Base) {
    return class DiscordjsError extends Base {
      constructor(code, ...args) {
        super(message(code, args));
        this.code = code;
        Error.captureStackTrace?.(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this.code}]`;
      }
    };
  }
  function message(code, args) {
    if (!(code in ErrorCodes))
      throw new Error("Error code must be a valid DiscordjsErrorCodes");
    const msg = Messages[code];
    if (!msg)
      throw new Error(`No message associated with error code: ${code}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (!args?.length)
      return msg;
    args.unshift(msg);
    return String(...args);
  }
  module.exports = {
    DiscordjsError: makeDiscordjsError(Error),
    DiscordjsTypeError: makeDiscordjsError(TypeError),
    DiscordjsRangeError: makeDiscordjsError(RangeError)
  };
});

// node_modules/discord.js/src/errors/index.js
var require_errors2 = __commonJS((exports, module) => {
  module.exports = require_DJSError();
  module.exports.ErrorCodes = require_ErrorCodes();
  module.exports.Messages = require_Messages();
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['’]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  module.exports = snakeCase;
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersect(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (this.has(key) && Object.is(value, this.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    subtract(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key) || !Object.is(value, other.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    sorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.values()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "1.5.3";
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS((exports, module) => {
  module.exports = {
    Default: 0,
    White: 16777215,
    Aqua: 1752220,
    Green: 5763719,
    Blue: 3447003,
    Yellow: 16705372,
    Purple: 10181046,
    LuminousVividPink: 15277667,
    Fuchsia: 15418782,
    Gold: 15844367,
    Orange: 15105570,
    Red: 15548997,
    Grey: 9807270,
    Navy: 3426654,
    DarkAqua: 1146986,
    DarkGreen: 2067276,
    DarkBlue: 2123412,
    DarkPurple: 7419530,
    DarkVividPink: 11342935,
    DarkGold: 12745742,
    DarkOrange: 11027200,
    DarkRed: 10038562,
    DarkGrey: 9936031,
    DarkerGrey: 8359053,
    LightGrey: 12370112,
    DarkNavy: 2899536,
    Blurple: 5793266,
    Greyple: 10070709,
    DarkButNotBlack: 2895667,
    NotQuiteBlack: 2303786
  };
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports, module) => {
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();

  class BitField {
    static Flags = {};
    static DefaultBit = 0;
    constructor(bits = this.constructor.DefaultBit) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      return new this.constructor(bits).remove(this).toArray(...hasParams);
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
        if (isNaN(flag))
          serialized[flag] = this.has(bit, ...hasParams);
      }
      return serialized;
    }
    toArray(...hasParams) {
      return [...this[Symbol.iterator](...hasParams)];
    }
    toJSON() {
      return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator](...hasParams) {
      for (const bitName of Object.keys(this.constructor.Flags)) {
        if (isNaN(bitName) && this.has(bitName, ...hasParams))
          yield bitName;
      }
    }
    static resolve(bit) {
      const { DefaultBit } = this;
      if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit)) {
        return bit.map((bit_) => this.resolve(bit_)).reduce((prev, bit_) => prev | bit_, DefaultBit);
      }
      if (typeof bit === "string") {
        if (!isNaN(bit))
          return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        if (this.Flags[bit] !== undefined)
          return this.Flags[bit];
      }
      throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);
    }
  }
  module.exports = BitField;
});

// node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS((exports, module) => {
  var { AttachmentFlags } = require_v106();
  var BitField = require_BitField();

  class AttachmentFlagsBitField extends BitField {
    static Flags = AttachmentFlags;
  }
  module.exports = AttachmentFlagsBitField;
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports, module) => {
  var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  var { basename, flatten } = require_Util();

  class Attachment {
    constructor(data) {
      this.attachment = data.url;
      this.name = data.filename;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("size" in data) {
        this.size = data.size;
      }
      if ("url" in data) {
        this.url = data.url;
      }
      if ("proxy_url" in data) {
        this.proxyURL = data.proxy_url;
      }
      if ("height" in data) {
        this.height = data.height;
      } else {
        this.height ??= null;
      }
      if ("width" in data) {
        this.width = data.width;
      } else {
        this.width ??= null;
      }
      if ("content_type" in data) {
        this.contentType = data.content_type;
      } else {
        this.contentType ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.ephemeral = data.ephemeral ?? false;
      if ("duration_secs" in data) {
        this.duration = data.duration_secs;
      } else {
        this.duration ??= null;
      }
      if ("waveform" in data) {
        this.waveform = data.waveform;
      } else {
        this.waveform ??= null;
      }
      if ("flags" in data) {
        this.flags = new AttachmentFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new AttachmentFlagsBitField().freeze();
      }
      if ("title" in data) {
        this.title = data.title;
      } else {
        this.title ??= null;
      }
    }
    get spoiler() {
      return basename(this.url ?? this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = Attachment;
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Faces: () => Faces,
    GuildNavigationMentions: () => GuildNavigationMentions,
    HeadingLevel: () => HeadingLevel,
    TimestampStyles: () => TimestampStyles,
    applicationDirectory: () => applicationDirectory,
    blockQuote: () => blockQuote,
    bold: () => bold,
    channelLink: () => channelLink,
    channelMention: () => channelMention,
    chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
    codeBlock: () => codeBlock,
    escapeBold: () => escapeBold,
    escapeBulletedList: () => escapeBulletedList,
    escapeCodeBlock: () => escapeCodeBlock,
    escapeEscape: () => escapeEscape,
    escapeHeading: () => escapeHeading,
    escapeInlineCode: () => escapeInlineCode,
    escapeItalic: () => escapeItalic,
    escapeMarkdown: () => escapeMarkdown,
    escapeMaskedLink: () => escapeMaskedLink,
    escapeNumberedList: () => escapeNumberedList,
    escapeSpoiler: () => escapeSpoiler,
    escapeStrikethrough: () => escapeStrikethrough,
    escapeUnderline: () => escapeUnderline,
    formatEmoji: () => formatEmoji,
    heading: () => heading,
    hideLinkEmbed: () => hideLinkEmbed,
    hyperlink: () => hyperlink,
    inlineCode: () => inlineCode,
    italic: () => italic,
    messageLink: () => messageLink,
    orderedList: () => orderedList,
    quote: () => quote,
    roleMention: () => roleMention,
    spoiler: () => spoiler,
    strikethrough: () => strikethrough,
    subtext: () => subtext,
    time: () => time,
    underline: () => underline,
    underscore: () => underscore,
    unorderedList: () => unorderedList,
    userMention: () => userMention,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  function escapeMarkdown(text, options = {}) {
    const {
      codeBlock: codeBlock2 = true,
      inlineCode: inlineCode2 = true,
      bold: bold2 = true,
      italic: italic2 = true,
      underline: underline2 = true,
      strikethrough: strikethrough2 = true,
      spoiler: spoiler2 = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape = true,
      heading: heading2 = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = options;
    if (!codeBlockContent) {
      return text.split("```").map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          inlineCode: inlineCode2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          inlineCodeContent,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(codeBlock2 ? "\\`\\`\\`" : "```");
    }
    if (!inlineCodeContent) {
      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          codeBlock: codeBlock2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(inlineCode2 ? "\\`" : "`");
    }
    let res = text;
    if (escape)
      res = escapeEscape(res);
    if (inlineCode2)
      res = escapeInlineCode(res);
    if (codeBlock2)
      res = escapeCodeBlock(res);
    if (italic2)
      res = escapeItalic(res);
    if (bold2)
      res = escapeBold(res);
    if (underline2)
      res = escapeUnderline(res);
    if (strikethrough2)
      res = escapeStrikethrough(res);
    if (spoiler2)
      res = escapeSpoiler(res);
    if (heading2)
      res = escapeHeading(res);
    if (bulletedList)
      res = escapeBulletedList(res);
    if (numberedList)
      res = escapeNumberedList(res);
    if (maskedLink)
      res = escapeMaskedLink(res);
    return res;
  }
  __name(escapeMarkdown, "escapeMarkdown");
  function escapeCodeBlock(text) {
    return text.replaceAll("```", "\\`\\`\\`");
  }
  __name(escapeCodeBlock, "escapeCodeBlock");
  function escapeInlineCode(text) {
    return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
  }
  __name(escapeInlineCode, "escapeInlineCode");
  function escapeItalic(text) {
    let idx = 0;
    const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === "**")
        return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    idx = 0;
    return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+|https?:\/\/\S+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
      if (match === "__")
        return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  }
  __name(escapeItalic, "escapeItalic");
  function escapeBold(text) {
    let idx = 0;
    return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return "\\*\\*";
    });
  }
  __name(escapeBold, "escapeBold");
  function escapeUnderline(text) {
    let idx = 0;
    return text.replaceAll(/(?<!<a?:.+|https?:\/\/\S+)__(_)?(?!:\d+>)/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return "\\_\\_";
    });
  }
  __name(escapeUnderline, "escapeUnderline");
  function escapeStrikethrough(text) {
    return text.replaceAll("~~", "\\~\\~");
  }
  __name(escapeStrikethrough, "escapeStrikethrough");
  function escapeSpoiler(text) {
    return text.replaceAll("||", "\\|\\|");
  }
  __name(escapeSpoiler, "escapeSpoiler");
  function escapeEscape(text) {
    return text.replaceAll("\\", "\\\\");
  }
  __name(escapeEscape, "escapeEscape");
  function escapeHeading(text) {
    return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
  }
  __name(escapeHeading, "escapeHeading");
  function escapeBulletedList(text) {
    return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
  }
  __name(escapeBulletedList, "escapeBulletedList");
  function escapeNumberedList(text) {
    return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
  }
  __name(escapeNumberedList, "escapeNumberedList");
  function escapeMaskedLink(text) {
    return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
  }
  __name(escapeMaskedLink, "escapeMaskedLink");
  function codeBlock(language, content) {
    return content === undefined ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
  }
  __name(codeBlock, "codeBlock");
  function inlineCode(content) {
    return `\`${content}\``;
  }
  __name(inlineCode, "inlineCode");
  function italic(content) {
    return `_${content}_`;
  }
  __name(italic, "italic");
  function bold(content) {
    return `**${content}**`;
  }
  __name(bold, "bold");
  function underscore(content) {
    return underline(content);
  }
  __name(underscore, "underscore");
  function underline(content) {
    return `__${content}__`;
  }
  __name(underline, "underline");
  function strikethrough(content) {
    return `~~${content}~~`;
  }
  __name(strikethrough, "strikethrough");
  function quote(content) {
    return `> ${content}`;
  }
  __name(quote, "quote");
  function blockQuote(content) {
    return `>>> ${content}`;
  }
  __name(blockQuote, "blockQuote");
  function hideLinkEmbed(url) {
    return `<${url}>`;
  }
  __name(hideLinkEmbed, "hideLinkEmbed");
  function hyperlink(content, url, title) {
    return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
  }
  __name(hyperlink, "hyperlink");
  function spoiler(content) {
    return `||${content}||`;
  }
  __name(spoiler, "spoiler");
  function userMention(userId) {
    return `<@${userId}>`;
  }
  __name(userMention, "userMention");
  function channelMention(channelId) {
    return `<#${channelId}>`;
  }
  __name(channelMention, "channelMention");
  function roleMention(roleId) {
    return `<@&${roleId}>`;
  }
  __name(roleMention, "roleMention");
  function chatInputApplicationCommandMention(commandName, subcommandGroupName, subcommandName, commandId) {
    if (commandId !== undefined) {
      return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
    }
    if (subcommandName !== undefined) {
      return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
    }
    return `</${commandName}:${subcommandGroupName}>`;
  }
  __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
  function formatEmoji(emojiIdOrOptions, animated) {
    const options = typeof emojiIdOrOptions === "string" ? {
      id: emojiIdOrOptions,
      animated: animated ?? false
    } : emojiIdOrOptions;
    const { id, animated: isAnimated, name: emojiName } = options;
    return `<${isAnimated ? "a" : ""}:${emojiName ?? "_"}:${id}>`;
  }
  __name(formatEmoji, "formatEmoji");
  function channelLink(channelId, guildId) {
    return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
  }
  __name(channelLink, "channelLink");
  function messageLink(channelId, messageId, guildId) {
    return `${guildId === undefined ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
  }
  __name(messageLink, "messageLink");
  var HeadingLevel = /* @__PURE__ */ ((HeadingLevel2) => {
    HeadingLevel2[HeadingLevel2["One"] = 1] = "One";
    HeadingLevel2[HeadingLevel2["Two"] = 2] = "Two";
    HeadingLevel2[HeadingLevel2["Three"] = 3] = "Three";
    return HeadingLevel2;
  })(HeadingLevel || {});
  function heading(content, level) {
    switch (level) {
      case 3:
        return `### ${content}`;
      case 2:
        return `## ${content}`;
      default:
        return `# ${content}`;
    }
  }
  __name(heading, "heading");
  function listCallback(element, startNumber, depth = 0) {
    if (Array.isArray(element)) {
      return element.map((element2) => listCallback(element2, startNumber, depth + 1)).join(`
`);
    }
    return `${"  ".repeat(depth - 1)}${startNumber ? `${startNumber}.` : "-"} ${element}`;
  }
  __name(listCallback, "listCallback");
  function orderedList(list, startNumber = 1) {
    return listCallback(list, Math.max(startNumber, 1));
  }
  __name(orderedList, "orderedList");
  function unorderedList(list) {
    return listCallback(list);
  }
  __name(unorderedList, "unorderedList");
  function subtext(content) {
    return `-# ${content}`;
  }
  __name(subtext, "subtext");
  function time(timeOrSeconds, style) {
    if (typeof timeOrSeconds !== "number") {
      timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1000);
    }
    return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
  }
  __name(time, "time");
  function applicationDirectory(applicationId, skuId) {
    const url = `https://discord.com/application-directory/${applicationId}/store`;
    return skuId ? `${url}/${skuId}` : url;
  }
  __name(applicationDirectory, "applicationDirectory");
  var TimestampStyles = {
    ShortTime: "t",
    LongTime: "T",
    ShortDate: "d",
    LongDate: "D",
    ShortDateTime: "f",
    LongDateTime: "F",
    RelativeTime: "R"
  };
  var Faces = /* @__PURE__ */ ((Faces2) => {
    Faces2["Shrug"] = "¯\\_(ツ)_/¯";
    Faces2["Tableflip"] = "(╯°□°)╯︵ ┻━┻";
    Faces2["Unflip"] = "┬─┬ノ( º _ ºノ)";
    return Faces2;
  })(Faces || {});
  var GuildNavigationMentions = /* @__PURE__ */ ((GuildNavigationMentions2) => {
    GuildNavigationMentions2["Browse"] = "<id:browse>";
    GuildNavigationMentions2["Customize"] = "<id:customize>";
    GuildNavigationMentions2["Guide"] = "<id:guide>";
    return GuildNavigationMentions2;
  })(GuildNavigationMentions || {});
  var version = "0.6.1";
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = Base;
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS((exports, module) => {
  var { ChannelFlags } = require_v106();
  var BitField = require_BitField();

  class ChannelFlagsBitField extends BitField {
    static Flags = ChannelFlags;
  }
  module.exports = ChannelFlagsBitField;
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
  exports.MaxBulkDeletableMessageAge = 1209600000;
  exports.SweeperKeys = [
    "autoModerationRules",
    "applicationCommands",
    "bans",
    "emojis",
    "entitlements",
    "invites",
    "guildMembers",
    "messages",
    "presences",
    "reactions",
    "stageInstances",
    "stickers",
    "threadMembers",
    "threads",
    "users",
    "voiceStates"
  ];
  exports.NonSystemMessageTypes = [
    MessageType.Default,
    MessageType.Reply,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand
  ];
  exports.GuildTextBasedChannelTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.AnnouncementThread,
    ChannelType.PublicThread,
    ChannelType.PrivateThread,
    ChannelType.GuildVoice,
    ChannelType.GuildStageVoice
  ];
  exports.TextBasedChannelTypes = [...exports.GuildTextBasedChannelTypes, ChannelType.DM, ChannelType.GroupDM];
  exports.SendableChannels = [...exports.GuildTextBasedChannelTypes, ChannelType.DM];
  exports.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
  exports.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  exports.SelectMenuTypes = [
    ComponentType.StringSelect,
    ComponentType.UserSelect,
    ComponentType.RoleSelect,
    ComponentType.MentionableSelect,
    ComponentType.ChannelSelect
  ];
  exports.UndeletableMessageTypes = [
    MessageType.RecipientAdd,
    MessageType.RecipientRemove,
    MessageType.Call,
    MessageType.ChannelNameChange,
    MessageType.ChannelIconChange,
    MessageType.ThreadStarterMessage
  ];
  exports.DeletableMessageTypes = [
    MessageType.AutoModerationAction,
    MessageType.ChannelFollowAdd,
    MessageType.ChannelPinnedMessage,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand,
    MessageType.Default,
    MessageType.GuildBoost,
    MessageType.GuildBoostTier1,
    MessageType.GuildBoostTier2,
    MessageType.GuildBoostTier3,
    MessageType.GuildInviteReminder,
    MessageType.InteractionPremiumUpsell,
    MessageType.Reply,
    MessageType.RoleSubscriptionPurchase,
    MessageType.StageEnd,
    MessageType.StageRaiseHand,
    MessageType.StageSpeaker,
    MessageType.StageStart,
    MessageType.StageTopic,
    MessageType.ThreadCreated,
    MessageType.UserJoin
  ];
  exports.StickerFormatExtensionMap = {
    [StickerFormatType.PNG]: ImageFormat.PNG,
    [StickerFormatType.APNG]: ImageFormat.PNG,
    [StickerFormatType.Lottie]: ImageFormat.Lottie,
    [StickerFormatType.GIF]: ImageFormat.GIF
  };
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS((exports) => {
  var { channelLink, channelMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { ThreadChannelTypes } = require_Constants();

  class BaseChannel extends Base {
    constructor(client, data, immediatePatch = true) {
      super(client);
      this.type = data.type;
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("flags" in data) {
        this.flags = new ChannelFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new ChannelFlagsBitField().freeze();
      }
      this.id = data.id;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
    }
    get partial() {
      return false;
    }
    toString() {
      return channelMention(this.id);
    }
    async delete() {
      await this.client.rest.delete(Routes.channel(this.id));
      return this;
    }
    fetch(force = true) {
      return this.client.channels.fetch(this.id, { force });
    }
    isThread() {
      return ThreadChannelTypes.includes(this.type);
    }
    isTextBased() {
      return "messages" in this;
    }
    isDMBased() {
      return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
    }
    isVoiceBased() {
      return "bitrate" in this;
    }
    isThreadOnly() {
      return "availableTags" in this;
    }
    isSendable() {
      return "send" in this;
    }
    toJSON(...props) {
      return super.toJSON({ createdTimestamp: true }, ...props);
    }
  }
  exports.BaseChannel = BaseChannel;
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports, module) => {
  class BaseManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
  }
  module.exports = BaseManager;
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS((exports, module) => {
  var BaseManager = require_BaseManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class DataManager extends BaseManager {
    constructor(client, holds) {
      super(client);
      Object.defineProperty(this, "holds", { value: holds });
    }
    get cache() {
      throw new DiscordjsError(ErrorCodes.NotImplemented, "get cache", this.constructor.name);
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) ?? null;
      return null;
    }
    resolveId(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = DataManager;
});

// node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS((exports) => {
  exports.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class CachedManager extends DataManager {
    constructor(client, holds, iterable) {
      super(client, holds);
      Object.defineProperty(this, "_cache", {
        value: this.client.options.makeCache(this.constructor[MakeCacheOverrideSymbol] ?? this.constructor, this.holds, this.constructor)
      });
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    get cache() {
      return this._cache;
    }
    _add(data, cache = true, { id, extras = [] } = {}) {
      const existing = this.cache.get(id ?? data.id);
      if (existing) {
        if (cache) {
          existing._patch(data);
          return existing;
        }
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id ?? entry.id, entry);
      return entry;
    }
  }
  module.exports = CachedManager;
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BitField = require_BitField();

  class PermissionsBitField extends BitField {
    static Flags = PermissionFlagsBits;
    static All = Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n);
    static Default = BigInt(104324673);
    static StageModerator = PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers;
    static DefaultBit = BigInt(0);
    missing(bits, checkAdmin = true) {
      return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
    }
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
    }
    toArray() {
      return super.toArray(false);
    }
  }
  module.exports = PermissionsBitField;
});

// node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS((exports, module) => {
  var { RoleFlags } = require_v106();
  var BitField = require_BitField();

  class RoleFlagsBitField extends BitField {
    static Flags = RoleFlags;
  }
  module.exports = RoleFlagsBitField;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports) => {
  var { roleMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();
  var RoleFlagsBitField = require_RoleFlagsBitField();

  class Role extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.icon = null;
      this.unicodeEmoji = null;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("color" in data) {
        this.color = data.color;
      }
      if ("hoist" in data) {
        this.hoist = data.hoist;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("permissions" in data) {
        this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("mentionable" in data) {
        this.mentionable = data.mentionable;
      }
      if ("icon" in data)
        this.icon = data.icon;
      if ("unicode_emoji" in data)
        this.unicodeEmoji = data.unicode_emoji;
      if ("flags" in data) {
        this.flags = new RoleFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new RoleFlagsBitField().freeze();
      }
      this.tags = data.tags ? {} : null;
      if (data.tags) {
        if ("bot_id" in data.tags) {
          this.tags.botId = data.tags.bot_id;
        }
        if ("integration_id" in data.tags) {
          this.tags.integrationId = data.tags.integration_id;
        }
        if ("premium_subscriber" in data.tags) {
          this.tags.premiumSubscriberRole = true;
        }
        if ("subscription_listing_id" in data.tags) {
          this.tags.subscriptionListingId = data.tags.subscription_listing_id;
        }
        if ("available_for_purchase" in data.tags) {
          this.tags.availableForPurchase = true;
        }
        if ("guild_connections" in data.tags) {
          this.tags.guildConnections = true;
        }
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.color.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((member) => member._roles.includes(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.members.resolve(this.client.user);
      if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) < BigInt(role.id) : this.rawPosition > role.rawPosition), 0);
    }
    comparePositionTo(role) {
      return this.guild.roles.comparePositions(this, role);
    }
    edit(options) {
      return this.guild.roles.edit(this, options);
    }
    permissionsIn(channel, checkAdmin = true) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.rolePermissions(this, checkAdmin);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setColor(color, reason) {
      return this.edit({ color, reason });
    }
    setHoist(hoist = true, reason) {
      return this.edit({ hoist, reason });
    }
    setPermissions(permissions, reason) {
      return this.edit({ permissions, reason });
    }
    setMentionable(mentionable = true, reason) {
      return this.edit({ mentionable, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setUnicodeEmoji(unicodeEmoji, reason) {
      return this.edit({ unicodeEmoji, reason });
    }
    setPosition(position, options = {}) {
      return this.guild.roles.setPosition(this, position, options);
    }
    async delete(reason) {
      await this.guild.roles.delete(this.id, reason);
      return this;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return roleMention(this.id);
    }
    toJSON() {
      return {
        ...super.toJSON({ createdTimestamp: true }),
        permissions: this.permissions.toJSON()
      };
    }
  }
  exports.Role = Role;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports, module) => {
  var { OverwriteType } = require_v106();
  var Base = require_Base();
  var { Role } = require_Role();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();

  class PermissionOverwrites extends Base {
    constructor(client, data, channel) {
      super(client);
      Object.defineProperty(this, "channel", { value: channel });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deny" in data) {
        this.deny = new PermissionsBitField(BigInt(data.deny)).freeze();
      }
      if ("allow" in data) {
        this.allow = new PermissionsBitField(BigInt(data.allow)).freeze();
      }
    }
    async edit(options, reason) {
      await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
      return this;
    }
    async delete(reason) {
      await this.channel.permissionOverwrites.delete(this.id, reason);
      return this;
    }
    toJSON() {
      return {
        id: this.id,
        type: this.type,
        allow: this.allow,
        deny: this.deny
      };
    }
    static resolveOverwriteOptions(options, { allow, deny } = {}) {
      allow = new PermissionsBitField(allow);
      deny = new PermissionsBitField(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(perm);
          deny.remove(perm);
        } else if (value === false) {
          allow.remove(perm);
          deny.add(perm);
        } else if (value === null) {
          allow.remove(perm);
          deny.remove(perm);
        }
      }
      return { allow, deny };
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
        return {
          id: overwrite.id,
          type: overwrite.type,
          allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
          deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
        };
      }
      const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
      if (!userOrRole) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "cached User or Role");
      }
      const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      return {
        id: userOrRole.id,
        type,
        allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
        deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
      };
    }
  }
  module.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { OverwriteType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionOverwrites = require_PermissionOverwrites();
  var { Role } = require_Role();
  var cacheWarningEmitted = false;

  class PermissionOverwriteManager extends CachedManager {
    constructor(channel, iterable) {
      super(channel.client, PermissionOverwrites);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.channel = channel;
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.channel] });
    }
    async set(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "overwrites", "Array or Collection of Permission Overwrites", true);
      }
      return this.channel.edit({ permissionOverwrites: overwrites, reason });
    }
    async upsert(userOrRole, options, overwriteOptions = {}, existing) {
      let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      let { type, reason } = overwriteOptions;
      if (typeof type !== "number") {
        userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
        if (!userOrRole)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
        type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      }
      const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
      await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {
        body: { id: userOrRoleId, type, allow, deny },
        reason
      });
      return this.channel;
    }
    create(userOrRole, options, overwriteOptions) {
      return this.upsert(userOrRole, options, overwriteOptions);
    }
    edit(userOrRole, options, overwriteOptions) {
      const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));
      return this.upsert(userOrRole, options, overwriteOptions, existing);
    }
    async delete(userOrRole, reason) {
      const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      if (!userOrRoleId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });
      return this.channel;
    }
  }
  module.exports = PermissionOverwriteManager;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports, module) => {
  var { Snowflake } = require_cjs();
  var { PermissionFlagsBits, ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionOverwriteManager = require_PermissionOverwriteManager();
  var { VoiceBasedChannelTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();
  var { getSortableGroupTypes } = require_Util();

  class GuildChannel extends BaseChannel {
    constructor(guild, data, client, immediatePatch = true) {
      super(client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.permissionOverwrites = new PermissionOverwriteManager(this);
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("permission_overwrites" in data) {
        this.permissionOverwrites.cache.clear();
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites._add(overwrite);
        }
      }
    }
    _clone() {
      const clone = super._clone();
      clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
      return clone;
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      const overwriteIds = new Set([
        ...this.permissionOverwrites.cache.keys(),
        ...this.parent.permissionOverwrites.cache.keys()
      ]);
      return [...overwriteIds].every((key) => {
        const channelVal = this.permissionOverwrites.cache.get(key);
        const parentVal = this.parent.permissionOverwrites.cache.get(key);
        if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {
          return true;
        }
        return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
      });
    }
    get position() {
      const selfIsCategory = this.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(this.type);
      let count = 0;
      for (const channel of this.guild.channels.cache.values()) {
        if (!types.includes(channel.type))
          continue;
        if (!selfIsCategory && channel.parentId !== this.parentId)
          continue;
        if (this.rawPosition === channel.rawPosition) {
          if (Snowflake.compare(channel.id, this.id) === -1)
            count++;
        } else if (this.rawPosition > channel.rawPosition) {
          count++;
        }
      }
      return count;
    }
    permissionsFor(memberOrRole, checkAdmin = true) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member, checkAdmin);
      const role = this.guild.roles.resolve(memberOrRole);
      return role && this.rolePermissions(role, checkAdmin);
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles ??= member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.cache.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member, checkAdmin) {
      if (checkAdmin && member.id === this.guild.ownerId) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const roles = member.roles.cache;
      const permissions = new PermissionsBitField(roles.map((role) => role.permissions));
      if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    rolePermissions(role, checkAdmin) {
      if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
      return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    async lockPermissions() {
      if (!this.parent)
        throw new DiscordjsError(ErrorCodes.GuildChannelOrphan);
      const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
      return this.edit({ permissionOverwrites });
    }
    get members() {
      return this.guild.members.cache.filter((member) => this.permissionsFor(member).has(PermissionFlagsBits.ViewChannel, false));
    }
    edit(options) {
      return this.guild.channels.edit(this, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setParent(channel, { lockPermissions = true, reason } = {}) {
      return this.edit({
        parent: channel ?? null,
        lockPermissions,
        reason
      });
    }
    setPosition(position, options = {}) {
      return this.guild.channels.setPosition(this, position, options);
    }
    clone(options = {}) {
      return this.guild.channels.create({
        name: options.name ?? this.name,
        permissionOverwrites: this.permissionOverwrites.cache,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        position: this.rawPosition,
        reason: null,
        ...options
      });
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
        return false;
      const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
      return permissions.has(bitfield, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
  }
  module.exports = GuildChannel;
});

// node_modules/discord.js/src/util/SKUFlagsBitField.js
var require_SKUFlagsBitField = __commonJS((exports) => {
  var { SKUFlags } = require_v106();
  var BitField = require_BitField();

  class SKUFlagsBitField extends BitField {
    static Flags = SKUFlags;
  }
  exports.SKUFlagsBitField = SKUFlagsBitField;
});

// node_modules/discord.js/src/structures/SKU.js
var require_SKU = __commonJS((exports) => {
  var Base = require_Base();
  var { SKUFlagsBitField } = require_SKUFlagsBitField();

  class SKU extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.type = data.type;
      this.applicationId = data.application_id;
      this.name = data.name;
      this.slug = data.slug;
      this.flags = new SKUFlagsBitField(data.flags).freeze();
    }
  }
  exports.SKU = SKU;
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var { parse } = __require("node:path");
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { ChannelType, RouteBases, Routes } = require_v106();
  var { fetch: fetch2 } = require_undici();
  var Colors = require_Colors();
  var { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var isObject = (d) => typeof d === "object" && d !== null;
  var deprecationEmittedForUserFetchFlags = false;
  var deprecationEmittedForRemoveThreadMember = false;
  function flatten(obj, ...props) {
    if (!isObject(obj))
      return obj;
    const objProps = Object.keys(obj).filter((key) => !key.startsWith("_")).map((key) => ({ [key]: true }));
    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
    const out = {};
    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp)
        continue;
      newProp = newProp === true ? prop : newProp;
      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
      const hasToJSON = elemIsObj && typeof element.toJSON === "function";
      if (element instanceof Collection)
        out[newProp] = Array.from(element.keys());
      else if (valueOf instanceof Collection)
        out[newProp] = Array.from(valueOf.keys());
      else if (Array.isArray(element))
        out[newProp] = element.map((elm) => elm.toJSON?.() ?? flatten(elm));
      else if (typeof valueOf !== "object")
        out[newProp] = valueOf;
      else if (hasToJSON)
        out[newProp] = element.toJSON();
      else if (typeof element === "object")
        out[newProp] = flatten(element);
      else if (!elemIsObj)
        out[newProp] = element;
    }
    return out;
  }
  async function fetchRecommendedShardCount(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {
    if (!token)
      throw new DiscordjsError(ErrorCodes.TokenMissing);
    const response = await fetch2(RouteBases.api + Routes.gatewayBot(), {
      method: "GET",
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
    });
    if (!response.ok) {
      if (response.status === 401)
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      throw response;
    }
    const { shards } = await response.json();
    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;
  }
  function parseEmoji(text) {
    if (text.includes("%"))
      text = decodeURIComponent(text);
    if (!text.includes(":"))
      return { animated: false, name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
  }
  function resolvePartialEmoji(emoji) {
    if (!emoji)
      return null;
    if (typeof emoji === "string")
      return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
    const { id, name, animated } = emoji;
    if (!id && !name)
      return null;
    return { id, name, animated: Boolean(animated) };
  }
  function makeError(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  }
  function makePlainError(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  }
  var TextSortableGroupTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.GuildForum,
    ChannelType.GuildMedia
  ];
  var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  var CategorySortableGroupTypes = [ChannelType.GuildCategory];
  function getSortableGroupTypes(type) {
    switch (type) {
      case ChannelType.GuildText:
      case ChannelType.GuildAnnouncement:
      case ChannelType.GuildForum:
      case ChannelType.GuildMedia:
        return TextSortableGroupTypes;
      case ChannelType.GuildVoice:
      case ChannelType.GuildStageVoice:
        return VoiceSortableGroupTypes;
      case ChannelType.GuildCategory:
        return CategorySortableGroupTypes;
      default:
        return [type];
    }
  }
  function moveElementInArray(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  }
  function verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
    if (typeof data !== "string")
      throw new error(errorMessage);
    if (!allowEmpty && data.length === 0)
      throw new error(errorMessage);
    return data;
  }
  function resolveColor(color) {
    let resolvedColor;
    if (typeof color === "string") {
      if (color === "Random")
        return Math.floor(Math.random() * (16777215 + 1));
      if (color === "Default")
        return 0;
      if (/^#?[\da-f]{6}$/i.test(color))
        return parseInt(color.replace("#", ""), 16);
      resolvedColor = Colors[color];
    } else if (Array.isArray(color)) {
      resolvedColor = (color[0] << 16) + (color[1] << 8) + color[2];
    } else {
      resolvedColor = color;
    }
    if (!Number.isInteger(resolvedColor)) {
      throw new DiscordjsTypeError(ErrorCodes.ColorConvert, color);
    }
    if (resolvedColor < 0 || resolvedColor > 16777215) {
      throw new DiscordjsRangeError(ErrorCodes.ColorRange);
    }
    return resolvedColor;
  }
  function discordSort(collection) {
    const isGuildChannel = collection.first() instanceof GuildChannel;
    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));
  }
  async function setPosition(item, position, relative, sorted, client, route, reason) {
    let updatedItems = [...sorted.values()];
    moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    await client.rest.patch(route, { body: updatedItems, reason });
    return updatedItems;
  }
  function basename(path, ext) {
    const res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
  }
  function cleanContent(str, channel) {
    return str.replaceAll(/<(?:(?<type>@[!&]?|#)|(?:\/(?<commandName>[-_\p{L}\p{N}\p{sc=Deva}\p{sc=Thai} ]+):)|(?:a?:(?<emojiName>[\w]+):))(?<id>\d{17,19})>/gu, (match, type, commandName, emojiName, id) => {
      if (commandName)
        return `/${commandName}`;
      if (emojiName)
        return `:${emojiName}:`;
      switch (type) {
        case "@":
        case "@!": {
          const member = channel.guild?.members.cache.get(id);
          if (member) {
            return `@${member.displayName}`;
          }
          const user = channel.client.users.cache.get(id);
          return user ? `@${user.displayName}` : match;
        }
        case "@&": {
          if (channel.type === ChannelType.DM)
            return match;
          const role = channel.guild.roles.cache.get(id);
          return role ? `@${role.name}` : match;
        }
        case "#": {
          const mentionedChannel = channel.client.channels.cache.get(id);
          return mentionedChannel ? `#${mentionedChannel.name}` : match;
        }
        default: {
          return match;
        }
      }
    });
  }
  function cleanCodeBlockContent(text) {
    return text.replaceAll("```", "`​``");
  }
  function parseWebhookURL(url) {
    const matches = url.match(/https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i);
    if (!matches || matches.length <= 2)
      return null;
    const [, id, token] = matches;
    return {
      id,
      token
    };
  }
  function transformResolved({ client, guild, channel }, { members, users, channels, roles, messages, attachments } = {}) {
    const result = {};
    if (members) {
      result.members = new Collection;
      for (const [id, member] of Object.entries(members)) {
        const user = users[id];
        result.members.set(id, guild?.members._add({ user, ...member }) ?? member);
      }
    }
    if (users) {
      result.users = new Collection;
      for (const user of Object.values(users)) {
        result.users.set(user.id, client.users._add(user));
      }
    }
    if (roles) {
      result.roles = new Collection;
      for (const role of Object.values(roles)) {
        result.roles.set(role.id, guild?.roles._add(role) ?? role);
      }
    }
    if (channels) {
      result.channels = new Collection;
      for (const apiChannel of Object.values(channels)) {
        result.channels.set(apiChannel.id, client.channels._add(apiChannel, guild) ?? apiChannel);
      }
    }
    if (messages) {
      result.messages = new Collection;
      for (const message of Object.values(messages)) {
        result.messages.set(message.id, channel?.messages?._add(message) ?? message);
      }
    }
    if (attachments) {
      result.attachments = new Collection;
      for (const attachment of Object.values(attachments)) {
        const patched = new Attachment(attachment);
        result.attachments.set(attachment.id, patched);
      }
    }
    return result;
  }
  function resolveSKUId(resolvable) {
    if (typeof resolvable === "string")
      return resolvable;
    if (resolvable instanceof SKU)
      return resolvable.id;
    return null;
  }
  function emitDeprecationWarningForUserFetchFlags(name) {
    if (deprecationEmittedForUserFetchFlags)
      return;
    process2.emitWarning(`${name}#fetchFlags() is deprecated. Use ${name}#fetch() instead.`);
    deprecationEmittedForUserFetchFlags = true;
  }
  function emitDeprecationWarningForRemoveThreadMember(name) {
    if (deprecationEmittedForRemoveThreadMember)
      return;
    process2.emitWarning(`The reason parameter of ${name}#remove() is deprecated as Discord does not parse them. It will be removed in the next major version.`);
    deprecationEmittedForRemoveThreadMember = true;
  }
  module.exports = {
    flatten,
    fetchRecommendedShardCount,
    parseEmoji,
    resolvePartialEmoji,
    makeError,
    makePlainError,
    getSortableGroupTypes,
    moveElementInArray,
    verifyString,
    resolveColor,
    discordSort,
    setPosition,
    basename,
    cleanContent,
    cleanCodeBlockContent,
    parseWebhookURL,
    transformResolved,
    resolveSKUId,
    emitDeprecationWarningForUserFetchFlags,
    emitDeprecationWarningForRemoveThreadMember
  };
  var Attachment = require_Attachment();
  var GuildChannel = require_GuildChannel();
  var { SKU } = require_SKU();
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS((exports, module) => {
  var { isJSONEncodable } = require_dist();
  var snakeCase = require_lodash();
  var { resolvePartialEmoji } = require_Util();
  function toSnakeCase(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    if (obj instanceof Date)
      return obj;
    if (isJSONEncodable(obj))
      return toSnakeCase(obj.toJSON());
    if (Array.isArray(obj))
      return obj.map(toSnakeCase);
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
      snakeCase(key),
      key === "emoji" && typeof value === "string" ? resolvePartialEmoji(value) : toSnakeCase(value)
    ]));
  }
  function _transformAPIAutoModerationAction(autoModerationAction) {
    return {
      type: autoModerationAction.type,
      metadata: {
        durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
        channelId: autoModerationAction.metadata.channel_id ?? null,
        customMessage: autoModerationAction.metadata.custom_message ?? null
      }
    };
  }
  function _transformAPIMessageInteractionMetadata(client, messageInteractionMetadata) {
    return {
      id: messageInteractionMetadata.id,
      type: messageInteractionMetadata.type,
      user: client.users._add(messageInteractionMetadata.user),
      authorizingIntegrationOwners: messageInteractionMetadata.authorizing_integration_owners,
      originalResponseMessageId: messageInteractionMetadata.original_response_message_id ?? null,
      interactedMessageId: messageInteractionMetadata.interacted_message_id ?? null,
      triggeringInteractionMetadata: messageInteractionMetadata.triggering_interaction_metadata ? _transformAPIMessageInteractionMetadata(client, messageInteractionMetadata.triggering_interaction_metadata) : null
    };
  }
  function _transformGuildScheduledEventRecurrenceRule(recurrenceRule) {
    return {
      start: new Date(recurrenceRule.startAt).toISOString(),
      frequency: recurrenceRule.frequency,
      interval: recurrenceRule.interval,
      by_weekday: recurrenceRule.byWeekday,
      by_n_weekday: recurrenceRule.byNWeekday,
      by_month: recurrenceRule.byMonth,
      by_month_day: recurrenceRule.byMonthDay
    };
  }
  function _transformAPIIncidentsData(data) {
    return {
      invitesDisabledUntil: data.invites_disabled_until ? new Date(data.invites_disabled_until) : null,
      dmsDisabledUntil: data.dms_disabled_until ? new Date(data.dms_disabled_until) : null,
      dmSpamDetectedAt: data.dm_spam_detected_at ? new Date(data.dm_spam_detected_at) : null,
      raidDetectedAt: data.raid_detected_at ? new Date(data.raid_detected_at) : null
    };
  }
  module.exports = {
    toSnakeCase,
    _transformAPIAutoModerationAction,
    _transformAPIMessageInteractionMetadata,
    _transformGuildScheduledEventRecurrenceRule,
    _transformAPIIncidentsData
  };
});

// node_modules/discord.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    $schema: "https://json.schemastore.org/package.json",
    name: "discord.js",
    version: "14.21.0",
    description: "A powerful library for interacting with the Discord API",
    main: "./src/index.js",
    types: "./typings/index.d.ts",
    exports: {
      ".": {
        import: {
          types: "./typings/index.d.mts",
          default: "./src/index.js"
        },
        require: {
          types: "./typings/index.d.ts",
          default: "./src/index.js"
        }
      }
    },
    directories: {
      lib: "src",
      test: "test"
    },
    files: [
      "src",
      "typings/*.d.ts",
      "typings/*.d.mts"
    ],
    contributors: [
      "Crawl <icrawltogo@gmail.com>",
      "Amish Shah <amishshah.2k@gmail.com>",
      "Vlad Frangu <me@vladfrangu.dev>",
      "SpaceEEC <spaceeec@yahoo.com>",
      "Aura Román <kyradiscord@gmail.com>"
    ],
    license: "Apache-2.0",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    repository: {
      type: "git",
      url: "https://github.com/discordjs/discord.js.git",
      directory: "packages/discord.js"
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    homepage: "https://discord.js.org",
    funding: "https://github.com/discordjs/discord.js?sponsor",
    dependencies: {
      "@discordjs/builders": "^1.11.2",
      "@discordjs/collection": "1.5.3",
      "@discordjs/formatters": "^0.6.1",
      "@discordjs/ws": "^1.2.3",
      "@sapphire/snowflake": "3.5.3",
      "discord-api-types": "^0.38.1",
      "fast-deep-equal": "3.1.3",
      "lodash.snakecase": "4.1.1",
      "magic-bytes.js": "^1.10.0",
      tslib: "^2.6.3",
      undici: "6.21.3",
      "@discordjs/rest": "^2.5.1",
      "@discordjs/util": "^1.1.1"
    },
    devDependencies: {
      "@favware/cliff-jumper": "^4.1.0",
      "@types/node": "^16.18.105",
      "@typescript-eslint/eslint-plugin": "^8.2.0",
      "@typescript-eslint/parser": "^8.2.0",
      "cross-env": "^7.0.3",
      dtslint: "4.2.1",
      eslint: "^8.57.0",
      "eslint-formatter-pretty": "^5.0.0",
      jest: "29.7.0",
      prettier: "^3.3.3",
      tsd: "^0.31.1",
      tslint: "6.1.3",
      turbo: "^2.0.14",
      typescript: "~5.5.4",
      "@discordjs/api-extractor": "^7.38.1",
      "@discordjs/docgen": "^0.12.1",
      "@discordjs/scripts": "^0.1.0"
    },
    engines: {
      node: ">=18"
    },
    publishConfig: {
      provenance: true
    },
    scripts: {
      test: "pnpm run docs:test && pnpm run test:typescript",
      "test:typescript": "tsc --noEmit && tsd",
      lint: "prettier --check . && tslint typings/index.d.ts && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --format=pretty src typings",
      format: "prettier --write . && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --fix --format=pretty src",
      fmt: "pnpm run format",
      docs: 'docgen -i "./src/*.js" "./src/**/*.js" -c ./docs/index.json -r ../../ -o ./docs/docs.json && pnpm run docs:new',
      "docs:test": 'docgen -i "./src/*.js" "./src/**/*.js" -c ./docs/index.json -r ../../',
      "docs:new": "api-extractor run --local --minify && generate-split-documentation",
      changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
      release: "cliff-jumper"
    }
  };
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class LimitedCollection extends Collection {
    constructor(options = {}, iterable) {
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const { maxSize = Infinity, keepOverLimit = null } = options;
      if (typeof maxSize !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "maxSize", "number");
      }
      if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "keepOverLimit", "function");
      }
      super(iterable);
      this.maxSize = maxSize;
      this.keepOverLimit = keepOverLimit;
    }
    set(key, value) {
      if (this.maxSize === 0 && !this.keepOverLimit?.(value, key, this))
        return this;
      if (this.size >= this.maxSize && !this.has(key)) {
        for (const [k, v] of this.entries()) {
          const keep = this.keepOverLimit?.(v, k, this) ?? false;
          if (!keep) {
            this.delete(k);
            break;
          }
        }
      }
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection;
    }
  }
  module.exports = LimitedCollection;
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS((exports, module) => {
  var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist5();
  var { toSnakeCase } = require_Transformers();
  var { version } = require_package();

  class Options extends null {
    static userAgentAppendix = `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd();
    static createDefault() {
      return {
        closeTimeout: 5000,
        waitGuildTimeout: 15000,
        shardCount: 1,
        makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
        partials: [],
        failIfNotExists: true,
        enforceNonce: false,
        presence: {},
        sweepers: this.DefaultSweeperSettings,
        ws: {
          large_threshold: 50,
          version: 10
        },
        rest: {
          ...DefaultRestOptions,
          userAgentAppendix: this.userAgentAppendix
        },
        jsonTransformer: toSnakeCase
      };
    }
    static cacheWithLimits(settings = {}) {
      const { Collection } = require_dist6();
      const LimitedCollection = require_LimitedCollection();
      return (managerType, _, manager) => {
        const setting = settings[manager.name] ?? settings[managerType.name];
        if (setting == null) {
          return new Collection;
        }
        if (typeof setting === "number") {
          if (setting === Infinity) {
            return new Collection;
          }
          return new LimitedCollection({ maxSize: setting });
        }
        const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
        if (noLimit) {
          return new Collection;
        }
        return new LimitedCollection(setting);
      };
    }
    static cacheEverything() {
      const { Collection } = require_dist6();
      return () => new Collection;
    }
    static get DefaultMakeCacheSettings() {
      return {
        MessageManager: 200
      };
    }
    static get DefaultSweeperSettings() {
      return {
        threads: {
          interval: 3600,
          lifetime: 14400
        }
      };
    }
  }
  module.exports = Options;
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { REST } = require_dist5();
  var { Routes } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Options = require_Options();
  var { flatten } = require_Util();

  class BaseClient extends EventEmitter {
    constructor(options = {}) {
      super({ captureRejections: true });
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const defaultOptions = Options.createDefault();
      this.options = {
        ...defaultOptions,
        ...options,
        presence: {
          ...defaultOptions.presence,
          ...options.presence
        },
        sweepers: {
          ...defaultOptions.sweepers,
          ...options.sweepers
        },
        ws: {
          ...defaultOptions.ws,
          ...options.ws
        },
        rest: {
          ...defaultOptions.rest,
          ...options.rest,
          userAgentAppendix: options.rest?.userAgentAppendix ? `${Options.userAgentAppendix} ${options.rest.userAgentAppendix}` : Options.userAgentAppendix
        }
      };
      this.rest = new REST(this.options.rest);
    }
    destroy() {
      this.rest.clearHashSweeper();
      this.rest.clearHandlerSweeper();
    }
    async deleteWebhook(id, { token, reason } = {}) {
      await this.rest.delete(Routes.webhook(id, token), { auth: !token, reason });
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  }
  module.exports = BaseClient;
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS((exports, module) => {
  function createEnum(keys) {
    const obj = {};
    for (const [index, key] of keys.entries()) {
      if (key === null)
        continue;
      obj[key] = index;
      obj[index] = key;
    }
    return obj;
  }
  module.exports = { createEnum };
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "User",
    "Channel",
    "GuildMember",
    "Message",
    "Reaction",
    "GuildScheduledEvent",
    "ThreadMember",
    "SoundboardSound"
  ]);
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports, module) => {
  var Partials = require_Partials();

  class GenericAction {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
    }
    getChannel(data) {
      const payloadData = {};
      const id = data.channel_id ?? data.id;
      if (!("recipients" in data)) {
        const recipient = data.author ?? data.user ?? { id: data.user_id };
        if (recipient.id !== this.client.user.id)
          payloadData.recipients = [recipient];
      }
      if (id !== undefined)
        payloadData.id = id;
      return data[this.client.actions.injectedChannel] ?? this.getPayload({ ...data, ...payloadData }, this.client.channels, id, Partials.Channel);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id ?? data.id;
      return data[this.client.actions.injectedMessage] ?? this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id ?? channel.guild?.id
      }, channel.messages, id, Partials.Message, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user?.id === this.client.user.id
      }, message.reactions, id, Partials.Reaction);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
    }
    getUser(data) {
      const id = data.user_id;
      return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member?.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members._add(data.member).user;
        } else {
          return this.client.users._add(data.member.user);
        }
      }
      return this.getUser(data);
    }
    getScheduledEvent(data, guild) {
      const id = data.guild_scheduled_event_id ?? data.id;
      return this.getPayload({ id, guild_id: data.guild_id ?? guild.id }, guild.scheduledEvents, id, Partials.GuildScheduledEvent);
    }
    getThreadMember(id, manager) {
      return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
    }
    getSoundboardSound(data, guild) {
      return this.getPayload(data, guild.soundboardSounds, data.sound_id, Partials.SoundboardSound);
    }
    spreadInjectedData(data) {
      return Object.fromEntries(Object.getOwnPropertySymbols(data).map((symbol) => [symbol, data[symbol]]));
    }
  }
  module.exports = GenericAction;
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS((exports, module) => {
  module.exports = {
    ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
    AutoModerationActionExecution: "autoModerationActionExecution",
    AutoModerationRuleCreate: "autoModerationRuleCreate",
    AutoModerationRuleDelete: "autoModerationRuleDelete",
    AutoModerationRuleUpdate: "autoModerationRuleUpdate",
    CacheSweep: "cacheSweep",
    ChannelCreate: "channelCreate",
    ChannelDelete: "channelDelete",
    ChannelPinsUpdate: "channelPinsUpdate",
    ChannelUpdate: "channelUpdate",
    ClientReady: "ready",
    Debug: "debug",
    EntitlementCreate: "entitlementCreate",
    EntitlementUpdate: "entitlementUpdate",
    EntitlementDelete: "entitlementDelete",
    Error: "error",
    GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
    GuildAvailable: "guildAvailable",
    GuildBanAdd: "guildBanAdd",
    GuildBanRemove: "guildBanRemove",
    GuildCreate: "guildCreate",
    GuildDelete: "guildDelete",
    GuildEmojiCreate: "emojiCreate",
    GuildEmojiDelete: "emojiDelete",
    GuildEmojiUpdate: "emojiUpdate",
    GuildIntegrationsUpdate: "guildIntegrationsUpdate",
    GuildMemberAdd: "guildMemberAdd",
    GuildMemberAvailable: "guildMemberAvailable",
    GuildMemberRemove: "guildMemberRemove",
    GuildMembersChunk: "guildMembersChunk",
    GuildMemberUpdate: "guildMemberUpdate",
    GuildRoleCreate: "roleCreate",
    GuildRoleDelete: "roleDelete",
    GuildRoleUpdate: "roleUpdate",
    GuildScheduledEventCreate: "guildScheduledEventCreate",
    GuildScheduledEventDelete: "guildScheduledEventDelete",
    GuildScheduledEventUpdate: "guildScheduledEventUpdate",
    GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
    GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
    GuildSoundboardSoundCreate: "guildSoundboardSoundCreate",
    GuildSoundboardSoundDelete: "guildSoundboardSoundDelete",
    GuildSoundboardSoundsUpdate: "guildSoundboardSoundsUpdate",
    GuildSoundboardSoundUpdate: "guildSoundboardSoundUpdate",
    GuildStickerCreate: "stickerCreate",
    GuildStickerDelete: "stickerDelete",
    GuildStickerUpdate: "stickerUpdate",
    GuildUnavailable: "guildUnavailable",
    GuildUpdate: "guildUpdate",
    InteractionCreate: "interactionCreate",
    Invalidated: "invalidated",
    InviteCreate: "inviteCreate",
    InviteDelete: "inviteDelete",
    MessageBulkDelete: "messageDeleteBulk",
    MessageCreate: "messageCreate",
    MessageDelete: "messageDelete",
    MessagePollVoteAdd: "messagePollVoteAdd",
    MessagePollVoteRemove: "messagePollVoteRemove",
    MessageReactionAdd: "messageReactionAdd",
    MessageReactionRemove: "messageReactionRemove",
    MessageReactionRemoveAll: "messageReactionRemoveAll",
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
    MessageUpdate: "messageUpdate",
    PresenceUpdate: "presenceUpdate",
    SoundboardSounds: "soundboardSounds",
    Raw: "raw",
    ShardDisconnect: "shardDisconnect",
    ShardError: "shardError",
    ShardReady: "shardReady",
    ShardReconnecting: "shardReconnecting",
    ShardResume: "shardResume",
    StageInstanceCreate: "stageInstanceCreate",
    StageInstanceDelete: "stageInstanceDelete",
    StageInstanceUpdate: "stageInstanceUpdate",
    SubscriptionCreate: "subscriptionCreate",
    SubscriptionUpdate: "subscriptionUpdate",
    SubscriptionDelete: "subscriptionDelete",
    ThreadCreate: "threadCreate",
    ThreadDelete: "threadDelete",
    ThreadListSync: "threadListSync",
    ThreadMembersUpdate: "threadMembersUpdate",
    ThreadMemberUpdate: "threadMemberUpdate",
    ThreadUpdate: "threadUpdate",
    TypingStart: "typingStart",
    UserUpdate: "userUpdate",
    VoiceChannelEffectSend: "voiceChannelEffectSend",
    VoiceServerUpdate: "voiceServerUpdate",
    VoiceStateUpdate: "voiceStateUpdate",
    Warn: "warn",
    WebhooksUpdate: "webhookUpdate"
  };
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ApplicationCommandPermissionsUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      client.emit(Events.ApplicationCommandPermissionsUpdate, {
        permissions: data.permissions,
        id: data.id,
        guildId: data.guild_id,
        applicationId: data.application_id
      });
    }
  }
  module.exports = ApplicationCommandPermissionsUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS((exports, module) => {
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationActionExecution {
    constructor(data, guild) {
      this.guild = guild;
      this.action = _transformAPIAutoModerationAction(data.action);
      this.ruleId = data.rule_id;
      this.ruleTriggerType = data.rule_trigger_type;
      this.userId = data.user_id;
      this.channelId = data.channel_id ?? null;
      this.messageId = data.message_id ?? null;
      this.alertSystemMessageId = data.alert_system_message_id ?? null;
      this.content = data.content;
      this.matchedKeyword = data.matched_keyword ?? null;
      this.matchedContent = data.matched_content ?? null;
    }
    get autoModerationRule() {
      return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get user() {
      return this.guild.client.users.cache.get(this.userId) ?? null;
    }
    get member() {
      return this.guild.members.cache.get(this.userId) ?? null;
    }
  }
  module.exports = AutoModerationActionExecution;
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS((exports, module) => {
  var Action = require_Action();
  var AutoModerationActionExecution = require_AutoModerationActionExecution();
  var Events = require_Events();

  class AutoModerationActionExecutionAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        client.emit(Events.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
      }
      return {};
    }
  }
  module.exports = AutoModerationActionExecutionAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleCreateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleCreate, autoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleCreateAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleDeleteAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
        if (autoModerationRule) {
          guild.autoModerationRules.cache.delete(autoModerationRule.id);
          client.emit(Events.AutoModerationRuleDelete, autoModerationRule);
        }
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleDeleteAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleUpdateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
        const newAutoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleUpdateAction;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels._add(data);
      if (!existing && channel) {
        client.emit(Events.ChannelCreate, channel);
      }
      return { channel };
    }
  }
  module.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels._remove(channel.id);
        client.emit(Events.ChannelDelete, channel);
      }
    }
  }
  module.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var GuildChannel = require_GuildChannel();

  class CategoryChannelChildManager extends DataManager {
    constructor(channel) {
      super(channel.client, GuildChannel);
      this.channel = channel;
    }
    get cache() {
      return this.guild.channels.cache.filter((channel) => channel.parentId === this.channel.id);
    }
    get guild() {
      return this.channel.guild;
    }
    create(options) {
      return this.guild.channels.create({
        ...options,
        parent: this.channel.id
      });
    }
  }
  module.exports = CategoryChannelChildManager;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannelChildManager = require_CategoryChannelChildManager();

  class CategoryChannel extends GuildChannel {
    get children() {
      return new CategoryChannelChildManager(this);
    }
  }
  module.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { flatten } = require_Util();

  class Collector extends EventEmitter {
    constructor(client, options = {}) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.filter = options.filter ?? (() => true);
      this.options = options;
      this.collected = new Collection;
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this._endReason = null;
      if (typeof this.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.filter", "function");
      }
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
      if (options.idle)
        this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      this.lastCollectedTimestamp = null;
    }
    get lastCollectedAt() {
      return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(...args) {
      const collectedId = await this.collect(...args);
      if (collectedId) {
        const filterResult = await this.filter(...args, this.collected);
        if (filterResult) {
          this.collected.set(collectedId, args[0]);
          this.emit("collect", ...args);
          this.lastCollectedTimestamp = Date.now();
          if (this._idletimeout) {
            clearTimeout2(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        } else {
          this.emit("ignore", ...args);
        }
      }
      this.checkEnd();
    }
    async handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = null;
      }
      this._endReason = reason;
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
      }
    }
    checkEnd() {
      const reason = this.endReason;
      if (reason)
        this.stop(reason);
      return Boolean(reason);
    }
    async* [Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (...item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return flatten(this);
    }
    get endReason() {
      return this._endReason;
    }
    collect() {}
    dispose() {}
  }
  module.exports = Collector;
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class InteractionCollector extends Collector {
    constructor(client, options = {}) {
      super(client, options);
      this.messageId = options.message?.id ?? options.interactionResponse?.interaction.message?.id ?? null;
      this.messageInteractionId = options.interactionResponse?.id ?? null;
      this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
      this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
      this.interactionType = options.interactionType ?? null;
      this.componentType = options.componentType ?? null;
      this.users = new Collection;
      this.total = 0;
      this.client.incrementMaxListeners();
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.messageId))
          this.stop("messageDelete");
      };
      if (this.messageId || this.messageInteractionId) {
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        this.client.on(Events.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      }
      if (this.channelId) {
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      }
      if (this.guildId) {
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      }
      this.client.on(Events.InteractionCreate, this.handleCollect);
      this.once("end", () => {
        this.client.removeListener(Events.InteractionCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (interaction) => {
        this.total++;
        this.users.set(interaction.user.id, interaction.user);
      });
    }
    collect(interaction) {
      if (this.interactionType && interaction.type !== this.interactionType)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    dispose(interaction) {
      if (this.type && interaction.type !== this.type)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
        return "componentLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.messageId) {
        this.stop("messageDelete");
      }
      if (message.interactionMetadata?.id === this.messageInteractionId) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.guildId) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = InteractionCollector;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports, module) => {
  var Collector = require_Collector();
  var Events = require_Events();

  class MessageCollector extends Collector {
    constructor(channel, options = {}) {
      super(channel.client, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageCreate, this.handleCollect);
      this.client.on(Events.MessageDelete, this.handleDispose);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this.handleDispose);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channelId !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channelId === this.channel.id ? message.id : null;
    }
    get endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return super.endReason;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channel.id) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.channel.guild?.id) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = MessageCollector;
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class GuildScheduledEvent extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.guildId = data.guild_id;
      this._patch(data);
    }
    _patch(data) {
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      } else {
        this.creatorId ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("scheduled_start_time" in data) {
        this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
      } else {
        this.scheduledStartTimestamp ??= null;
      }
      if ("scheduled_end_time" in data) {
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
      } else {
        this.scheduledEndTimestamp ??= null;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      } else {
        this.privacyLevel ??= null;
      }
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= null;
      }
      if ("entity_type" in data) {
        this.entityType = data.entity_type;
      } else {
        this.entityType ??= null;
      }
      if ("entity_id" in data) {
        this.entityId = data.entity_id;
      } else {
        this.entityId ??= null;
      }
      if ("user_count" in data) {
        this.userCount = data.user_count;
      } else {
        this.userCount ??= null;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      } else {
        this.creator ??= this.client.users.resolve(this.creatorId);
      }
      if ("entity_metadata" in data) {
        if (data.entity_metadata) {
          this.entityMetadata = {
            location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
          };
        } else {
          this.entityMetadata = null;
        }
      } else {
        this.entityMetadata ??= null;
      }
      if ("image" in data) {
        this.image = data.image;
      } else {
        this.image ??= null;
      }
      if ("recurrence_rule" in data) {
        this.recurrenceRule = data.recurrence_rule && {
          startTimestamp: Date.parse(data.recurrence_rule.start),
          get startAt() {
            return new Date(this.startTimestamp);
          },
          endTimestamp: data.recurrence_rule.end && Date.parse(data.recurrence_rule.end),
          get endAt() {
            return this.endTimestamp && new Date(this.endTimestamp);
          },
          frequency: data.recurrence_rule.frequency,
          interval: data.recurrence_rule.interval,
          byWeekday: data.recurrence_rule.by_weekday,
          byNWeekday: data.recurrence_rule.by_n_weekday,
          byMonth: data.recurrence_rule.by_month,
          byMonthDay: data.recurrence_rule.by_month_day,
          byYearDay: data.recurrence_rule.by_year_day,
          count: data.recurrence_rule.count
        };
      } else {
        this.recurrenceRule ??= null;
      }
    }
    get partial() {
      return this.name === null;
    }
    coverImageURL(options = {}) {
      return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get scheduledStartAt() {
      return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
    }
    get scheduledEndAt() {
      return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
    }
    async createInviteURL(options) {
      let channelId = this.channelId;
      if (this.entityType === GuildScheduledEventEntityType.External) {
        if (!options?.channel)
          throw new DiscordjsError(ErrorCodes.InviteOptionsMissingChannel);
        channelId = this.guild.channels.resolveId(options.channel);
        if (!channelId)
          throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      }
      const invite = await this.guild.invites.create(channelId, options);
      return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
    }
    edit(options) {
      return this.guild.scheduledEvents.edit(this.id, options);
    }
    fetch(force = true) {
      return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
    }
    async delete() {
      await this.guild.scheduledEvents.delete(this.id);
      return this;
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setScheduledStartTime(scheduledStartTime, reason) {
      return this.edit({ scheduledStartTime, reason });
    }
    setScheduledEndTime(scheduledEndTime, reason) {
      return this.edit({ scheduledEndTime, reason });
    }
    setDescription(description, reason) {
      return this.edit({ description, reason });
    }
    setStatus(status, reason) {
      return this.edit({ status, reason });
    }
    setLocation(location, reason) {
      return this.edit({ entityMetadata: { location }, reason });
    }
    fetchSubscribers(options) {
      return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
    }
    toString() {
      return this.url;
    }
    isActive() {
      return this.status === GuildScheduledEventStatus.Active;
    }
    isCanceled() {
      return this.status === GuildScheduledEventStatus.Canceled;
    }
    isCompleted() {
      return this.status === GuildScheduledEventStatus.Completed;
    }
    isScheduled() {
      return this.status === GuildScheduledEventStatus.Scheduled;
    }
  }
  exports.GuildScheduledEvent = GuildScheduledEvent;
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class Application extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
    }
    coverURL(options = {}) {
      return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Application;
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports, module) => {
  var Application = require_Application();

  class IntegrationApplication extends Application {
    _patch(data) {
      super._patch(data);
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("hook" in data) {
        this.hook = data.hook;
      } else {
        this.hook ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
  }
  module.exports = IntegrationApplication;
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();

  class InviteStageInstance extends Base {
    constructor(client, data, channelId, guildId) {
      super(client);
      this.channelId = channelId;
      this.guildId = guildId;
      this.members = new Collection;
      this._patch(data);
    }
    _patch(data) {
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("participant_count" in data) {
        this.participantCount = data.participant_count;
      }
      if ("speaker_count" in data) {
        this.speakerCount = data.speaker_count;
      }
      this.members.clear();
      for (const rawMember of data.members) {
        const member = this.guild.members._add(rawMember);
        this.members.set(member.id, member);
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
  }
  module.exports = InviteStageInstance;
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GuildFeature } = require_v106();
  var Base = require_Base();

  class BaseGuild extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.features = data.features;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    get partnered() {
      return this.features.includes(GuildFeature.Partnered);
    }
    get verified() {
      return this.features.includes(GuildFeature.Verified);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guild(this.id), {
        query: makeURLSearchParams({ with_counts: true })
      });
      return this.client.guilds._add(data);
    }
    toString() {
      return this.name;
    }
  }
  module.exports = BaseGuild;
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();

  class AnonymousGuild extends BaseGuild {
    constructor(client, data, immediatePatch = true) {
      super(client, data);
      if (immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("features" in data)
        this.features = data.features;
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("verification_level" in data) {
        this.verificationLevel = data.verification_level;
      }
      if ("vanity_url_code" in data) {
        this.vanityURLCode = data.vanity_url_code;
      }
      if ("nsfw_level" in data) {
        this.nsfwLevel = data.nsfw_level;
      }
      if ("premium_subscription_count" in data) {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      } else {
        this.premiumSubscriptionCount ??= null;
      }
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
  }
  module.exports = AnonymousGuild;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports) => {
  var process2 = __require("node:process");
  var { formatEmoji } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var deprecationEmittedForURL = false;

  class Emoji extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated ?? null;
      this.name = emoji.name ?? null;
      this.id = emoji.id ?? null;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    imageURL(options) {
      return this.id && this.client.rest.cdn.emoji(this.id, options);
    }
    get url() {
      if (!deprecationEmittedForURL) {
        process2.emitWarning("The Emoji#url getter is deprecated. Use Emoji#imageURL() instead.", "DeprecationWarning");
        deprecationEmittedForURL = true;
      }
      return this.imageURL({ extension: this.animated ? "gif" : "png" });
    }
    get createdTimestamp() {
      return this.id && DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return this.id && new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? formatEmoji({ animated: this.animated, id: this.id, name: this.name }) : this.name;
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        createdTimestamp: true,
        identifier: true
      });
      json.imageURL = this.imageURL();
      return json;
    }
  }
  exports.Emoji = Emoji;
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS((exports, module) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class WelcomeChannel extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description;
      this._emoji = {
        name: data.emoji_name,
        id: data.emoji_id
      };
      this.channelId = data.channel_id;
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get emoji() {
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  module.exports = WelcomeChannel;
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { GuildFeature } = require_v106();
  var Base = require_Base();
  var WelcomeChannel = require_WelcomeChannel();

  class WelcomeScreen extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description ?? null;
      this.welcomeChannels = new Collection;
      for (const channel of data.welcome_channels) {
        const welcomeChannel = new WelcomeChannel(this.guild, channel);
        this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
      }
    }
    get enabled() {
      return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
    }
  }
  module.exports = WelcomeScreen;
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS((exports, module) => {
  var AnonymousGuild = require_AnonymousGuild();
  var WelcomeScreen = require_WelcomeScreen();

  class InviteGuild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data);
      this.welcomeScreen = data.welcome_screen !== undefined ? new WelcomeScreen(this, data.welcome_screen) : null;
    }
  }
  module.exports = InviteGuild;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports, module) => {
  var { RouteBases, Routes, PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var IntegrationApplication = require_IntegrationApplication();
  var InviteStageInstance = require_InviteStageInstance();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class Invite extends Base {
    static InvitesPattern = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this._patch(data);
    }
    _patch(data) {
      const InviteGuild = require_InviteGuild();
      this.guild ??= null;
      if (data.guild) {
        this.guild = this.client.guilds.cache.get(data.guild.id) ?? new InviteGuild(this.client, data.guild);
      }
      if ("code" in data) {
        this.code = data.code;
      }
      if ("approximate_presence_count" in data) {
        this.presenceCount = data.approximate_presence_count;
      } else {
        this.presenceCount ??= null;
      }
      if ("approximate_member_count" in data) {
        this.memberCount = data.approximate_member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("temporary" in data) {
        this.temporary = data.temporary ?? null;
      } else {
        this.temporary ??= null;
      }
      if ("max_age" in data) {
        this.maxAge = data.max_age;
      } else {
        this.maxAge ??= null;
      }
      if ("uses" in data) {
        this.uses = data.uses;
      } else {
        this.uses ??= null;
      }
      if ("max_uses" in data) {
        this.maxUses = data.max_uses;
      } else {
        this.maxUses ??= null;
      }
      if ("inviter_id" in data) {
        this.inviterId = data.inviter_id;
      } else {
        this.inviterId ??= null;
      }
      if ("inviter" in data) {
        this.client.users._add(data.inviter);
        this.inviterId = data.inviter.id;
      }
      if ("target_user" in data) {
        this.targetUser = this.client.users._add(data.target_user);
      } else {
        this.targetUser ??= null;
      }
      if ("target_application" in data) {
        this.targetApplication = new IntegrationApplication(this.client, data.target_application);
      } else {
        this.targetApplication ??= null;
      }
      if ("target_type" in data) {
        this.targetType = data.target_type;
      } else {
        this.targetType ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("channel" in data) {
        this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
        this.channelId ??= data.channel.id;
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      } else {
        this.createdTimestamp ??= null;
      }
      if ("expires_at" in data) {
        this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
      } else {
        this._expiresTimestamp ??= null;
      }
      if ("stage_instance" in data) {
        this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
      } else {
        this.stageInstance ??= null;
      }
      if ("guild_scheduled_event" in data) {
        this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
      } else {
        this.guildScheduledEvent ??= null;
      }
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return Boolean(this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild));
    }
    get expiresTimestamp() {
      return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);
    }
    get expiresAt() {
      return this.expiresTimestamp && new Date(this.expiresTimestamp);
    }
    get inviter() {
      return this.inviterId && this.client.users.resolve(this.inviterId);
    }
    get url() {
      return `${RouteBases.invite}/${this.code}`;
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.invite(this.code), { reason });
      return this;
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelId",
        inviter: "inviterId",
        guild: "guildId"
      });
    }
    valueOf() {
      return this.code;
    }
  }
  module.exports = Invite;
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { RouteBases, Routes } = require_v106();
  var Base = require_Base();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();

  class GuildTemplate extends Base {
    static GuildTemplatesPattern = /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      if ("code" in data) {
        this.code = data.code;
      }
      if ("name" in data) {
        this.name = data.name;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("usage_count" in data) {
        this.usageCount = data.usage_count;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      }
      if ("updated_at" in data) {
        this.updatedTimestamp = Date.parse(data.updated_at);
      }
      if ("source_guild_id" in data) {
        this.guildId = data.source_guild_id;
      }
      if ("serialized_source_guild" in data) {
        this.serializedGuild = data.serialized_source_guild;
      }
      this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const { client } = this;
      const data = await client.rest.post(Routes.template(this.code), {
        body: {
          name,
          icon: await resolveImage(icon)
        }
      });
      if (client.guilds.cache.has(data.id))
        return client.guilds.cache.get(data.id);
      return new Promise((resolve) => {
        const resolveGuild = (guild) => {
          client.off(Events.GuildCreate, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
      });
    }
    async edit({ name, description } = {}) {
      const data = await this.client.rest.patch(Routes.guildTemplate(this.guildId, this.code), {
        body: { name, description }
      });
      return this._patch(data);
    }
    async delete() {
      await this.client.rest.delete(Routes.guildTemplate(this.guildId, this.code));
      return this;
    }
    async sync() {
      const data = await this.client.rest.put(Routes.guildTemplate(this.guildId, this.code));
      return this._patch(data);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get updatedAt() {
      return new Date(this.updatedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  }
  module.exports = GuildTemplate;
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var fs = __require("node:fs/promises");
  var path = __require("node:path");
  var { fetch: fetch2 } = require_undici();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();
  function resolveCode(data, regex) {
    return regex.exec(data)?.[1] ?? data;
  }
  function resolveInviteCode(data) {
    return resolveCode(data, Invite.InvitesPattern);
  }
  function resolveGuildTemplateCode(data) {
    const GuildTemplate = require_GuildTemplate();
    return resolveCode(data, GuildTemplate.GuildTemplatesPattern);
  }
  async function resolveFile(resource) {
    if (Buffer2.isBuffer(resource))
      return { data: resource };
    if (typeof resource[Symbol.asyncIterator] === "function") {
      const buffers = [];
      for await (const data of resource)
        buffers.push(Buffer2.from(data));
      return { data: Buffer2.concat(buffers) };
    }
    if (typeof resource === "string") {
      if (/^https?:\/\//.test(resource)) {
        const res = await fetch2(resource);
        return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
      }
      const file = path.resolve(resource);
      const stats = await fs.stat(file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.FileNotFound, file);
      return { data: await fs.readFile(file) };
    }
    throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
  }
  function resolveBase64(data, contentType = "image/jpg") {
    if (Buffer2.isBuffer(data))
      return `data:${contentType};base64,${data.toString("base64")}`;
    return data;
  }
  async function resolveImage(image) {
    if (!image)
      return null;
    if (typeof image === "string" && image.startsWith("data:")) {
      return image;
    }
    const file = await resolveFile(image);
    return resolveBase64(file.data);
  }
  module.exports = { resolveCode, resolveInviteCode, resolveGuildTemplateCode, resolveImage, resolveBase64, resolveFile };
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS((exports, module) => {
  var { MessageFlags } = require_v106();
  var BitField = require_BitField();

  class MessageFlagsBitField extends BitField {
    static Flags = MessageFlags;
  }
  module.exports = MessageFlagsBitField;
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
  var Base = require_Base();
  var { SelectMenuTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();

  class BaseInteraction extends Base {
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this.id = data.id;
      Object.defineProperty(this, "token", { value: data.token });
      this.applicationId = data.application_id;
      this.channelId = data.channel?.id ?? null;
      this.guildId = data.guild_id ?? null;
      this.user = this.client.users._add(data.user ?? data.member.user);
      this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
      this.version = data.version;
      this.appPermissions = new PermissionsBitField(data.app_permissions).freeze();
      this.memberPermissions = data.member?.permissions ? new PermissionsBitField(data.member.permissions).freeze() : null;
      this.locale = data.locale;
      this.guildLocale = data.guild_locale ?? null;
      this.entitlements = data.entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this.client.application.entitlements._add(entitlement)), new Collection);
      this.authorizingIntegrationOwners = data.authorizing_integration_owners;
      this.context = data.context ?? null;
      this.attachmentSizeLimit = data.attachment_size_limit;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get channel() {
      return this.client.channels.cache.get(this.channelId) ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    inGuild() {
      return Boolean(this.guildId && this.member);
    }
    inCachedGuild() {
      return Boolean(this.guild && this.member);
    }
    inRawGuild() {
      return Boolean(this.guildId && !this.guild && this.member);
    }
    isAutocomplete() {
      return this.type === InteractionType.ApplicationCommandAutocomplete;
    }
    isCommand() {
      return this.type === InteractionType.ApplicationCommand;
    }
    isChatInputCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
    }
    isContextMenuCommand() {
      return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
    }
    isPrimaryEntryPointCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.PrimaryEntryPoint;
    }
    isMessageComponent() {
      return this.type === InteractionType.MessageComponent;
    }
    isModalSubmit() {
      return this.type === InteractionType.ModalSubmit;
    }
    isUserContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
    }
    isMessageContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
    }
    isButton() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
    }
    isSelectMenu() {
      return this.isStringSelectMenu();
    }
    isAnySelectMenu() {
      return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
    }
    isStringSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
    }
    isUserSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
    }
    isRoleSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
    }
    isChannelSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
    }
    isMentionableSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
    }
    isRepliable() {
      return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
    }
  }
  BaseInteraction.prototype.isSelectMenu = deprecate(BaseInteraction.prototype.isSelectMenu, "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead.");
  module.exports = BaseInteraction;
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS((exports) => {
  class ApplicationRoleConnectionMetadata {
    constructor(data) {
      this.name = data.name;
      this.nameLocalizations = data.name_localizations ?? null;
      this.description = data.description;
      this.descriptionLocalizations = data.description_localizations ?? null;
      this.key = data.key;
      this.type = data.type;
    }
  }
  exports.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class TeamMember extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      if ("permissions" in data) {
        this.permissions = data.permissions;
      }
      if ("membership_state" in data) {
        this.membershipState = data.membership_state;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      }
      if ("role" in data) {
        this.role = data.role;
      }
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  }
  module.exports = TeamMember;
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TeamMember = require_TeamMember();

  class Team extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("owner_user_id" in data) {
        this.ownerId = data.owner_user_id;
      } else {
        this.ownerId ??= null;
      }
      this.members = new Collection;
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerId) ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Team;
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require_v106();
  var BaseManager = require_BaseManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ApplicationCommandPermissionsManager extends BaseManager {
    constructor(manager) {
      super(manager.client);
      this.manager = manager;
      this.guild = manager.guild ?? null;
      this.guildId = manager.guildId ?? manager.guild?.id ?? null;
      this.commandId = manager.id ?? null;
    }
    permissionsPath(guildId, commandId) {
      if (commandId) {
        return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
      }
      return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
    }
    async fetch({ guild, command } = {}) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (commandId) {
        const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
        return data2.permissions;
      }
      const data = await this.client.rest.get(this.permissionsPath(guildId));
      return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection);
    }
    async set({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      if (!commandId) {
        commandId = this.client.user.id;
      }
      const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
        body: { permissions },
        auth: false,
        headers: { Authorization: `Bearer ${token}` }
      });
      return data.permissions;
    }
    async add({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      let existingPermissions = [];
      try {
        existingPermissions = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const newPermissions = permissions.slice();
      for (const existingPermission of existingPermissions) {
        if (!newPermissions.some((newPermission) => newPermission.id === existingPermission.id)) {
          newPermissions.push(existingPermission);
        }
      }
      return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
    }
    async remove({ guild, command, users, roles, channels, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!users && !roles && !channels) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
      }
      let resolvedUserIds = [];
      if (Array.isArray(users)) {
        for (const user of users) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", user);
          resolvedUserIds.push(userId);
        }
      }
      let resolvedRoleIds = [];
      if (Array.isArray(roles)) {
        for (const role of roles) {
          if (typeof role === "string") {
            resolvedRoleIds.push(role);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", role);
          resolvedRoleIds.push(roleId);
        }
      }
      let resolvedChannelIds = [];
      if (Array.isArray(channels)) {
        for (const channel of channels) {
          if (typeof channel === "string") {
            resolvedChannelIds.push(channel);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "channels");
          const channelId = this.guild.channels.resolveId(channel);
          if (!channelId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "channels", channel);
          resolvedChannelIds.push(channelId);
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const permissions = existing.filter((perm) => {
        switch (perm.type) {
          case ApplicationCommandPermissionType.Role:
            return !resolvedRoleIds.includes(perm.id);
          case ApplicationCommandPermissionType.User:
            return !resolvedUserIds.includes(perm.id);
          case ApplicationCommandPermissionType.Channel:
            return !resolvedChannelIds.includes(perm.id);
        }
        return true;
      });
      return this.set({ guild: guildId, command: commandId, permissions, token });
    }
    async has({ guild, command, permissionId, permissionType }) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      if (!permissionId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
      }
      let resolvedId = permissionId;
      if (typeof permissionId !== "string") {
        resolvedId = this.client.users.resolveId(permissionId);
        if (!resolvedId) {
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          resolvedId = this.guild.roles.resolveId(permissionId);
        }
        if (!resolvedId) {
          resolvedId = this.guild.channels.resolveId(permissionId);
        }
        if (!resolvedId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
    }
    _validateOptions(guild, command) {
      const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
      if (!guildId)
        throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
      let commandId = this.commandId;
      if (command && !commandId) {
        commandId = this.manager.resolveId?.(command);
        if (!commandId && this.guild) {
          commandId = this.guild.commands.resolveId(command);
        }
        commandId ??= this.client.application?.commands.resolveId(command);
        if (!commandId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable", true);
        }
      }
      return { guildId, commandId };
    }
  }
  module.exports = ApplicationCommandPermissionsManager;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { ApplicationCommandOptionType } = require_v106();
  var isEqual = require_fast_deep_equal();
  var Base = require_Base();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommand extends Base {
    constructor(client, data, guild, guildId) {
      super(client);
      this.id = data.id;
      this.applicationId = data.application_id;
      this.guild = guild ?? null;
      this.guildId = guild?.id ?? guildId ?? null;
      this.permissions = new ApplicationCommandPermissionsManager(this);
      this.type = data.type;
      this.nsfw = data.nsfw ?? false;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("name_localizations" in data) {
        this.nameLocalizations = data.name_localizations;
      } else {
        this.nameLocalizations ??= null;
      }
      if ("name_localized" in data) {
        this.nameLocalized = data.name_localized;
      } else {
        this.nameLocalized ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("description_localizations" in data) {
        this.descriptionLocalizations = data.description_localizations;
      } else {
        this.descriptionLocalizations ??= null;
      }
      if ("description_localized" in data) {
        this.descriptionLocalized = data.description_localized;
      } else {
        this.descriptionLocalized ??= null;
      }
      if ("options" in data) {
        this.options = data.options.map((option) => this.constructor.transformOption(option, true));
      } else {
        this.options ??= [];
      }
      if ("default_member_permissions" in data) {
        this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField(BigInt(data.default_member_permissions)).freeze() : null;
      } else {
        this.defaultMemberPermissions ??= null;
      }
      if ("dm_permission" in data) {
        this.dmPermission = data.dm_permission;
      } else {
        this.dmPermission ??= null;
      }
      if ("integration_types" in data) {
        this.integrationTypes = data.integration_types;
      } else {
        this.integrationTypes ??= null;
      }
      if ("contexts" in data) {
        this.contexts = data.contexts;
      } else {
        this.contexts ??= null;
      }
      if ("handler" in data) {
        this.handler = data.handler;
      } else {
        this.handler ??= null;
      }
      if ("version" in data) {
        this.version = data.version;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get manager() {
      return (this.guild ?? this.client.application).commands;
    }
    edit(data) {
      return this.manager.edit(this, data, this.guildId);
    }
    setName(name) {
      return this.edit({ name });
    }
    setNameLocalizations(nameLocalizations) {
      return this.edit({ nameLocalizations });
    }
    setDescription(description) {
      return this.edit({ description });
    }
    setDescriptionLocalizations(descriptionLocalizations) {
      return this.edit({ descriptionLocalizations });
    }
    setDefaultMemberPermissions(defaultMemberPermissions) {
      return this.edit({ defaultMemberPermissions });
    }
    setDMPermission(dmPermission = true) {
      return this.edit({ dmPermission });
    }
    setOptions(options) {
      return this.edit({ options });
    }
    delete() {
      return this.manager.delete(this, this.guildId);
    }
    equals(command, enforceOptionOrder = false) {
      if (command.id && this.id !== command.id)
        return false;
      let defaultMemberPermissions = null;
      let dmPermission = command.dmPermission ?? command.dm_permission;
      if ("default_member_permissions" in command) {
        defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield : null;
      }
      if ("defaultMemberPermissions" in command) {
        defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield : null;
      }
      if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== undefined && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(command.descriptionLocalizations ?? command.description_localizations ?? {}, this.descriptionLocalizations ?? {}) || !isEqual(command.integrationTypes ?? command.integration_types ?? [], this.integrationTypes ?? []) || !isEqual(command.contexts ?? [], this.contexts ?? []) || "handler" in command && command.handler !== this.handler) {
        return false;
      }
      if (command.options) {
        return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
      }
      return true;
    }
    static optionsEqual(existing, options, enforceOptionOrder = false) {
      if (existing.length !== options.length)
        return false;
      if (enforceOptionOrder) {
        return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
      }
      const newOptions = new Map(options.map((option) => [option.name, option]));
      for (const option of existing) {
        const foundOption = newOptions.get(option.name);
        if (!foundOption || !this._optionEquals(option, foundOption))
          return false;
      }
      return true;
    }
    static _optionEquals(existing, option, enforceOptionOrder = false) {
      if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(option.descriptionLocalizations ?? option.description_localizations ?? {}, existing.descriptionLocalizations ?? {})) {
        return false;
      }
      if (existing.choices) {
        if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(choice.nameLocalizations ?? {}, option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}))) {
          return false;
        }
        if (!enforceOptionOrder) {
          const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
          for (const choice of existing.choices) {
            const foundChoice = newChoices.get(choice.name);
            if (!foundChoice || foundChoice.value !== choice.value)
              return false;
          }
        }
      }
      if (existing.channelTypes) {
        const newTypes = option.channelTypes ?? option.channel_types;
        for (const type of existing.channelTypes) {
          if (!newTypes.includes(type))
            return false;
        }
      }
      if (existing.options) {
        return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
      }
      return true;
    }
    static transformOption(option, received) {
      const channelTypesKey = received ? "channelTypes" : "channel_types";
      const minValueKey = received ? "minValue" : "min_value";
      const maxValueKey = received ? "maxValue" : "max_value";
      const minLengthKey = received ? "minLength" : "min_length";
      const maxLengthKey = received ? "maxLength" : "max_length";
      const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
      const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
      const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
      const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
      return {
        type: option.type,
        name: option.name,
        [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
        [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
        description: option.description,
        [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
        [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
        required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? undefined : false),
        autocomplete: option.autocomplete,
        choices: option.choices?.map((choice) => ({
          name: choice.name,
          [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
          [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
          value: choice.value
        })),
        options: option.options?.map((opt) => this.transformOption(opt, received)),
        [channelTypesKey]: option.channelTypes ?? option.channel_types,
        [minValueKey]: option.minValue ?? option.min_value,
        [maxValueKey]: option.maxValue ?? option.max_value,
        [minLengthKey]: option.minLength ?? option.min_length,
        [maxLengthKey]: option.maxLength ?? option.max_length
      };
    }
  }
  module.exports = ApplicationCommand;
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { Routes } = require_v106();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ApplicationCommand = require_ApplicationCommand();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommandManager extends CachedManager {
    constructor(client, iterable) {
      super(client, ApplicationCommand, iterable);
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
    _add(data, cache, guildId) {
      return super._add(data, cache, { extras: [this.guild, guildId] });
    }
    commandPath({ id, guildId } = {}) {
      if (this.guild ?? guildId) {
        if (id) {
          return Routes.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
        }
        return Routes.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
      }
      if (id) {
        return Routes.applicationCommand(this.client.application.id, id);
      }
      return Routes.applicationCommands(this.client.application.id);
    }
    async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
      if (typeof id === "object") {
        ({ guildId, cache = true, locale, withLocalizations } = id);
      } else if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const command = await this.client.rest.get(this.commandPath({ id, guildId }));
        return this._add(command, cache);
      }
      const data = await this.client.rest.get(this.commandPath({ guildId }), {
        headers: {
          "X-Discord-Locale": locale
        },
        query: makeURLSearchParams({ with_localizations: withLocalizations })
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection);
    }
    async create(command, guildId) {
      const data = await this.client.rest.post(this.commandPath({ guildId }), {
        body: this.constructor.transformCommand(command)
      });
      return this._add(data, true, guildId);
    }
    async set(commands, guildId) {
      const data = await this.client.rest.put(this.commandPath({ guildId }), {
        body: commands.map((command) => this.constructor.transformCommand(command))
      });
      return data.reduce((collection, command) => collection.set(command.id, this._add(command, true, guildId)), new Collection);
    }
    async edit(command, data, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
        body: this.constructor.transformCommand(data)
      });
      return this._add(patched, true, guildId);
    }
    async delete(command, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      await this.client.rest.delete(this.commandPath({ id, guildId }));
      const cached = this.cache.get(id);
      this.cache.delete(id);
      return cached ?? null;
    }
    static transformCommand(command) {
      if (isJSONEncodable(command))
        return command.toJSON();
      let default_member_permissions;
      if ("default_member_permissions" in command) {
        default_member_permissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
      }
      if ("defaultMemberPermissions" in command) {
        default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
      }
      return {
        name: command.name,
        name_localizations: command.nameLocalizations ?? command.name_localizations,
        description: command.description,
        nsfw: command.nsfw,
        description_localizations: command.descriptionLocalizations ?? command.description_localizations,
        type: command.type,
        options: command.options?.map((option) => ApplicationCommand.transformOption(option)),
        default_member_permissions,
        dm_permission: command.dmPermission ?? command.dm_permission,
        integration_types: command.integrationTypes ?? command.integration_types,
        contexts: command.contexts,
        handler: command.handler
      };
    }
  }
  module.exports = ApplicationCommandManager;
});

// node_modules/discord.js/src/structures/ApplicationEmoji.js
var require_ApplicationEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class ApplicationEmoji extends Emoji {
    constructor(client, data, application) {
      super(client, data);
      this.application = application;
      this.author = null;
      this.managed = null;
      this.requiresColons = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if (data.user)
        this.author = this.client.users._add(data.user);
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
    }
    fetchAuthor() {
      return this.application.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.application.emojis.edit(this.id, options);
    }
    setName(name) {
      return this.edit({ name });
    }
    async delete() {
      await this.application.emojis.delete(this.id);
      return this;
    }
    equals(other) {
      if (other instanceof ApplicationEmoji) {
        return other.animated === this.animated && other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons;
      }
      return other.id === this.id && other.name === this.name;
    }
  }
  module.exports = ApplicationEmoji;
});

// node_modules/discord.js/src/managers/ApplicationEmojiManager.js
var require_ApplicationEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ApplicationEmoji = require_ApplicationEmoji();
  var { resolveImage } = require_DataResolver();

  class ApplicationEmojiManager extends CachedManager {
    constructor(application, iterable) {
      super(application.client, ApplicationEmoji, iterable);
      this.application = application;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.application] });
    }
    async create({ attachment, name }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      const emoji = await this.client.rest.post(Routes.applicationEmojis(this.application.id), { body });
      return this._add(emoji);
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
        return this._add(emoji, cache);
      }
      const { items: data } = await this.client.rest.get(Routes.applicationEmojis(this.application.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.applicationEmoji(this.application.id, id));
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const newData = await this.client.rest.patch(Routes.applicationEmoji(this.application.id, id), {
        body: {
          name: options.name
        }
      });
      const existing = this.cache.get(id);
      if (existing) {
        existing._patch(newData);
        return existing;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const data = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
      return this._add(data).author;
    }
  }
  module.exports = ApplicationEmojiManager;
});

// node_modules/discord.js/src/structures/Entitlement.js
var require_Entitlement = __commonJS((exports) => {
  var Base = require_Base();

  class Entitlement extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("sku_id" in data) {
        this.skuId = data.sku_id;
      }
      if ("user_id" in data) {
        this.userId = data.user_id;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deleted" in data) {
        this.deleted = data.deleted;
      }
      if ("starts_at" in data) {
        this.startsTimestamp = data.starts_at ? Date.parse(data.starts_at) : null;
      } else {
        this.startsTimestamp ??= null;
      }
      if ("ends_at" in data) {
        this.endsTimestamp = data.ends_at ? Date.parse(data.ends_at) : null;
      } else {
        this.endsTimestamp ??= null;
      }
      if ("consumed" in data) {
        this.consumed = data.consumed;
      } else {
        this.consumed ??= false;
      }
    }
    get guild() {
      if (!this.guildId)
        return null;
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get startsAt() {
      return this.startsTimestamp && new Date(this.startsTimestamp);
    }
    get endsAt() {
      return this.endsTimestamp && new Date(this.endsTimestamp);
    }
    isActive() {
      return !this.deleted && (!this.endsTimestamp || this.endsTimestamp > Date.now());
    }
    isTest() {
      return this.startsTimestamp === null;
    }
    isUserSubscription() {
      return this.guildId === null;
    }
    isGuildSubscription() {
      return this.guildId !== null;
    }
    fetchUser() {
      return this.client.users.fetch(this.userId);
    }
    async consume() {
      await this.client.application.entitlements.consume(this.id);
    }
  }
  exports.Entitlement = Entitlement;
});

// node_modules/discord.js/src/managers/EntitlementManager.js
var require_EntitlementManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes, EntitlementOwnerType } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsTypeError } = require_errors2();
  var { Entitlement } = require_Entitlement();
  var { resolveSKUId } = require_Util();

  class EntitlementManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Entitlement, iterable);
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany(options);
      const { entitlement, cache, force } = options;
      const resolvedEntitlement = this.resolveId(entitlement ?? options);
      if (resolvedEntitlement) {
        return this._fetchSingle({ entitlement: resolvedEntitlement, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ entitlement, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(entitlement);
        if (existing) {
          return existing;
        }
      }
      const data = await this.client.rest.get(Routes.entitlement(this.client.application.id, entitlement));
      return this._add(data, cache);
    }
    async _fetchMany({ limit, guild, user, skus, excludeEnded, excludeDeleted, cache, before, after } = {}) {
      const query = makeURLSearchParams({
        limit,
        guild_id: guild && this.client.guilds.resolveId(guild),
        user_id: user && this.client.users.resolveId(user),
        sku_ids: skus?.map((sku) => resolveSKUId(sku)).join(","),
        exclude_ended: excludeEnded,
        exclude_deleted: excludeDeleted,
        before,
        after
      });
      const entitlements = await this.client.rest.get(Routes.entitlements(this.client.application.id), { query });
      return entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this._add(entitlement, cache)), new Collection);
    }
    async createTest({ sku, guild, user }) {
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (guild && user || !guild && !user) {
        throw new DiscordjsTypeError(ErrorCodes.EntitlementCreateInvalidOwner);
      }
      const resolved = guild ? this.client.guilds.resolveId(guild) : this.client.users.resolveId(user);
      if (!resolved) {
        const name = guild ? "guild" : "user";
        const type = guild ? "GuildResolvable" : "UserResolvable";
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, name, type);
      }
      const entitlement = await this.client.rest.post(Routes.entitlements(this.client.application.id), {
        body: {
          sku_id: skuId,
          owner_id: resolved,
          owner_type: guild ? EntitlementOwnerType.Guild : EntitlementOwnerType.User
        }
      });
      return new Entitlement(this.client, entitlement);
    }
    async deleteTest(entitlement) {
      const resolved = this.resolveId(entitlement);
      if (!resolved)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "entitlement", "EntitlementResolvable");
      await this.client.rest.delete(Routes.entitlement(this.client.application.id, resolved));
    }
    async consume(entitlementId) {
      await this.client.rest.post(Routes.consumeEntitlement(this.client.application.id, entitlementId));
    }
  }
  exports.EntitlementManager = EntitlementManager;
});

// node_modules/discord.js/src/structures/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var Base = require_Base();

  class Subscription extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.userId = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      this.skuIds = data.sku_ids;
      this.entitlementIds = data.entitlement_ids;
      this.currentPeriodStartTimestamp = Date.parse(data.current_period_start);
      this.currentPeriodEndTimestamp = Date.parse(data.current_period_end);
      this.status = data.status;
      if ("renewal_sku_ids" in data) {
        this.renewalSkuIds = data.renewal_sku_ids;
      }
      if ("canceled_at" in data) {
        this.canceledTimestamp = data.canceled_at ? Date.parse(data.canceled_at) : null;
      } else {
        this.canceledTimestamp ??= null;
      }
      if ("country" in data) {
        this.country = data.country;
      } else {
        this.country ??= null;
      }
    }
    get canceledAt() {
      return this.canceledTimestamp && new Date(this.canceledTimestamp);
    }
    get currentPeriodStartAt() {
      return new Date(this.currentPeriodStartTimestamp);
    }
    get currentPeriodEndAt() {
      return new Date(this.currentPeriodEndTimestamp);
    }
  }
  exports.Subscription = Subscription;
});

// node_modules/discord.js/src/managers/SubscriptionManager.js
var require_SubscriptionManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Subscription } = require_Subscription();
  var { resolveSKUId } = require_Util();

  class SubscriptionManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Subscription, iterable);
    }
    async fetch(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { after, before, cache, limit, sku, subscriptionId, user } = options;
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (subscriptionId) {
        const subscription = await this.client.rest.get(Routes.skuSubscription(skuId, subscriptionId));
        return this._add(subscription, cache);
      }
      const query = makeURLSearchParams({
        limit,
        user_id: this.client.users.resolveId(user) ?? undefined,
        sku_id: skuId,
        before,
        after
      });
      const subscriptions = await this.client.rest.get(Routes.skuSubscriptions(skuId), { query });
      return subscriptions.reduce((coll, subscription) => coll.set(subscription.id, this._add(subscription, cache)), new Collection);
    }
  }
  exports.SubscriptionManager = SubscriptionManager;
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS((exports, module) => {
  var { ApplicationFlags } = require_v106();
  var BitField = require_BitField();

  class ApplicationFlagsBitField extends BitField {
    static Flags = ApplicationFlags;
  }
  module.exports = ApplicationFlagsBitField;
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
  var { SKU } = require_SKU();
  var Team = require_Team();
  var Application = require_Application();
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationEmojiManager = require_ApplicationEmojiManager();
  var { EntitlementManager } = require_EntitlementManager();
  var { SubscriptionManager } = require_SubscriptionManager();
  var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();

  class ClientApplication extends Application {
    constructor(client, data) {
      super(client, data);
      this.commands = new ApplicationCommandManager(this.client);
      this.emojis = new ApplicationEmojiManager(this);
      this.entitlements = new EntitlementManager(this.client);
      this.subscriptions = new SubscriptionManager(this.client);
    }
    _patch(data) {
      super._patch(data);
      this.tags = data.tags ?? [];
      if ("install_params" in data) {
        this.installParams = {
          scopes: data.install_params.scopes,
          permissions: new PermissionsBitField(data.install_params.permissions).freeze()
        };
      } else {
        this.installParams ??= null;
      }
      if ("integration_types_config" in data) {
        this.integrationTypesConfig = Object.fromEntries(Object.entries(data.integration_types_config).map(([key, config]) => {
          let oauth2InstallParams = null;
          if (config.oauth2_install_params) {
            oauth2InstallParams = {
              scopes: config.oauth2_install_params.scopes,
              permissions: new PermissionsBitField(config.oauth2_install_params.permissions).freeze()
            };
          }
          const context = {
            oauth2InstallParams
          };
          return [key, context];
        }));
      } else {
        this.integrationTypesConfig ??= null;
      }
      if ("custom_install_url" in data) {
        this.customInstallURL = data.custom_install_url;
      } else {
        this.customInstallURL = null;
      }
      if ("flags" in data) {
        this.flags = new ApplicationFlagsBitField(data.flags).freeze();
      }
      if ("approximate_guild_count" in data) {
        this.approximateGuildCount = data.approximate_guild_count;
      } else {
        this.approximateGuildCount ??= null;
      }
      if ("approximate_user_install_count" in data) {
        this.approximateUserInstallCount = data.approximate_user_install_count;
      } else {
        this.approximateUserInstallCount ??= null;
      }
      if ("approximate_user_authorization_count" in data) {
        this.approximateUserAuthorizationCount = data.approximate_user_authorization_count;
      } else {
        this.approximateUserAuthorizationCount ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("bot_require_code_grant" in data) {
        this.botRequireCodeGrant = data.bot_require_code_grant;
      } else {
        this.botRequireCodeGrant ??= null;
      }
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("bot_public" in data) {
        this.botPublic = data.bot_public;
      } else {
        this.botPublic ??= null;
      }
      if ("interactions_endpoint_url" in data) {
        this.interactionsEndpointURL = data.interactions_endpoint_url;
      } else {
        this.interactionsEndpointURL ??= null;
      }
      if ("role_connections_verification_url" in data) {
        this.roleConnectionsVerificationURL = data.role_connections_verification_url;
      } else {
        this.roleConnectionsVerificationURL ??= null;
      }
      if ("event_webhooks_url" in data) {
        this.eventWebhooksURL = data.event_webhooks_url;
      } else {
        this.eventWebhooksURL ??= null;
      }
      if ("event_webhooks_status" in data) {
        this.eventWebhooksStatus = data.event_webhooks_status;
      } else {
        this.eventWebhooksStatus ??= null;
      }
      if ("event_webhooks_types" in data) {
        this.eventWebhooksTypes = data.event_webhooks_types;
      } else {
        this.eventWebhooksTypes ??= null;
      }
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get partial() {
      return !this.name;
    }
    async edit({
      customInstallURL,
      description,
      roleConnectionsVerificationURL,
      installParams,
      flags,
      icon,
      coverImage,
      interactionsEndpointURL,
      eventWebhooksURL,
      eventWebhooksStatus,
      eventWebhooksTypes,
      tags
    } = {}) {
      const data = await this.client.rest.patch(Routes.currentApplication(), {
        body: {
          custom_install_url: customInstallURL,
          description,
          role_connections_verification_url: roleConnectionsVerificationURL,
          install_params: installParams,
          flags: flags === undefined ? undefined : ApplicationFlagsBitField.resolve(flags),
          icon: icon && await resolveImage(icon),
          cover_image: coverImage && await resolveImage(coverImage),
          interactions_endpoint_url: interactionsEndpointURL,
          event_webhooks_url: eventWebhooksURL,
          event_webhooks_status: eventWebhooksStatus,
          event_webhooks_types: eventWebhooksTypes,
          tags
        }
      });
      this._patch(data);
      return this;
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.currentApplication());
      this._patch(data);
      return this;
    }
    async fetchRoleConnectionMetadataRecords() {
      const metadata = await this.client.rest.get(Routes.applicationRoleConnectionMetadata(this.client.user.id));
      return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async editRoleConnectionMetadataRecords(records) {
      const newRecords = await this.client.rest.put(Routes.applicationRoleConnectionMetadata(this.client.user.id), {
        body: records.map((record) => ({
          type: record.type,
          key: record.key,
          name: record.name,
          name_localizations: record.nameLocalizations,
          description: record.description,
          description_localizations: record.descriptionLocalizations
        }))
      });
      return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async fetchSKUs() {
      const skus = await this.client.rest.get(Routes.skus(this.id));
      return skus.reduce((coll, sku) => coll.set(sku.id, new SKU(this.client, sku)), new Collection);
    }
  }
  module.exports = ClientApplication;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module.exports = baseGetTag;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  module.exports = isKey;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  module.exports = getNative;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var eq = require_eq();
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var isKeyable = require__isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  var baseToString = require__baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  var castPath = require__castPath();
  var toKey = require__toKey();
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  var baseGet = require__baseGet();
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  module.exports = get;
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0])))
            return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (a[i] !== b[i])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var baseIndexOf = require__baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  function noop() {}
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseUniq;
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS((exports, module) => {
  var baseUniq = require__baseUniq();
  function uniqWith(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : undefined;
    return array && array.length ? baseUniq(array, undefined, comparator) : [];
  }
  module.exports = uniqWith;
});

// node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs3 = __commonJS((exports) => {
  var get = require_get();
  var fastDeepEqual = require_es6();
  var uniqWith = require_uniqWith();
  function _interopDefault(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  var get__default = /* @__PURE__ */ _interopDefault(get);
  var fastDeepEqual__default = /* @__PURE__ */ _interopDefault(fastDeepEqual);
  var uniqWith__default = /* @__PURE__ */ _interopDefault(uniqWith);
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var e;
  var t;
  var n;
  var r = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var o = e = {};
  function i() {
    throw new Error("setTimeout has not been defined");
  }
  __name(i, "i");
  function u() {
    throw new Error("clearTimeout has not been defined");
  }
  __name(u, "u");
  function c(e3) {
    if (t === setTimeout)
      return setTimeout(e3, 0);
    if ((t === i || !t) && setTimeout)
      return t = setTimeout, setTimeout(e3, 0);
    try {
      return t(e3, 0);
    } catch (n3) {
      try {
        return t.call(null, e3, 0);
      } catch (n4) {
        return t.call(this || r, e3, 0);
      }
    }
  }
  __name(c, "c");
  (function() {
    try {
      t = typeof setTimeout == "function" ? setTimeout : i;
    } catch (e3) {
      t = i;
    }
    try {
      n = typeof clearTimeout == "function" ? clearTimeout : u;
    } catch (e3) {
      n = u;
    }
  })();
  var l;
  var s = [];
  var f = false;
  var a = -1;
  function h() {
    f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
  }
  __name(h, "h");
  function d() {
    if (!f) {
      var e3 = c(h);
      f = true;
      for (var t3 = s.length;t3; ) {
        for (l = s, s = [];++a < t3; )
          l && l[a].run();
        a = -1, t3 = s.length;
      }
      l = null, f = false, function(e4) {
        if (n === clearTimeout)
          return clearTimeout(e4);
        if ((n === u || !n) && clearTimeout)
          return n = clearTimeout, clearTimeout(e4);
        try {
          n(e4);
        } catch (t4) {
          try {
            return n.call(null, e4);
          } catch (t5) {
            return n.call(this || r, e4);
          }
        }
      }(e3);
    }
  }
  __name(d, "d");
  function m(e3, t3) {
    (this || r).fun = e3, (this || r).array = t3;
  }
  __name(m, "m");
  function p() {}
  __name(p, "p");
  o.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n3 = 1;n3 < arguments.length; n3++)
        t3[n3 - 1] = arguments[n3];
    s.push(new m(e3, t3)), s.length !== 1 || f || c(d);
  }, m.prototype.run = function() {
    (this || r).fun.apply(null, (this || r).array);
  }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e3) {
    return [];
  }, o.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, o.cwd = function() {
    return "/";
  }, o.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, o.umask = function() {
    return 0;
  };
  var T = e;
  T.addListener;
  T.argv;
  T.binding;
  T.browser;
  T.chdir;
  T.cwd;
  T.emit;
  T.env;
  T.listeners;
  T.nextTick;
  T.off;
  T.on;
  T.once;
  T.prependListener;
  T.prependOnceListener;
  T.removeAllListeners;
  T.removeListener;
  T.title;
  T.umask;
  T.version;
  T.versions;
  var t2 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var e2 = Object.prototype.toString;
  var o2 = /* @__PURE__ */ __name(function(o3) {
    return !(t2 && o3 && typeof o3 == "object" && (Symbol.toStringTag in o3)) && e2.call(o3) === "[object Arguments]";
  }, "o");
  var n2 = /* @__PURE__ */ __name(function(t3) {
    return !!o2(t3) || t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && e2.call(t3) !== "[object Array]" && e2.call(t3.callee) === "[object Function]";
  }, "n");
  var r2 = function() {
    return o2(arguments);
  }();
  o2.isLegacyArguments = n2;
  var l2 = r2 ? o2 : n2;
  var t$1 = Object.prototype.toString;
  var o$1 = Function.prototype.toString;
  var n$1 = /^\s*(?:function)?\*/;
  var e$1 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var r$1 = Object.getPrototypeOf;
  var c2 = function() {
    if (!e$1)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (t3) {}
  }();
  var u2 = c2 ? r$1(c2) : {};
  var i2 = /* @__PURE__ */ __name(function(c3) {
    return typeof c3 == "function" && (!!n$1.test(o$1.call(c3)) || (e$1 ? r$1(c3) === u2 : t$1.call(c3) === "[object GeneratorFunction]"));
  }, "i");
  var t$2 = typeof Object.create == "function" ? function(t3, e3) {
    e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
  } : function(t3, e3) {
    if (e3) {
      t3.super_ = e3;
      var o3 = /* @__PURE__ */ __name(function() {}, "o");
      o3.prototype = e3.prototype, t3.prototype = new o3, t3.prototype.constructor = t3;
    }
  };
  var i$1 = /* @__PURE__ */ __name(function(e3) {
    return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
  }, "i$1");
  var o$2 = {};
  var u$1 = i$1;
  var f2 = l2;
  var a2 = i2;
  function c$1(e3) {
    return e3.call.bind(e3);
  }
  __name(c$1, "c$1");
  var s2 = typeof BigInt != "undefined";
  var p2 = typeof Symbol != "undefined";
  var y = p2 && Symbol.toStringTag !== undefined;
  var l$1 = typeof Uint8Array != "undefined";
  var d2 = typeof ArrayBuffer != "undefined";
  if (l$1 && y)
    var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
  var m2 = c$1(Object.prototype.toString);
  var h2 = c$1(Number.prototype.valueOf);
  var j = c$1(String.prototype.valueOf);
  var A = c$1(Boolean.prototype.valueOf);
  if (s2)
    var w = c$1(BigInt.prototype.valueOf);
  if (p2)
    var v = c$1(Symbol.prototype.valueOf);
  function O(e3, t3) {
    if (typeof e3 != "object")
      return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  }
  __name(O, "O");
  function S(e3) {
    return l$1 && y ? b(e3) !== undefined : B(e3) || k(e3) || E(e3) || D(e3) || U(e3) || P(e3) || x(e3) || I(e3) || M(e3) || z(e3) || F(e3);
  }
  __name(S, "S");
  function B(e3) {
    return l$1 && y ? b(e3) === "Uint8Array" : m2(e3) === "[object Uint8Array]" || u$1(e3) && e3.buffer !== undefined;
  }
  __name(B, "B");
  function k(e3) {
    return l$1 && y ? b(e3) === "Uint8ClampedArray" : m2(e3) === "[object Uint8ClampedArray]";
  }
  __name(k, "k");
  function E(e3) {
    return l$1 && y ? b(e3) === "Uint16Array" : m2(e3) === "[object Uint16Array]";
  }
  __name(E, "E");
  function D(e3) {
    return l$1 && y ? b(e3) === "Uint32Array" : m2(e3) === "[object Uint32Array]";
  }
  __name(D, "D");
  function U(e3) {
    return l$1 && y ? b(e3) === "Int8Array" : m2(e3) === "[object Int8Array]";
  }
  __name(U, "U");
  function P(e3) {
    return l$1 && y ? b(e3) === "Int16Array" : m2(e3) === "[object Int16Array]";
  }
  __name(P, "P");
  function x(e3) {
    return l$1 && y ? b(e3) === "Int32Array" : m2(e3) === "[object Int32Array]";
  }
  __name(x, "x");
  function I(e3) {
    return l$1 && y ? b(e3) === "Float32Array" : m2(e3) === "[object Float32Array]";
  }
  __name(I, "I");
  function M(e3) {
    return l$1 && y ? b(e3) === "Float64Array" : m2(e3) === "[object Float64Array]";
  }
  __name(M, "M");
  function z(e3) {
    return l$1 && y ? b(e3) === "BigInt64Array" : m2(e3) === "[object BigInt64Array]";
  }
  __name(z, "z");
  function F(e3) {
    return l$1 && y ? b(e3) === "BigUint64Array" : m2(e3) === "[object BigUint64Array]";
  }
  __name(F, "F");
  function T2(e3) {
    return m2(e3) === "[object Map]";
  }
  __name(T2, "T");
  function N(e3) {
    return m2(e3) === "[object Set]";
  }
  __name(N, "N");
  function W(e3) {
    return m2(e3) === "[object WeakMap]";
  }
  __name(W, "W");
  function $(e3) {
    return m2(e3) === "[object WeakSet]";
  }
  __name($, "$");
  function C(e3) {
    return m2(e3) === "[object ArrayBuffer]";
  }
  __name(C, "C");
  function V(e3) {
    return typeof ArrayBuffer != "undefined" && (C.working ? C(e3) : e3 instanceof ArrayBuffer);
  }
  __name(V, "V");
  function G(e3) {
    return m2(e3) === "[object DataView]";
  }
  __name(G, "G");
  function R(e3) {
    return typeof DataView != "undefined" && (G.working ? G(e3) : e3 instanceof DataView);
  }
  __name(R, "R");
  function J(e3) {
    return m2(e3) === "[object SharedArrayBuffer]";
  }
  __name(J, "J");
  function _(e3) {
    return typeof SharedArrayBuffer != "undefined" && (J.working ? J(e3) : e3 instanceof SharedArrayBuffer);
  }
  __name(_, "_");
  function H(e3) {
    return O(e3, h2);
  }
  __name(H, "H");
  function Z(e3) {
    return O(e3, j);
  }
  __name(Z, "Z");
  function q(e3) {
    return O(e3, A);
  }
  __name(q, "q");
  function K(e3) {
    return s2 && O(e3, w);
  }
  __name(K, "K");
  function L(e3) {
    return p2 && O(e3, v);
  }
  __name(L, "L");
  o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e3) {
    return typeof Promise != "undefined" && e3 instanceof Promise || e3 !== null && typeof e3 == "object" && typeof e3.then == "function" && typeof e3.catch == "function";
  }, o$2.isArrayBufferView = function(e3) {
    return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : S(e3) || R(e3);
  }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map != "undefined" && T2(/* @__PURE__ */ new Map), o$2.isMap = function(e3) {
    return typeof Map != "undefined" && (T2.working ? T2(e3) : e3 instanceof Map);
  }, N.working = typeof Set != "undefined" && N(/* @__PURE__ */ new Set), o$2.isSet = function(e3) {
    return typeof Set != "undefined" && (N.working ? N(e3) : e3 instanceof Set);
  }, W.working = typeof WeakMap != "undefined" && W(/* @__PURE__ */ new WeakMap), o$2.isWeakMap = function(e3) {
    return typeof WeakMap != "undefined" && (W.working ? W(e3) : e3 instanceof WeakMap);
  }, $.working = typeof WeakSet != "undefined" && $(/* @__PURE__ */ new WeakSet), o$2.isWeakSet = function(e3) {
    return $(e3);
  }, C.working = typeof ArrayBuffer != "undefined" && C(new ArrayBuffer), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer != "undefined" && J(new SharedArrayBuffer), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e3) {
    return m2(e3) === "[object AsyncFunction]";
  }, o$2.isMapIterator = function(e3) {
    return m2(e3) === "[object Map Iterator]";
  }, o$2.isSetIterator = function(e3) {
    return m2(e3) === "[object Set Iterator]";
  }, o$2.isGeneratorObject = function(e3) {
    return m2(e3) === "[object Generator]";
  }, o$2.isWebAssemblyCompiledModule = function(e3) {
    return m2(e3) === "[object WebAssembly.Module]";
  }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e3) {
    return H(e3) || Z(e3) || q(e3) || K(e3) || L(e3);
  }, o$2.isAnyArrayBuffer = function(e3) {
    return l$1 && (V(e3) || _(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(o$2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
  var Q = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var X = {};
  var Y = T;
  var ee = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0;n3 < t3.length; n3++)
      r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  };
  var te = /%[sdj%]/g;
  X.format = function(e3) {
    if (!ge(e3)) {
      for (var t3 = [], r3 = 0;r3 < arguments.length; r3++)
        t3.push(oe(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, i3 = n3.length, o3 = String(e3).replace(te, function(e4) {
      if (e4 === "%%")
        return "%";
      if (r3 >= i3)
        return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), u3 = n3[r3];r3 < i3; u3 = n3[++r3])
      le(u3) || !he(u3) ? o3 += " " + u3 : o3 += " " + oe(u3);
    return o3;
  }, X.deprecate = function(e3, t3) {
    if (Y !== undefined && Y.noDeprecation === true)
      return e3;
    if (Y === undefined)
      return function() {
        return X.deprecate(e3, t3).apply(this || Q, arguments);
      };
    var r3 = false;
    return function() {
      if (!r3) {
        if (Y.throwDeprecation)
          throw new Error(t3);
        Y.traceDeprecation ? console.trace(t3) : console.error(t3), r3 = true;
      }
      return e3.apply(this || Q, arguments);
    };
  };
  var re = {};
  var ne = /^$/;
  if (Y.env.NODE_DEBUG) {
    ie = Y.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
  }
  var ie;
  function oe(e3, t3) {
    var r3 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), ye(t3) ? r3.showHidden = t3 : t3 && X._extend(r3, t3), be(r3.showHidden) && (r3.showHidden = false), be(r3.depth) && (r3.depth = 2), be(r3.colors) && (r3.colors = false), be(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = ue), ae(r3, e3, r3.depth);
  }
  __name(oe, "oe");
  function ue(e3, t3) {
    var r3 = oe.styles[t3];
    return r3 ? "\x1B[" + oe.colors[r3][0] + "m" + e3 + "\x1B[" + oe.colors[r3][1] + "m" : e3;
  }
  __name(ue, "ue");
  function fe(e3, t3) {
    return e3;
  }
  __name(fe, "fe");
  function ae(e3, t3, r3) {
    if (e3.customInspect && t3 && we(t3.inspect) && t3.inspect !== X.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
      var n3 = t3.inspect(r3, e3);
      return ge(n3) || (n3 = ae(e3, n3, r3)), n3;
    }
    var i3 = function(e4, t4) {
      if (be(t4))
        return e4.stylize("undefined", "undefined");
      if (ge(t4)) {
        var r4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      if (de(t4))
        return e4.stylize("" + t4, "number");
      if (ye(t4))
        return e4.stylize("" + t4, "boolean");
      if (le(t4))
        return e4.stylize("null", "null");
    }(e3, t3);
    if (i3)
      return i3;
    var o3 = Object.keys(t3), u3 = function(e4) {
      var t4 = {};
      return e4.forEach(function(e5, r4) {
        t4[e5] = true;
      }), t4;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Ae(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
      return ce(t3);
    if (o3.length === 0) {
      if (we(t3)) {
        var f3 = t3.name ? ": " + t3.name : "";
        return e3.stylize("[Function" + f3 + "]", "special");
      }
      if (me(t3))
        return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
      if (je(t3))
        return e3.stylize(Date.prototype.toString.call(t3), "date");
      if (Ae(t3))
        return ce(t3);
    }
    var a3, c3 = "", s4 = false, p3 = ["{", "}"];
    (pe(t3) && (s4 = true, p3 = ["[", "]"]), we(t3)) && (c3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
    return me(t3) && (c3 = " " + RegExp.prototype.toString.call(t3)), je(t3) && (c3 = " " + Date.prototype.toUTCString.call(t3)), Ae(t3) && (c3 = " " + ce(t3)), o3.length !== 0 || s4 && t3.length != 0 ? r3 < 0 ? me(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), a3 = s4 ? function(e4, t4, r4, n4, i4) {
      for (var o4 = [], u4 = 0, f4 = t4.length;u4 < f4; ++u4)
        ke(t4, String(u4)) ? o4.push(se(e4, t4, r4, n4, String(u4), true)) : o4.push("");
      return i4.forEach(function(i5) {
        i5.match(/^\d+$/) || o4.push(se(e4, t4, r4, n4, i5, true));
      }), o4;
    }(e3, t3, r3, u3, o3) : o3.map(function(n4) {
      return se(e3, t3, r3, u3, n4, s4);
    }), e3.seen.pop(), function(e4, t4, r4) {
      var n4 = 0;
      if (e4.reduce(function(e5, t5) {
        return n4++, t5.indexOf(`
`) >= 0 && n4++, e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r4[0] + (t4 === "" ? "" : t4 + `
 `) + " " + e4.join(`,
  `) + " " + r4[1];
      return r4[0] + t4 + " " + e4.join(", ") + " " + r4[1];
    }(a3, c3, p3)) : p3[0] + c3 + p3[1];
  }
  __name(ae, "ae");
  function ce(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  }
  __name(ce, "ce");
  function se(e3, t3, r3, n3, i3, o3) {
    var u3, f3, a3;
    if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? f3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (f3 = e3.stylize("[Setter]", "special")), ke(n3, i3) || (u3 = "[" + i3 + "]"), f3 || (e3.seen.indexOf(a3.value) < 0 ? (f3 = le(r3) ? ae(e3, a3.value, null) : ae(e3, a3.value, r3 - 1)).indexOf(`
`) > -1 && (f3 = o3 ? f3.split(`
`).map(function(e4) {
      return "  " + e4;
    }).join(`
`).substr(2) : `
` + f3.split(`
`).map(function(e4) {
      return "   " + e4;
    }).join(`
`)) : f3 = e3.stylize("[Circular]", "special")), be(u3)) {
      if (o3 && i3.match(/^\d+$/))
        return f3;
      (u3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u3 = u3.substr(1, u3.length - 2), u3 = e3.stylize(u3, "name")) : (u3 = u3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u3 = e3.stylize(u3, "string"));
    }
    return u3 + ": " + f3;
  }
  __name(se, "se");
  function pe(e3) {
    return Array.isArray(e3);
  }
  __name(pe, "pe");
  function ye(e3) {
    return typeof e3 == "boolean";
  }
  __name(ye, "ye");
  function le(e3) {
    return e3 === null;
  }
  __name(le, "le");
  function de(e3) {
    return typeof e3 == "number";
  }
  __name(de, "de");
  function ge(e3) {
    return typeof e3 == "string";
  }
  __name(ge, "ge");
  function be(e3) {
    return e3 === undefined;
  }
  __name(be, "be");
  function me(e3) {
    return he(e3) && ve(e3) === "[object RegExp]";
  }
  __name(me, "me");
  function he(e3) {
    return typeof e3 == "object" && e3 !== null;
  }
  __name(he, "he");
  function je(e3) {
    return he(e3) && ve(e3) === "[object Date]";
  }
  __name(je, "je");
  function Ae(e3) {
    return he(e3) && (ve(e3) === "[object Error]" || e3 instanceof Error);
  }
  __name(Ae, "Ae");
  function we(e3) {
    return typeof e3 == "function";
  }
  __name(we, "we");
  function ve(e3) {
    return Object.prototype.toString.call(e3);
  }
  __name(ve, "ve");
  function Oe(e3) {
    return e3 < 10 ? "0" + e3.toString(10) : e3.toString(10);
  }
  __name(Oe, "Oe");
  X.debuglog = function(e3) {
    if (e3 = e3.toUpperCase(), !re[e3])
      if (ne.test(e3)) {
        var t3 = Y.pid;
        re[e3] = function() {
          var r3 = X.format.apply(X, arguments);
          console.error("%s %d: %s", e3, t3, r3);
        };
      } else
        re[e3] = function() {};
    return re[e3];
  }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e3) {
    return e3 == null;
  }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e3) {
    return typeof e3 == "symbol";
  }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e3) {
    return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === undefined;
  }, X.isBuffer = i$1;
  var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function Be() {
    var e3 = /* @__PURE__ */ new Date, t3 = [Oe(e3.getHours()), Oe(e3.getMinutes()), Oe(e3.getSeconds())].join(":");
    return [e3.getDate(), Se[e3.getMonth()], t3].join(" ");
  }
  __name(Be, "Be");
  function ke(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  __name(ke, "ke");
  X.log = function() {
    console.log("%s - %s", Be(), X.format.apply(X, arguments));
  }, X.inherits = t$2, X._extend = function(e3, t3) {
    if (!t3 || !he(t3))
      return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length;n3--; )
      e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var Ee = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
  function De(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  }
  __name(De, "De");
  X.promisify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Ee && e3[Ee]) {
      var t3;
      if (typeof (t3 = e3[Ee]) != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), i3 = [], o3 = 0;o3 < arguments.length; o3++)
        i3.push(arguments[o3]);
      i3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this || Q, i3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Ee && Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, ee(e3));
  }, X.promisify.custom = Ee, X.callbackify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0;r3 < arguments.length; r3++)
        t4.push(arguments[r3]);
      var n3 = t4.pop();
      if (typeof n3 != "function")
        throw new TypeError("The last argument must be of type Function");
      var i3 = this || Q, o3 = /* @__PURE__ */ __name(function() {
        return n3.apply(i3, arguments);
      }, "o");
      e3.apply(this || Q, t4).then(function(e4) {
        Y.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        Y.nextTick(De.bind(null, e4, o3));
      });
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, ee(e3)), t3;
  };
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  var inspect2 = X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X.TextEncoder = globalThis.TextEncoder;
  X.TextDecoder = globalThis.TextDecoder;
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var _BaseError = class _BaseError2 extends Error {
    toJSON() {
      return {
        name: this.name,
        message: this.message
      };
    }
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf(`
`))}`;
    }
  };
  __name(_BaseError, "BaseError");
  var BaseError = _BaseError;
  var _BaseConstraintError = class _BaseConstraintError2 extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        message: this.message
      };
    }
  };
  __name(_BaseConstraintError, "BaseConstraintError");
  var BaseConstraintError = _BaseConstraintError;
  var _ExpectedConstraintError = class _ExpectedConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedConstraintError, "ExpectedConstraintError");
  var ExpectedConstraintError = _ExpectedConstraintError;
  var _Result = class _Result2 {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new _Result2(true, value);
    }
    static err(error) {
      return new _Result2(false, undefined, error);
    }
  };
  __name(_Result, "Result");
  var Result = _Result;
  function whenConstraint(key, options, validator, validatorOptions) {
    return {
      run(input, parent) {
        if (!parent) {
          return Result.err(new ExpectedConstraintError("s.object(T.when)", validatorOptions?.message ?? "Validator has no parent", parent, "Validator to have a parent"));
        }
        const isKeyArray = Array.isArray(key);
        const value = isKeyArray ? key.map((k2) => get__default.default(parent, k2)) : get__default.default(parent, key);
        const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
        if (predicate) {
          return predicate(validator).run(input);
        }
        return Result.ok(input);
      }
    };
  }
  __name(whenConstraint, "whenConstraint");
  function resolveBooleanIs(options, value, isKeyArray) {
    if (options.is === undefined) {
      return isKeyArray ? !value.some((val) => !val) : Boolean(value);
    }
    if (typeof options.is === "function") {
      return options.is(value);
    }
    return value === options.is;
  }
  __name(resolveBooleanIs, "resolveBooleanIs");
  var validationEnabled = true;
  function setGlobalValidationEnabled(enabled) {
    validationEnabled = enabled;
  }
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  function getGlobalValidationEnabled() {
    return validationEnabled;
  }
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
  function getValue(valueOrFn) {
    return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
  }
  __name(getValue, "getValue");
  var _BaseValidator = class _BaseValidator2 {
    constructor(validatorOptions = {}, constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
      this.validatorOptions = validatorOptions;
    }
    setParent(parent) {
      this.parent = parent;
      return this;
    }
    optional(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(undefined, options), this.clone()], options);
    }
    nullable(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(null, options), this.clone()], options);
    }
    nullish(options = this.validatorOptions) {
      return new UnionValidator([new NullishValidator(options), this.clone()], options);
    }
    array(options = this.validatorOptions) {
      return new ArrayValidator(this.clone(), options);
    }
    set(options = this.validatorOptions) {
      return new SetValidator(this.clone(), options);
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates], this.validatorOptions);
    }
    transform(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: (input) => Result.ok(cb(input))
      }, options);
    }
    reshape(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: cb
      }, options);
    }
    default(value, options = this.validatorOptions) {
      return new DefaultValidator(this.clone(), value, options);
    }
    when(key, options, validatorOptions) {
      return this.addConstraint(whenConstraint(key, options, this, validatorOptions));
    }
    describe(description) {
      const clone = this.clone();
      clone.description = description;
      return clone;
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value, this.parent);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v2, constraint) => constraint.run(v2).unwrap(), this.handle(value).unwrap());
    }
    is(value) {
      return this.run(value).isOk();
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return getValue(this.isValidationEnabled);
    }
    get shouldRunConstraints() {
      return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.validatorOptions, this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint, validatorOptions = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = validatorOptions;
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(_BaseValidator, "BaseValidator");
  var BaseValidator = _BaseValidator;
  function isUnique(input) {
    if (input.length < 2)
      return true;
    const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
    return uniqueArray2.length === input.length;
  }
  __name(isUnique, "isUnique");
  function lessThan(a3, b2) {
    return a3 < b2;
  }
  __name(lessThan, "lessThan");
  function lessThanOrEqual(a3, b2) {
    return a3 <= b2;
  }
  __name(lessThanOrEqual, "lessThanOrEqual");
  function greaterThan(a3, b2) {
    return a3 > b2;
  }
  __name(greaterThan, "greaterThan");
  function greaterThanOrEqual(a3, b2) {
    return a3 >= b2;
  }
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  function equal(a3, b2) {
    return a3 === b2;
  }
  __name(equal, "equal");
  function notEqual(a3, b2) {
    return a3 !== b2;
  }
  __name(notEqual, "notEqual");
  function arrayLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthComparator, "arrayLengthComparator");
  function arrayLengthLessThan(value, options) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan()", expected, value, options);
  }
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  function arrayLengthLessThanOrEqual(value, options) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual()", expected, value, options);
  }
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  function arrayLengthGreaterThan(value, options) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan()", expected, value, options);
  }
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  function arrayLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  function arrayLengthEqual(value, options) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual()", expected, value, options);
  }
  __name(arrayLengthEqual, "arrayLengthEqual");
  function arrayLengthNotEqual(value, options) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual()", expected, value, options);
  }
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  function arrayLengthRange(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRange, "arrayLengthRange");
  function arrayLengthRangeInclusive(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  function arrayLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
  function uniqueArray(options) {
    return {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique()", options?.message ?? "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
  }
  __name(uniqueArray, "uniqueArray");
  var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = _CombinedPropertyError2.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  input${property}${padding}${body}`;
      }).join(`

`);
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(_CombinedPropertyError, "CombinedPropertyError");
  var CombinedPropertyError = _CombinedPropertyError;
  var _ValidationError = class _ValidationError2 extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        message: "Unknown validation error occurred.",
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_ValidationError, "ValidationError");
  var ValidationError = _ValidationError;
  var _ArrayValidator = class _ArrayValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    unique(options = this.validatorOptions) {
      return this.addConstraint(uniqueArray(options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validator.run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_ArrayValidator, "ArrayValidator");
  var ArrayValidator = _ArrayValidator;
  function bigintComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid bigint value", input, expected));
      }
    };
  }
  __name(bigintComparator, "bigintComparator");
  function bigintLessThan(value, options) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint().lessThan()", expected, value, options);
  }
  __name(bigintLessThan, "bigintLessThan");
  function bigintLessThanOrEqual(value, options) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint().lessThanOrEqual()", expected, value, options);
  }
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  function bigintGreaterThan(value, options) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint().greaterThan()", expected, value, options);
  }
  __name(bigintGreaterThan, "bigintGreaterThan");
  function bigintGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint().greaterThanOrEqual()", expected, value, options);
  }
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  function bigintEqual(value, options) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint().equal()", expected, value, options);
  }
  __name(bigintEqual, "bigintEqual");
  function bigintNotEqual(value, options) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint().notEqual()", expected, value, options);
  }
  __name(bigintNotEqual, "bigintNotEqual");
  function bigintDivisibleBy(divider, options) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint().divisibleBy()", options?.message ?? "BigInt is not divisible", input, expected));
      }
    };
  }
  __name(bigintDivisibleBy, "bigintDivisibleBy");
  var _BigIntValidator = class _BigIntValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return this.addConstraint(bigintEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintNotEqual(number, options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0n, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0n, options);
    }
    divisibleBy(number, options = this.validatorOptions) {
      return this.addConstraint(bigintDivisibleBy(number, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform((value) => value < 0 ? -value : value, options);
    }
    intN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asIntN(bits, value), options);
    }
    uintN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asUintN(bits, value), options);
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint()", this.validatorOptions.message ?? "Expected a bigint primitive", value));
    }
  };
  __name(_BigIntValidator, "BigIntValidator");
  var BigIntValidator = _BigIntValidator;
  function booleanTrue(options) {
    return {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean().true()", options?.message ?? "Invalid boolean value", input, "true"));
      }
    };
  }
  __name(booleanTrue, "booleanTrue");
  function booleanFalse(options) {
    return {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean().false()", options?.message ?? "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
  }
  __name(booleanFalse, "booleanFalse");
  var _BooleanValidator = class _BooleanValidator2 extends BaseValidator {
    true(options = this.validatorOptions) {
      return this.addConstraint(booleanTrue(options));
    }
    false(options = this.validatorOptions) {
      return this.addConstraint(booleanFalse(options));
    }
    equal(value, options = this.validatorOptions) {
      return value ? this.true(options) : this.false(options);
    }
    notEqual(value, options = this.validatorOptions) {
      return value ? this.false(options) : this.true(options);
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean()", this.validatorOptions.message ?? "Expected a boolean primitive", value));
    }
  };
  __name(_BooleanValidator, "BooleanValidator");
  var BooleanValidator = _BooleanValidator;
  function dateComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Date value", input, expected));
      }
    };
  }
  __name(dateComparator, "dateComparator");
  function dateLessThan(value, options) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date().lessThan()", expected, value.getTime(), options);
  }
  __name(dateLessThan, "dateLessThan");
  function dateLessThanOrEqual(value, options) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date().lessThanOrEqual()", expected, value.getTime(), options);
  }
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  function dateGreaterThan(value, options) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date().greaterThan()", expected, value.getTime(), options);
  }
  __name(dateGreaterThan, "dateGreaterThan");
  function dateGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date().greaterThanOrEqual()", expected, value.getTime(), options);
  }
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  function dateEqual(value, options) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date().equal()", expected, value.getTime(), options);
  }
  __name(dateEqual, "dateEqual");
  function dateNotEqual(value, options) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date().notEqual()", expected, value.getTime(), options);
  }
  __name(dateNotEqual, "dateNotEqual");
  function dateInvalid(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date().invalid()", options?.message ?? "Invalid Date value", input, "expected === NaN"));
      }
    };
  }
  __name(dateInvalid, "dateInvalid");
  function dateValid(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date().valid()", options?.message ?? "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  }
  __name(dateValid, "dateValid");
  var _DateValidator = class _DateValidator2 extends BaseValidator {
    lessThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThan(new Date(date), options));
    }
    lessThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date), options));
    }
    greaterThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThan(new Date(date), options));
    }
    greaterThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date), options));
    }
    equal(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid(options) : this.addConstraint(dateEqual(resolved, options));
    }
    notEqual(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid(options) : this.addConstraint(dateNotEqual(resolved, options));
    }
    valid(options = this.validatorOptions) {
      return this.addConstraint(dateValid(options));
    }
    invalid(options = this.validatorOptions) {
      return this.addConstraint(dateInvalid(options));
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date()", this.validatorOptions.message ?? "Expected a Date", value));
    }
  };
  __name(_DateValidator, "DateValidator");
  var DateValidator = _DateValidator;
  var _ExpectedValidationError = class _ExpectedValidationError2 extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = inspect2(this.expected, newOptions).replace(/\n/g, padding);
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedValidationError, "ExpectedValidationError");
  var ExpectedValidationError = _ExpectedValidationError;
  var _InstanceValidator = class _InstanceValidator2 extends BaseValidator {
    constructor(expected, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", this.validatorOptions.message ?? "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_InstanceValidator, "InstanceValidator");
  var InstanceValidator = _InstanceValidator;
  var _LiteralValidator = class _LiteralValidator2 extends BaseValidator {
    constructor(literal, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", this.validatorOptions.message ?? "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_LiteralValidator, "LiteralValidator");
  var LiteralValidator = _LiteralValidator;
  var _NeverValidator = class _NeverValidator2 extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never()", this.validatorOptions.message ?? "Expected a value to not be passed", value));
    }
  };
  __name(_NeverValidator, "NeverValidator");
  var NeverValidator = _NeverValidator;
  var _NullishValidator = class _NullishValidator2 extends BaseValidator {
    handle(value) {
      return value === undefined || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish()", this.validatorOptions.message ?? "Expected undefined or null", value));
    }
  };
  __name(_NullishValidator, "NullishValidator");
  var NullishValidator = _NullishValidator;
  function numberComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid number value", input, expected));
      }
    };
  }
  __name(numberComparator, "numberComparator");
  function numberLessThan(value, options) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number().lessThan()", expected, value, options);
  }
  __name(numberLessThan, "numberLessThan");
  function numberLessThanOrEqual(value, options) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number().lessThanOrEqual()", expected, value, options);
  }
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  function numberGreaterThan(value, options) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number().greaterThan()", expected, value, options);
  }
  __name(numberGreaterThan, "numberGreaterThan");
  function numberGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number().greaterThanOrEqual()", expected, value, options);
  }
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  function numberEqual(value, options) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number().equal()", expected, value, options);
  }
  __name(numberEqual, "numberEqual");
  function numberNotEqual(value, options) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number().notEqual()", expected, value, options);
  }
  __name(numberNotEqual, "numberNotEqual");
  function numberInt(options) {
    return {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().int()", options?.message ?? "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
      }
    };
  }
  __name(numberInt, "numberInt");
  function numberSafeInt(options) {
    return {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().safeInt()", options?.message ?? "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
      }
    };
  }
  __name(numberSafeInt, "numberSafeInt");
  function numberFinite(options) {
    return {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().finite()", options?.message ?? "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
  }
  __name(numberFinite, "numberFinite");
  function numberNaN(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().equal(NaN)", options?.message ?? "Invalid number value", input, "expected === NaN"));
      }
    };
  }
  __name(numberNaN, "numberNaN");
  function numberNotNaN(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number().notEqual(NaN)", options?.message ?? "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  }
  __name(numberNotNaN, "numberNotNaN");
  function numberDivisibleBy(divider, options) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().divisibleBy()", options?.message ?? "Number is not divisible", input, expected));
      }
    };
  }
  __name(numberDivisibleBy, "numberDivisibleBy");
  var _NumberValidator = class _NumberValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN(options)) : this.addConstraint(numberEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN(options)) : this.addConstraint(numberNotEqual(number, options));
    }
    int(options = this.validatorOptions) {
      return this.addConstraint(numberInt(options));
    }
    safeInt(options = this.validatorOptions) {
      return this.addConstraint(numberSafeInt(options));
    }
    finite(options = this.validatorOptions) {
      return this.addConstraint(numberFinite(options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0, options);
    }
    divisibleBy(divider, options = this.validatorOptions) {
      return this.addConstraint(numberDivisibleBy(divider, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform(Math.abs, options);
    }
    sign(options = this.validatorOptions) {
      return this.transform(Math.sign, options);
    }
    trunc(options = this.validatorOptions) {
      return this.transform(Math.trunc, options);
    }
    floor(options = this.validatorOptions) {
      return this.transform(Math.floor, options);
    }
    fround(options = this.validatorOptions) {
      return this.transform(Math.fround, options);
    }
    round(options = this.validatorOptions) {
      return this.transform(Math.round, options);
    }
    ceil(options = this.validatorOptions) {
      return this.transform(Math.ceil, options);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number()", this.validatorOptions.message ?? "Expected a number primitive", value));
    }
  };
  __name(_NumberValidator, "NumberValidator");
  var NumberValidator = _NumberValidator;
  var _MissingPropertyError = class _MissingPropertyError2 extends BaseError {
    constructor(property, validatorOptions) {
      super(validatorOptions?.message ?? "A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(_MissingPropertyError, "MissingPropertyError");
  var MissingPropertyError = _MissingPropertyError;
  var _UnknownPropertyError = class _UnknownPropertyError2 extends BaseError {
    constructor(property, value, options) {
      super(options?.message ?? "Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.value, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_UnknownPropertyError, "UnknownPropertyError");
  var UnknownPropertyError = _UnknownPropertyError;
  var _DefaultValidator = class _DefaultValidator2 extends BaseValidator {
    constructor(validator, value, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
      this.defaultValue = value;
    }
    default(value, options = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = options;
      clone.defaultValue = value;
      return clone;
    }
    handle(value) {
      return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.validatorOptions, this.constraints]);
    }
  };
  __name(_DefaultValidator, "DefaultValidator");
  var DefaultValidator = _DefaultValidator;
  var _CombinedError = class _CombinedError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map((error, i3) => {
        const index = options.stylize((i3 + 1).toString(), "number");
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  ${index} ${body}`;
      }).join(`

`);
      return `${header}
  ${message}

${errors}`;
    }
  };
  __name(_CombinedError, "CombinedError");
  var CombinedError = _CombinedError;
  var _UnionValidator = class _UnionValidator2 extends BaseValidator {
    constructor(validators, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = validators;
    }
    optional(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return new _UnionValidator2([new LiteralValidator(undefined, options)], this.validatorOptions, this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return this.clone();
        if (validator.expected === null) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(undefined, options), ...this.validators], this.validatorOptions);
    }
    required(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return this.clone();
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined) {
          return new _UnionValidator2(this.validators.slice(1), this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
      }
      return this.clone();
    }
    nullable(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new LiteralValidator(null, options)], this.validatorOptions, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null)
          return this.clone();
        if (validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators], this.validatorOptions);
    }
    nullish(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new NullishValidator(options)], options, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null || validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], options, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new NullishValidator(options), ...this.validators], options);
    }
    or(...predicates) {
      return new _UnionValidator2([...this.validators, ...predicates], this.validatorOptions);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      const errors = [];
      for (const validator of this.validators) {
        const result = validator.run(value);
        if (result.isOk())
          return result;
        errors.push(result.error);
      }
      return Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_UnionValidator, "UnionValidator");
  var UnionValidator = _UnionValidator;
  var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
    constructor(shape, strategy = 0, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keys = [];
      this.requiredKeys = /* @__PURE__ */ new Map;
      this.possiblyUndefinedKeys = /* @__PURE__ */ new Map;
      this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map;
      this.shape = shape;
      this.strategy = strategy;
      switch (this.strategy) {
        case 0:
          this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
          break;
        case 1: {
          this.handleStrategy = (value) => this.handleStrictStrategy(value);
          break;
        }
        case 2:
          this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
          break;
      }
      const shapeEntries = Object.entries(shape);
      this.keys = shapeEntries.map(([key]) => key);
      for (const [key, validator] of shapeEntries) {
        if (validator instanceof UnionValidator) {
          const [possiblyLiteralOrNullishPredicate] = validator["validators"];
          if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
            if (possiblyLiteralOrNullishPredicate.expected === undefined) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof NullishValidator) {
          this.possiblyUndefinedKeys.set(key, validator);
        } else if (validator instanceof LiteralValidator) {
          if (validator.expected === undefined) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof DefaultValidator) {
          this.possiblyUndefinedKeysWithDefaults.set(key, validator);
        } else {
          this.requiredKeys.set(key, validator);
        }
      }
    }
    strict(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 1, options, this.constraints]);
    }
    ignore(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 0, options, this.constraints]);
    }
    passthrough(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 2, options, this.constraints]);
    }
    partial(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional(options)]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    required(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => {
        let validator = this.shape[key];
        if (validator instanceof UnionValidator)
          validator = validator.required(options);
        return [key, validator];
      }));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    extend(schema, options = this.validatorOptions) {
      const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    pick(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    omit(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue !== "object") {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? `Expected the value to be an object, but received ${typeOfValue} instead`, value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      for (const predicate of Object.values(this.shape)) {
        predicate.setParent(this.parent ?? value);
      }
      return this.handleStrategy(value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.shape, this.strategy, this.validatorOptions, this.constraints]);
    }
    handleIgnoreStrategy(value) {
      const errors = [];
      const finalObject = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalObject[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      if (inputEntries.size === 0) {
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
      }
      const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
      if (checkInputEntriesInsteadOfSchemaKeys) {
        for (const [key] of inputEntries) {
          const predicate = this.possiblyUndefinedKeys.get(key);
          if (predicate) {
            runPredicate(key, predicate);
          }
        }
      } else {
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
      }
      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handleStrictStrategy(value) {
      const errors = [];
      const finalResult = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalResult[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      for (const [key, predicate] of this.possiblyUndefinedKeys) {
        if (inputEntries.size === 0) {
          break;
        }
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        }
      }
      if (inputEntries.size !== 0) {
        for (const [key, value2] of inputEntries.entries()) {
          errors.push([key, new UnknownPropertyError(key, value2, this.validatorOptions)]);
        }
      }
      return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handlePassthroughStrategy(value) {
      const result = this.handleIgnoreStrategy(value);
      return result.isErr() ? result : Result.ok({ ...value, ...result.value });
    }
  };
  __name(_ObjectValidator, "ObjectValidator");
  var ObjectValidator = _ObjectValidator;
  var _PassthroughValidator = class _PassthroughValidator2 extends BaseValidator {
    handle(value) {
      return Result.ok(value);
    }
  };
  __name(_PassthroughValidator, "PassthroughValidator");
  var PassthroughValidator = _PassthroughValidator;
  var _RecordValidator = class _RecordValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (typeof value !== "object") {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected an object", value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = {};
      for (const [key, val] of Object.entries(value)) {
        const result = this.validator.run(val);
        if (result.isOk())
          transformed[key] = result.value;
        else
          errors.push([key, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_RecordValidator, "RecordValidator");
  var RecordValidator = _RecordValidator;
  var _SetValidator = class _SetValidator2 extends BaseValidator {
    constructor(validator, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!(values instanceof Set)) {
        return Result.err(new ValidationError("s.set(T)", this.validatorOptions.message ?? "Expected a set", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = /* @__PURE__ */ new Set;
      for (const value of values) {
        const result = this.validator.run(value);
        if (result.isOk())
          transformed.add(result.value);
        else
          errors.push(result.error);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_SetValidator, "SetValidator");
  var SetValidator = _SetValidator;
  var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
  function validateEmail(email) {
    if (!email)
      return false;
    const atIndex = email.indexOf("@");
    if (atIndex === -1)
      return false;
    if (atIndex > 64)
      return false;
    const domainIndex = atIndex + 1;
    if (email.includes("@", domainIndex))
      return false;
    if (email.length - domainIndex > 255)
      return false;
    let dotIndex = email.indexOf(".", domainIndex);
    if (dotIndex === -1)
      return false;
    let lastDotIndex = domainIndex;
    do {
      if (dotIndex - lastDotIndex > 63)
        return false;
      lastDotIndex = dotIndex + 1;
    } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
    if (email.length - lastDotIndex > 63)
      return false;
    return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
  }
  __name(validateEmail, "validateEmail");
  function validateEmailDomain(domain) {
    try {
      return new URL(`http://${domain}`).hostname === domain;
    } catch {
      return false;
    }
  }
  __name(validateEmailDomain, "validateEmailDomain");
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Reg = new RegExp(`^${v4Str}$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
  function isIPv4(s4) {
    return IPv4Reg.test(s4);
  }
  __name(isIPv4, "isIPv4");
  function isIPv6(s4) {
    return IPv6Reg.test(s4);
  }
  __name(isIPv6, "isIPv6");
  function isIP(s4) {
    if (isIPv4(s4))
      return 4;
    if (isIPv6(s4))
      return 6;
    return 0;
  }
  __name(isIP, "isIP");
  var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
  function validatePhoneNumber(input) {
    return phoneNumberRegex.test(input);
  }
  __name(validatePhoneNumber, "validatePhoneNumber");
  var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const verticalLine = options.stylize("|", "undefined");
      const padding = `
  ${verticalLine} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedPadding = `
  ${verticalLine} - `;
      const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
  var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
  function combinedErrorFn(...fns) {
    switch (fns.length) {
      case 0:
        return () => null;
      case 1:
        return fns[0];
      case 2: {
        const [fn0, fn1] = fns;
        return (...params) => fn0(...params) || fn1(...params);
      }
      default: {
        return (...params) => {
          for (const fn of fns) {
            const result = fn(...params);
            if (result)
              return result;
          }
          return null;
        };
      }
    }
  }
  __name(combinedErrorFn, "combinedErrorFn");
  function createUrlValidators(options, validatorOptions) {
    const fns = [];
    if (options?.allowedProtocols?.length)
      fns.push(allowedProtocolsFn(options.allowedProtocols, validatorOptions));
    if (options?.allowedDomains?.length)
      fns.push(allowedDomainsFn(options.allowedDomains, validatorOptions));
    return combinedErrorFn(...fns);
  }
  __name(createUrlValidators, "createUrlValidators");
  function allowedProtocolsFn(allowedProtocols, options) {
    return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL protocol", input, allowedProtocols);
  }
  __name(allowedProtocolsFn, "allowedProtocolsFn");
  function allowedDomainsFn(allowedDomains, options) {
    return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL domain", input, allowedDomains);
  }
  __name(allowedDomainsFn, "allowedDomainsFn");
  function stringLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid string length", input, expected));
      }
    };
  }
  __name(stringLengthComparator, "stringLengthComparator");
  function stringLengthLessThan(length, options) {
    const expected = `expected.length < ${length}`;
    return stringLengthComparator(lessThan, "s.string().lengthLessThan()", expected, length, options);
  }
  __name(stringLengthLessThan, "stringLengthLessThan");
  function stringLengthLessThanOrEqual(length, options) {
    const expected = `expected.length <= ${length}`;
    return stringLengthComparator(lessThanOrEqual, "s.string().lengthLessThanOrEqual()", expected, length, options);
  }
  __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
  function stringLengthGreaterThan(length, options) {
    const expected = `expected.length > ${length}`;
    return stringLengthComparator(greaterThan, "s.string().lengthGreaterThan()", expected, length, options);
  }
  __name(stringLengthGreaterThan, "stringLengthGreaterThan");
  function stringLengthGreaterThanOrEqual(length, options) {
    const expected = `expected.length >= ${length}`;
    return stringLengthComparator(greaterThanOrEqual, "s.string().lengthGreaterThanOrEqual()", expected, length, options);
  }
  __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
  function stringLengthEqual(length, options) {
    const expected = `expected.length === ${length}`;
    return stringLengthComparator(equal, "s.string().lengthEqual()", expected, length, options);
  }
  __name(stringLengthEqual, "stringLengthEqual");
  function stringLengthNotEqual(length, options) {
    const expected = `expected.length !== ${length}`;
    return stringLengthComparator(notEqual, "s.string().lengthNotEqual()", expected, length, options);
  }
  __name(stringLengthNotEqual, "stringLengthNotEqual");
  function stringEmail(options) {
    return {
      run(input) {
        return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().email()", options?.message ?? "Invalid email address", input, "expected to be an email address"));
      }
    };
  }
  __name(stringEmail, "stringEmail");
  function stringRegexValidator(type, expected, regex, options) {
    return {
      run(input) {
        return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, options?.message ?? "Invalid string format", input, expected));
      }
    };
  }
  __name(stringRegexValidator, "stringRegexValidator");
  function stringUrl(options, validatorOptions) {
    const validatorFn = createUrlValidators(options, validatorOptions);
    return {
      run(input) {
        let url;
        try {
          url = new URL(input);
        } catch {
          return Result.err(new ExpectedConstraintError("s.string().url()", validatorOptions?.message ?? "Invalid URL", input, "expected to match a URL"));
        }
        const validatorFnResult = validatorFn(input, url);
        if (validatorFnResult === null)
          return Result.ok(input);
        return Result.err(validatorFnResult);
      }
    };
  }
  __name(stringUrl, "stringUrl");
  function stringIp(version, options) {
    const ipVersion = version ? `v${version}` : "";
    const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
    const name = `s.string().ip${ipVersion}()`;
    const message = `Invalid IP${ipVersion} address`;
    const expected = `expected to be an IP${ipVersion} address`;
    return {
      run(input) {
        return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? message, input, expected));
      }
    };
  }
  __name(stringIp, "stringIp");
  function stringRegex(regex, options) {
    return stringRegexValidator("s.string().regex()", `expected ${regex}.test(expected) to be true`, regex, options);
  }
  __name(stringRegex, "stringRegex");
  function stringUuid({ version = 4, nullable = false } = {}, options) {
    version ?? (version = "1-5");
    const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`, "i");
    const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
    return stringRegexValidator("s.string().uuid()", expected, regex, options);
  }
  __name(stringUuid, "stringUuid");
  function stringDate(options) {
    return {
      run(input) {
        const time = Date.parse(input);
        return Number.isNaN(time) ? Result.err(new ExpectedConstraintError("s.string().date()", options?.message ?? "Invalid date string", input, "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)")) : Result.ok(input);
      }
    };
  }
  __name(stringDate, "stringDate");
  function stringPhone(options) {
    return {
      run(input) {
        return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().phone()", options?.message ?? "Invalid phone number", input, "expected to be a phone number"));
      }
    };
  }
  __name(stringPhone, "stringPhone");
  var _StringValidator = class _StringValidator2 extends BaseValidator {
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthNotEqual(length, options));
    }
    email(options = this.validatorOptions) {
      return this.addConstraint(stringEmail(options));
    }
    url(options, validatorOptions = this.validatorOptions) {
      const urlOptions = this.isUrlOptions(options);
      if (urlOptions) {
        return this.addConstraint(stringUrl(options, validatorOptions));
      }
      return this.addConstraint(stringUrl(undefined, validatorOptions));
    }
    uuid(options, validatorOptions = this.validatorOptions) {
      const stringUuidOptions = this.isStringUuidOptions(options);
      if (stringUuidOptions) {
        return this.addConstraint(stringUuid(options, validatorOptions));
      }
      return this.addConstraint(stringUuid(undefined, validatorOptions));
    }
    regex(regex, options = this.validatorOptions) {
      return this.addConstraint(stringRegex(regex, options));
    }
    date(options = this.validatorOptions) {
      return this.addConstraint(stringDate(options));
    }
    ipv4(options = this.validatorOptions) {
      return this.ip(4, options);
    }
    ipv6(options = this.validatorOptions) {
      return this.ip(6, options);
    }
    ip(version, options = this.validatorOptions) {
      return this.addConstraint(stringIp(version, options));
    }
    phone(options = this.validatorOptions) {
      return this.addConstraint(stringPhone(options));
    }
    handle(value) {
      return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string()", this.validatorOptions.message ?? "Expected a string primitive", value));
    }
    isUrlOptions(options) {
      return options?.message === undefined;
    }
    isStringUuidOptions(options) {
      return options?.message === undefined;
    }
  };
  __name(_StringValidator, "StringValidator");
  var StringValidator = _StringValidator;
  var _TupleValidator = class _TupleValidator2 extends BaseValidator {
    constructor(validators, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = [];
      this.validators = validators;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (values.length !== this.validators.length) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? `Expected an array of length ${this.validators.length}`, values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validators[i3].run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_TupleValidator, "TupleValidator");
  var TupleValidator = _TupleValidator;
  var _MapValidator = class _MapValidator2 extends BaseValidator {
    constructor(keyValidator, valueValidator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (!(value instanceof Map)) {
        return Result.err(new ValidationError("s.map(K, V)", this.validatorOptions.message ?? "Expected a map", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = /* @__PURE__ */ new Map;
      for (const [key, val] of value.entries()) {
        const keyResult = this.keyValidator.run(key);
        const valueResult = this.valueValidator.run(val);
        const { length } = errors;
        if (keyResult.isErr())
          errors.push([key, keyResult.error]);
        if (valueResult.isErr())
          errors.push([key, valueResult.error]);
        if (errors.length === length)
          transformed.set(keyResult.value, valueResult.value);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_MapValidator, "MapValidator");
  var MapValidator = _MapValidator;
  var _LazyValidator = class _LazyValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      return this.validator(values).run(values);
    }
  };
  __name(_LazyValidator, "LazyValidator");
  var LazyValidator = _LazyValidator;
  var _UnknownEnumValueError = class _UnknownEnumValueError2 extends BaseError {
    constructor(value, keys, enumMappings, validatorOptions) {
      super(validatorOptions?.message ?? "Expected the value to be one of the following enum values:");
      this.value = value;
      this.enumKeys = keys;
      this.enumMappings = enumMappings;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        value: this.value,
        enumKeys: this.enumKeys,
        enumMappings: [...this.enumMappings.entries()]
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const value = options.stylize(this.value.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
      }
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const pairs = this.enumKeys.map((key) => {
        const enumValue = this.enumMappings.get(key);
        return `${options.stylize(key, "string")} or ${options.stylize(enumValue.toString(), typeof enumValue === "number" ? "number" : "string")}`;
      }).join(padding);
      const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
      const message = options.stylize(this.message, "regexp");
      const pairsBlock = `${padding}${pairs}`;
      return `${header}
  ${message}
${pairsBlock}`;
    }
  };
  __name(_UnknownEnumValueError, "UnknownEnumValueError");
  var UnknownEnumValueError = _UnknownEnumValueError;
  var _NativeEnumValidator = class _NativeEnumValidator2 extends BaseValidator {
    constructor(enumShape, validatorOptions = {}) {
      super(validatorOptions);
      this.hasNumericElements = false;
      this.enumMapping = /* @__PURE__ */ new Map;
      this.enumShape = enumShape;
      this.enumKeys = Object.keys(enumShape).filter((key) => {
        return typeof enumShape[enumShape[key]] !== "number";
      });
      for (const key of this.enumKeys) {
        const enumValue = enumShape[key];
        this.enumMapping.set(key, enumValue);
        this.enumMapping.set(enumValue, enumValue);
        if (typeof enumValue === "number") {
          this.hasNumericElements = true;
          this.enumMapping.set(`${enumValue}`, enumValue);
        }
      }
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue === "number") {
        if (!this.hasNumericElements) {
          return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string", value));
        }
      } else if (typeOfValue !== "string") {
        return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string or number", value));
      }
      const casted = value;
      const possibleEnumValue = this.enumMapping.get(casted);
      return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping, this.validatorOptions)) : Result.ok(possibleEnumValue);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.enumShape, this.validatorOptions]);
    }
  };
  __name(_NativeEnumValidator, "NativeEnumValidator");
  var NativeEnumValidator = _NativeEnumValidator;
  function typedArrayByteLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
  function typedArrayByteLengthLessThan(value, options) {
    const expected = `expected.byteLength < ${value}`;
    return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan()", expected, value, options);
  }
  __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
  function typedArrayByteLengthLessThanOrEqual(value, options) {
    const expected = `expected.byteLength <= ${value}`;
    return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
  function typedArrayByteLengthGreaterThan(value, options) {
    const expected = `expected.byteLength > ${value}`;
    return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan()", expected, value, options);
  }
  __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
  function typedArrayByteLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.byteLength >= ${value}`;
    return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
  function typedArrayByteLengthEqual(value, options) {
    const expected = `expected.byteLength === ${value}`;
    return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
  function typedArrayByteLengthNotEqual(value, options) {
    const expected = `expected.byteLength !== ${value}`;
    return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
  function typedArrayByteLengthRange(start, endBefore, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
  function typedArrayByteLengthRangeInclusive(start, end, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
  function typedArrayByteLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
  function typedArrayLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthComparator, "typedArrayLengthComparator");
  function typedArrayLengthLessThan(value, options) {
    const expected = `expected.length < ${value}`;
    return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan()", expected, value, options);
  }
  __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
  function typedArrayLengthLessThanOrEqual(value, options) {
    const expected = `expected.length <= ${value}`;
    return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual()", expected, value, options);
  }
  __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
  function typedArrayLengthGreaterThan(value, options) {
    const expected = `expected.length > ${value}`;
    return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan()", expected, value, options);
  }
  __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
  function typedArrayLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.length >= ${value}`;
    return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
  function typedArrayLengthEqual(value, options) {
    const expected = `expected.length === ${value}`;
    return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual()", expected, value, options);
  }
  __name(typedArrayLengthEqual, "typedArrayLengthEqual");
  function typedArrayLengthNotEqual(value, options) {
    const expected = `expected.length !== ${value}`;
    return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual()", expected, value, options);
  }
  __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
  function typedArrayLengthRange(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRange, "typedArrayLengthRange");
  function typedArrayLengthRangeInclusive(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
  function typedArrayLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
  var vowels = ["a", "e", "i", "o", "u"];
  var aOrAn = /* @__PURE__ */ __name((word) => {
    return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
  }, "aOrAn");
  var TypedArrays = {
    Int8Array: (x2) => x2 instanceof Int8Array,
    Uint8Array: (x2) => x2 instanceof Uint8Array,
    Uint8ClampedArray: (x2) => x2 instanceof Uint8ClampedArray,
    Int16Array: (x2) => x2 instanceof Int16Array,
    Uint16Array: (x2) => x2 instanceof Uint16Array,
    Int32Array: (x2) => x2 instanceof Int32Array,
    Uint32Array: (x2) => x2 instanceof Uint32Array,
    Float32Array: (x2) => x2 instanceof Float32Array,
    Float64Array: (x2) => x2 instanceof Float64Array,
    BigInt64Array: (x2) => x2 instanceof BigInt64Array,
    BigUint64Array: (x2) => x2 instanceof BigUint64Array,
    TypedArray: (x2) => ArrayBuffer.isView(x2) && !(x2 instanceof DataView)
  };
  var _TypedArrayValidator = class _TypedArrayValidator2 extends BaseValidator {
    constructor(type, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.type = type;
    }
    byteLengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThan(length, options));
    }
    byteLengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length, options));
    }
    byteLengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThan(length, options));
    }
    byteLengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length, options));
    }
    byteLengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthEqual(length, options));
    }
    byteLengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthNotEqual(length, options));
    }
    byteLengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRange(start, endBefore, options));
    }
    byteLengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt, options));
    }
    byteLengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore, options));
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.type, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray()", this.validatorOptions.message ?? `Expected ${aOrAn(this.type)}`, value));
    }
  };
  __name(_TypedArrayValidator, "TypedArrayValidator");
  var TypedArrayValidator = _TypedArrayValidator;
  var _Shapes = class _Shapes2 {
    string(options) {
      return new StringValidator(options);
    }
    number(options) {
      return new NumberValidator(options);
    }
    bigint(options) {
      return new BigIntValidator(options);
    }
    boolean(options) {
      return new BooleanValidator(options);
    }
    date(options) {
      return new DateValidator(options);
    }
    object(shape, options) {
      return new ObjectValidator(shape, 0, options);
    }
    undefined(options) {
      return this.literal(undefined, { equalsOptions: options });
    }
    null(options) {
      return this.literal(null, { equalsOptions: options });
    }
    nullish(options) {
      return new NullishValidator(options);
    }
    any(options) {
      return new PassthroughValidator(options);
    }
    unknown(options) {
      return new PassthroughValidator(options);
    }
    never(options) {
      return new NeverValidator(options);
    }
    enum(values, options) {
      return this.union(values.map((value) => this.literal(value, { equalsOptions: options })), options);
    }
    nativeEnum(enumShape, options) {
      return new NativeEnumValidator(enumShape, options);
    }
    literal(value, options) {
      if (value instanceof Date) {
        return this.date(options?.dateOptions).equal(value, options?.equalsOptions);
      }
      return new LiteralValidator(value, options?.equalsOptions);
    }
    instance(expected, options) {
      return new InstanceValidator(expected, options);
    }
    union(validators, options) {
      return new UnionValidator(validators, options);
    }
    array(validator, options) {
      return new ArrayValidator(validator, options);
    }
    typedArray(type = "TypedArray", options) {
      return new TypedArrayValidator(type, options);
    }
    int8Array(options) {
      return this.typedArray("Int8Array", options);
    }
    uint8Array(options) {
      return this.typedArray("Uint8Array", options);
    }
    uint8ClampedArray(options) {
      return this.typedArray("Uint8ClampedArray", options);
    }
    int16Array(options) {
      return this.typedArray("Int16Array", options);
    }
    uint16Array(options) {
      return this.typedArray("Uint16Array", options);
    }
    int32Array(options) {
      return this.typedArray("Int32Array", options);
    }
    uint32Array(options) {
      return this.typedArray("Uint32Array", options);
    }
    float32Array(options) {
      return this.typedArray("Float32Array", options);
    }
    float64Array(options) {
      return this.typedArray("Float64Array", options);
    }
    bigInt64Array(options) {
      return this.typedArray("BigInt64Array", options);
    }
    bigUint64Array(options) {
      return this.typedArray("BigUint64Array", options);
    }
    tuple(validators, options) {
      return new TupleValidator(validators, options);
    }
    set(validator, options) {
      return new SetValidator(validator, options);
    }
    record(validator, options) {
      return new RecordValidator(validator, options);
    }
    map(keyValidator, valueValidator, options) {
      return new MapValidator(keyValidator, valueValidator, options);
    }
    lazy(validator, options) {
      return new LazyValidator(validator, options);
    }
  };
  __name(_Shapes, "Shapes");
  var Shapes = _Shapes;
  var s3 = new Shapes;
  exports.BaseError = BaseError;
  exports.CombinedError = CombinedError;
  exports.CombinedPropertyError = CombinedPropertyError;
  exports.ExpectedConstraintError = ExpectedConstraintError;
  exports.ExpectedValidationError = ExpectedValidationError;
  exports.MissingPropertyError = MissingPropertyError;
  exports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
  exports.Result = Result;
  exports.UnknownEnumValueError = UnknownEnumValueError;
  exports.UnknownPropertyError = UnknownPropertyError;
  exports.ValidationError = ValidationError;
  exports.customInspectSymbol = customInspectSymbol;
  exports.customInspectSymbolStackLess = customInspectSymbolStackLess;
  exports.getGlobalValidationEnabled = getGlobalValidationEnabled;
  exports.s = s3;
  exports.setGlobalValidationEnabled = setGlobalValidationEnabled;
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatten = exports.unique = exports.hardMixProtos = exports.nearestCommonProto = exports.protoChain = exports.copyProps = undefined;
  var copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
      delete props[prop];
    Object.defineProperties(dest, props);
  };
  exports.copyProps = copyProps;
  var protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return currentChain;
    return (0, exports.protoChain)(proto, [...currentChain, proto]);
  };
  exports.protoChain = protoChain;
  var nearestCommonProto = (...objs) => {
    if (objs.length === 0)
      return;
    let commonProto = undefined;
    const protoChains = objs.map((obj) => (0, exports.protoChain)(obj));
    while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
      const protos = protoChains.map((protoChain2) => protoChain2.pop());
      const potentialCommonProto = protos[0];
      if (protos.every((proto) => proto === potentialCommonProto))
        commonProto = potentialCommonProto;
      else
        break;
    }
    return commonProto;
  };
  exports.nearestCommonProto = nearestCommonProto;
  var hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = (0, exports.nearestCommonProto)(...ingredients)) !== null && _a !== undefined ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    const visitedProtos = (0, exports.protoChain)(base);
    for (let prototype of ingredients) {
      let protos = (0, exports.protoChain)(prototype);
      for (let i = protos.length - 1;i >= 0; i--) {
        let newProto = protos[i];
        if (visitedProtos.indexOf(newProto) === -1) {
          (0, exports.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
          visitedProtos.push(newProto);
        }
      }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
  };
  exports.hardMixProtos = hardMixProtos;
  var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
  exports.unique = unique;
  var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
  exports.flatten = flatten;
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.softMixProtos = exports.proxyMix = exports.getIngredientWithProp = undefined;
  var util_1 = require_util9();
  var getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
    let protoDepth = 0;
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
      protosAreLeftToSearch = false;
      for (let i = ingredients.length - 1;i >= 0; i--) {
        const searchTarget = protoChains[i][protoDepth];
        if (searchTarget !== undefined && searchTarget !== null) {
          protosAreLeftToSearch = true;
          if (Object.getOwnPropertyDescriptor(searchTarget, prop) != null) {
            return protoChains[i][0];
          }
        }
      }
      protoDepth++;
    }
    return;
  };
  exports.getIngredientWithProp = getIngredientWithProp;
  var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
      return prototype;
    },
    setPrototypeOf() {
      throw Error("Cannot set prototype of Proxies created by ts-mixer");
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor((0, exports.getIngredientWithProp)(prop, ingredients) || {}, prop);
    },
    defineProperty() {
      throw new Error("Cannot define new properties on Proxies created by ts-mixer");
    },
    has(_, prop) {
      return (0, exports.getIngredientWithProp)(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
      return ((0, exports.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
      const ingredientWithProp = (0, exports.getIngredientWithProp)(prop, ingredients);
      if (ingredientWithProp === undefined)
        throw new Error("Cannot set new properties on Proxies created by ts-mixer");
      ingredientWithProp[prop] = val;
      return true;
    },
    deleteProperty() {
      throw new Error("Cannot delete properties on Proxies created by ts-mixer");
    },
    ownKeys() {
      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
    }
  });
  exports.proxyMix = proxyMix;
  var softMixProtos = (ingredients, constructor) => (0, exports.proxyMix)([...ingredients, { constructor }]);
  exports.softMixProtos = softMixProtos;
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.settings = undefined;
  exports.settings = {
    initFunction: null,
    staticsStrategy: "copy",
    prototypeStrategy: "copy",
    decoratorInheritance: "deep"
  };
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.registerMixins = exports.getMixinsForClass = undefined;
  var util_1 = require_util9();
  var mixins = new WeakMap;
  var getMixinsForClass = (clazz) => mixins.get(clazz);
  exports.getMixinsForClass = getMixinsForClass;
  var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
  exports.registerMixins = registerMixins;
  var hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
      return true;
    const constructor = instance.constructor;
    const visited = new Set;
    let frontier = new Set;
    frontier.add(constructor);
    while (frontier.size > 0) {
      if (frontier.has(mixin))
        return true;
      frontier.forEach((item) => visited.add(item));
      const newFrontier = new Set;
      frontier.forEach((item) => {
        var _a;
        const itemConstituents = (_a = mixins.get(item)) !== null && _a !== undefined ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
        if (itemConstituents)
          itemConstituents.forEach((constituent) => {
            if (!visited.has(constituent) && !frontier.has(constituent))
              newFrontier.add(constituent);
          });
      });
      frontier = newFrontier;
    }
    return false;
  };
  exports.hasMixin = hasMixin;
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorate = exports.getDecoratorsForClass = exports.directDecoratorSearch = exports.deepDecoratorSearch = undefined;
  var util_1 = require_util9();
  var mixin_tracking_1 = require_mixin_tracking();
  var mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
      mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === undefined ? undefined : o1[key]) !== null && _a !== undefined ? _a : [], ...(_b = o2 === null || o2 === undefined ? undefined : o2[key]) !== null && _b !== undefined ? _b : []]);
    return mergedObject;
  };
  var mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return {
      property: mergeObjectsOfDecorators((_a = d1 === null || d1 === undefined ? undefined : d1.property) !== null && _a !== undefined ? _a : {}, (_b = d2 === null || d2 === undefined ? undefined : d2.property) !== null && _b !== undefined ? _b : {}),
      method: mergeObjectsOfDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.method) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.method) !== null && _d !== undefined ? _d : {})
    };
  };
  var mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      class: (0, util_1.unique)([...(_a = d1 === null || d1 === undefined ? undefined : d1.class) !== null && _a !== undefined ? _a : [], ...(_b = d2 === null || d2 === undefined ? undefined : d2.class) !== null && _b !== undefined ? _b : []]),
      static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.static) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.static) !== null && _d !== undefined ? _d : {}),
      instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === undefined ? undefined : d1.instance) !== null && _e !== undefined ? _e : {}, (_f = d2 === null || d2 === undefined ? undefined : d2.instance) !== null && _f !== undefined ? _f : {})
    };
  };
  var decorators = new Map;
  var findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set;
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
      for (let clazz of frontier) {
        const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
        const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== undefined ? _a : [];
        const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
        const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
        for (let newClass of newClasses)
          frontier.add(newClass);
        allClasses.add(clazz);
        frontier.delete(clazz);
      }
    }
    return [...allClasses];
  };
  var deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
    if (decoratorsForClassChain.length == 0)
      return {};
    if (decoratorsForClassChain.length == 1)
      return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.deepDecoratorSearch = deepDecoratorSearch;
  var directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map((clazz) => (0, exports.getDecoratorsForClass)(clazz));
    if (classDecorators.length === 0)
      return {};
    if (classDecorators.length === 1)
      return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.directDecoratorSearch = directDecoratorSearch;
  var getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
      decoratorsForClass = {};
      decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
  };
  exports.getDecoratorsForClass = getDecoratorsForClass;
  var decorateClass = (decorator) => (clazz) => {
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
      classDecorators = [];
      decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
  };
  var decorateMember = (decorator) => (object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === "function" ? "static" : "instance";
    const decoratorType = typeof object[key] === "function" ? "method" : "property";
    const clazz = decoratorTargetType === "static" ? object : object.constructor;
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === undefined ? undefined : decoratorsForClass[decoratorTargetType]) !== null && _a !== undefined ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === undefined ? undefined : decoratorsForTargetType[decoratorType]) !== null && _b !== undefined ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === undefined ? undefined : decoratorsForType[key]) !== null && _c !== undefined ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    decoratorsForKey.push(decorator);
    return decorator(object, key, ...otherArgs);
  };
  var decorate = (decorator) => (...args) => {
    if (args.length === 1)
      return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
  };
  exports.decorate = decorate;
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mix = exports.Mixin = undefined;
  var proxy_1 = require_proxy();
  var settings_1 = require_settings();
  var util_1 = require_util9();
  var decorator_1 = require_decorator();
  var mixin_tracking_1 = require_mixin_tracking();
  function Mixin(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings_1.settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        (0, util_1.copyProps)(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings_1.settings.decoratorInheritance !== "none") {
      const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.class) !== null && _a !== undefined ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.static) !== null && _b !== undefined ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.instance) !== null && _c !== undefined ? _c : {}, DecoratedMixedClass.prototype);
    }
    (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  }
  exports.Mixin = Mixin;
  var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
      for (let key in propDecorators)
        for (let decorator of propDecorators[key])
          decorator(target, key);
    if (methodDecorators)
      for (let key in methodDecorators)
        for (let decorator of methodDecorators[key])
          decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };
  var mix = (...ingredients) => (decoratedClass) => {
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, "name", {
      value: decoratedClass.name,
      writable: false
    });
    return mixedClass;
  };
  exports.mix = mix;
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.decorate = exports.settings = exports.mix = exports.Mixin = undefined;
  var mixins_1 = require_mixins();
  Object.defineProperty(exports, "Mixin", { enumerable: true, get: function() {
    return mixins_1.Mixin;
  } });
  Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
    return mixins_1.mix;
  } });
  var settings_1 = require_settings();
  Object.defineProperty(exports, "settings", { enumerable: true, get: function() {
    return settings_1.settings;
  } });
  var decorator_1 = require_decorator();
  Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
    return decorator_1.decorate;
  } });
  var mixin_tracking_1 = require_mixin_tracking();
  Object.defineProperty(exports, "hasMixin", { enumerable: true, get: function() {
    return mixin_tracking_1.hasMixin;
  } });
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist8 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? undefined : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator;i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var src_exports = {};
  __export(src_exports, {
    ActionRowBuilder: () => ActionRowBuilder,
    ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
    ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
    ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
    ApplicationCommandOptionWithAutocompleteMixin: () => ApplicationCommandOptionWithAutocompleteMixin,
    ApplicationCommandOptionWithChoicesMixin: () => ApplicationCommandOptionWithChoicesMixin,
    BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
    ButtonBuilder: () => ButtonBuilder,
    ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
    ComponentAssertions: () => Assertions_exports2,
    ComponentBuilder: () => ComponentBuilder,
    ComponentsV2Assertions: () => Assertions_exports4,
    ContainerBuilder: () => ContainerBuilder,
    ContextMenuCommandAssertions: () => Assertions_exports7,
    ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
    EmbedAssertions: () => Assertions_exports,
    EmbedBuilder: () => EmbedBuilder,
    FileBuilder: () => FileBuilder,
    MediaGalleryBuilder: () => MediaGalleryBuilder,
    MediaGalleryItemBuilder: () => MediaGalleryItemBuilder,
    MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
    ModalAssertions: () => Assertions_exports5,
    ModalBuilder: () => ModalBuilder,
    RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
    SectionBuilder: () => SectionBuilder,
    SelectMenuBuilder: () => StringSelectMenuBuilder,
    SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    SeparatorBuilder: () => SeparatorBuilder,
    SharedNameAndDescription: () => SharedNameAndDescription,
    SharedSlashCommand: () => SharedSlashCommand,
    SharedSlashCommandOptions: () => SharedSlashCommandOptions,
    SharedSlashCommandSubcommands: () => SharedSlashCommandSubcommands,
    SlashCommandAssertions: () => Assertions_exports6,
    SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
    SlashCommandBooleanOption: () => SlashCommandBooleanOption,
    SlashCommandBuilder: () => SlashCommandBuilder,
    SlashCommandChannelOption: () => SlashCommandChannelOption,
    SlashCommandIntegerOption: () => SlashCommandIntegerOption,
    SlashCommandMentionableOption: () => SlashCommandMentionableOption,
    SlashCommandNumberOption: () => SlashCommandNumberOption,
    SlashCommandRoleOption: () => SlashCommandRoleOption,
    SlashCommandStringOption: () => SlashCommandStringOption,
    SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
    SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
    SlashCommandUserOption: () => SlashCommandUserOption,
    StringSelectMenuBuilder: () => StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    TextDisplayBuilder: () => TextDisplayBuilder,
    TextInputAssertions: () => Assertions_exports3,
    TextInputBuilder: () => TextInputBuilder,
    ThumbnailBuilder: () => ThumbnailBuilder,
    UserSelectMenuBuilder: () => UserSelectMenuBuilder,
    createComponentBuilder: () => createComponentBuilder,
    disableValidators: () => disableValidators,
    embedLength: () => embedLength,
    enableValidators: () => enableValidators,
    isValidationEnabled: () => isValidationEnabled,
    normalizeArray: () => normalizeArray,
    resolveBuilder: () => resolveBuilder,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Assertions_exports = {};
  __export(Assertions_exports, {
    RGBPredicate: () => RGBPredicate,
    authorNamePredicate: () => authorNamePredicate,
    colorPredicate: () => colorPredicate,
    descriptionPredicate: () => descriptionPredicate,
    embedAuthorPredicate: () => embedAuthorPredicate,
    embedFieldPredicate: () => embedFieldPredicate,
    embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
    embedFooterPredicate: () => embedFooterPredicate,
    fieldInlinePredicate: () => fieldInlinePredicate,
    fieldLengthPredicate: () => fieldLengthPredicate,
    fieldNamePredicate: () => fieldNamePredicate,
    fieldValuePredicate: () => fieldValuePredicate,
    footerTextPredicate: () => footerTextPredicate,
    imageURLPredicate: () => imageURLPredicate,
    timestampPredicate: () => timestampPredicate,
    titlePredicate: () => titlePredicate,
    urlPredicate: () => urlPredicate,
    validateFieldLength: () => validateFieldLength
  });
  var import_shapeshift = require_cjs3();
  var validate = true;
  function enableValidators() {
    return validate = true;
  }
  __name(enableValidators, "enableValidators");
  function disableValidators() {
    return validate = false;
  }
  __name(disableValidators, "disableValidators");
  function isValidationEnabled() {
    return validate;
  }
  __name(isValidationEnabled, "isValidationEnabled");
  var fieldNamePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
  var fieldValuePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var fieldInlinePredicate = import_shapeshift.s.boolean().optional();
  var embedFieldPredicate = import_shapeshift.s.object({
    name: fieldNamePredicate,
    value: fieldValuePredicate,
    inline: fieldInlinePredicate
  }).setValidationEnabled(isValidationEnabled);
  var embedFieldsArrayPredicate = embedFieldPredicate.array().setValidationEnabled(isValidationEnabled);
  var fieldLengthPredicate = import_shapeshift.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateFieldLength(amountAdding, fields) {
    fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
  }
  __name(validateFieldLength, "validateFieldLength");
  var authorNamePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  var imageURLPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:", "attachment:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var urlPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var embedAuthorPredicate = import_shapeshift.s.object({
    name: authorNamePredicate,
    iconURL: imageURLPredicate,
    url: urlPredicate
  }).setValidationEnabled(isValidationEnabled);
  var RGBPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
  var colorPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable().setValidationEnabled(isValidationEnabled);
  var descriptionPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable().setValidationEnabled(isValidationEnabled);
  var footerTextPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable().setValidationEnabled(isValidationEnabled);
  var embedFooterPredicate = import_shapeshift.s.object({
    text: footerTextPredicate,
    iconURL: imageURLPredicate
  }).setValidationEnabled(isValidationEnabled);
  var timestampPredicate = import_shapeshift.s.union([import_shapeshift.s.number(), import_shapeshift.s.date()]).nullable().setValidationEnabled(isValidationEnabled);
  var titlePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  function normalizeArray(arr) {
    if (Array.isArray(arr[0]))
      return [...arr[0]];
    return arr;
  }
  __name(normalizeArray, "normalizeArray");
  var EmbedBuilder = class {
    static {
      __name(this, "EmbedBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = { ...data };
      if (data.timestamp)
        this.data.timestamp = new Date(data.timestamp).toISOString();
    }
    addFields(...fields) {
      const normalizedFields = normalizeArray(fields);
      validateFieldLength(normalizedFields.length, this.data.fields);
      embedFieldsArrayPredicate.parse(normalizedFields);
      if (this.data.fields)
        this.data.fields.push(...normalizedFields);
      else
        this.data.fields = normalizedFields;
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      validateFieldLength(fields.length - deleteCount, this.data.fields);
      embedFieldsArrayPredicate.parse(fields);
      if (this.data.fields)
        this.data.fields.splice(index, deleteCount, ...fields);
      else
        this.data.fields = fields;
      return this;
    }
    setFields(...fields) {
      this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
      return this;
    }
    setAuthor(options) {
      if (options === null) {
        this.data.author = undefined;
        return this;
      }
      embedAuthorPredicate.parse(options);
      this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
      return this;
    }
    setColor(color) {
      colorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.color = color ?? undefined;
      return this;
    }
    setDescription(description) {
      descriptionPredicate.parse(description);
      this.data.description = description ?? undefined;
      return this;
    }
    setFooter(options) {
      if (options === null) {
        this.data.footer = undefined;
        return this;
      }
      embedFooterPredicate.parse(options);
      this.data.footer = { text: options.text, icon_url: options.iconURL };
      return this;
    }
    setImage(url) {
      imageURLPredicate.parse(url);
      this.data.image = url ? { url } : undefined;
      return this;
    }
    setThumbnail(url) {
      imageURLPredicate.parse(url);
      this.data.thumbnail = url ? { url } : undefined;
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      timestampPredicate.parse(timestamp);
      this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : undefined;
      return this;
    }
    setTitle(title) {
      titlePredicate.parse(title);
      this.data.title = title ?? undefined;
      return this;
    }
    setURL(url) {
      urlPredicate.parse(url);
      this.data.url = url ?? undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  __reExport(src_exports, require_dist7(), module.exports);
  var Assertions_exports2 = {};
  __export(Assertions_exports2, {
    buttonLabelValidator: () => buttonLabelValidator,
    buttonStyleValidator: () => buttonStyleValidator,
    channelTypesValidator: () => channelTypesValidator,
    customIdValidator: () => customIdValidator,
    defaultValidator: () => defaultValidator,
    disabledValidator: () => disabledValidator,
    emojiValidator: () => emojiValidator,
    idValidator: () => idValidator,
    jsonOptionValidator: () => jsonOptionValidator,
    labelValueDescriptionValidator: () => labelValueDescriptionValidator,
    minMaxValidator: () => minMaxValidator,
    optionValidator: () => optionValidator,
    optionsLengthValidator: () => optionsLengthValidator,
    optionsValidator: () => optionsValidator,
    placeholderValidator: () => placeholderValidator,
    urlValidator: () => urlValidator,
    validateRequiredButtonParameters: () => validateRequiredButtonParameters,
    validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
    validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
  });
  var import_shapeshift2 = require_cjs3();
  var import_v10 = require_v106();
  var StringSelectMenuOptionBuilder = class {
    constructor(data = {}) {
      this.data = data;
    }
    static {
      __name(this, "StringSelectMenuOptionBuilder");
    }
    setLabel(label) {
      this.data.label = labelValueDescriptionValidator.parse(label);
      return this;
    }
    setValue(value) {
      this.data.value = labelValueDescriptionValidator.parse(value);
      return this;
    }
    setDescription(description) {
      this.data.description = labelValueDescriptionValidator.parse(description);
      return this;
    }
    setDefault(isDefault = true) {
      this.data.default = defaultValidator.parse(isDefault);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
      return {
        ...this.data
      };
    }
  };
  var idValidator = import_shapeshift2.s.number().safeInt().greaterThanOrEqual(1).lessThan(4294967296).setValidationEnabled(isValidationEnabled);
  var customIdValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var emojiValidator = import_shapeshift2.s.object({
    id: import_shapeshift2.s.string(),
    name: import_shapeshift2.s.string(),
    animated: import_shapeshift2.s.boolean()
  }).partial().strict().setValidationEnabled(isValidationEnabled);
  var disabledValidator = import_shapeshift2.s.boolean();
  var buttonLabelValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
  var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
  var placeholderValidator = import_shapeshift2.s.string().lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
  var minMaxValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  var labelValueDescriptionValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var jsonOptionValidator = import_shapeshift2.s.object({
    label: labelValueDescriptionValidator,
    value: labelValueDescriptionValidator,
    description: labelValueDescriptionValidator.optional(),
    emoji: emojiValidator.optional(),
    default: import_shapeshift2.s.boolean().optional()
  }).setValidationEnabled(isValidationEnabled);
  var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
  var optionsValidator = optionValidator.array().lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
  var optionsLengthValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateRequiredSelectMenuParameters(options, customId) {
    customIdValidator.parse(customId);
    optionsValidator.parse(options);
  }
  __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
  var defaultValidator = import_shapeshift2.s.boolean();
  function validateRequiredSelectMenuOptionParameters(label, value) {
    labelValueDescriptionValidator.parse(label);
    labelValueDescriptionValidator.parse(value);
  }
  __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
  var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array().setValidationEnabled(isValidationEnabled);
  var urlValidator = import_shapeshift2.s.string().url({
    allowedProtocols: ["http:", "https:", "discord:"]
  }).setValidationEnabled(isValidationEnabled);
  function validateRequiredButtonParameters(style, label, emoji, customId, skuId, url) {
    if (style === import_v10.ButtonStyle.Premium) {
      if (!skuId) {
        throw new RangeError("Premium buttons must have an SKU id.");
      }
      if (customId || label || url || emoji) {
        throw new RangeError("Premium buttons cannot have a custom id, label, URL, or emoji.");
      }
    } else {
      if (skuId) {
        throw new RangeError("Non-premium buttons must not have an SKU id.");
      }
      if (url && customId) {
        throw new RangeError("URL and custom id are mutually exclusive.");
      }
      if (!label && !emoji) {
        throw new RangeError("Non-premium buttons must have a label and/or an emoji.");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url) {
          throw new RangeError("Link buttons must have a URL.");
        }
      } else if (url) {
        throw new RangeError("Non-premium and non-link buttons cannot have a URL.");
      }
    }
  }
  __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
  var import_v1019 = require_v106();
  var ComponentBuilder = class {
    static {
      __name(this, "ComponentBuilder");
    }
    data;
    constructor(data) {
      this.data = data;
    }
    setId(id) {
      this.data.id = idValidator.parse(id);
      return this;
    }
    clearId() {
      this.data.id = undefined;
      return this;
    }
  };
  var import_v1018 = require_v106();
  var import_v102 = require_v106();
  var ButtonBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ButtonBuilder");
    }
    constructor(data) {
      super({ type: import_v102.ComponentType.Button, ...data });
    }
    setStyle(style) {
      this.data.style = buttonStyleValidator.parse(style);
      return this;
    }
    setURL(url) {
      this.data.url = urlValidator.parse(url);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setSKUId(skuId) {
      this.data.sku_id = skuId;
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    setLabel(label) {
      this.data.label = buttonLabelValidator.parse(label);
      return this;
    }
    toJSON() {
      validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.sku_id, this.data.url);
      return {
        ...this.data
      };
    }
  };
  var import_v103 = require_v106();
  var BaseSelectMenuBuilder = class extends ComponentBuilder {
    static {
      __name(this, "BaseSelectMenuBuilder");
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator.parse(placeholder);
      return this;
    }
    setMinValues(minValues) {
      this.data.min_values = minMaxValidator.parse(minValues);
      return this;
    }
    setMaxValues(maxValues) {
      this.data.max_values = minMaxValidator.parse(maxValues);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "ChannelSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v103.ComponentType.ChannelSelect });
    }
    addChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    setChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    addDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      })));
      return this;
    }
    setDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      }));
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var import_v104 = require_v106();
  var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "MentionableSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v104.ComponentType.MentionableSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    addDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues);
      return this;
    }
    setDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues;
      return this;
    }
  };
  var import_v105 = require_v106();
  var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "RoleSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v105.ComponentType.RoleSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    setDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      }));
      return this;
    }
  };
  var import_v106 = require_v106();
  var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "StringSelectMenuBuilder");
    }
    options;
    constructor(data) {
      const { options, ...initData } = data ?? {};
      super({ ...initData, type: import_v106.ComponentType.StringSelect });
      this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
    }
    addOptions(...options) {
      const normalizedOptions = normalizeArray(options);
      optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
      this.options.push(...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      return this;
    }
    setOptions(...options) {
      return this.spliceOptions(0, this.options.length, ...options);
    }
    spliceOptions(index, deleteCount, ...options) {
      const normalizedOptions = normalizeArray(options);
      const clone = [...this.options];
      clone.splice(index, deleteCount, ...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      optionsLengthValidator.parse(clone.length);
      this.options.splice(0, this.options.length, ...clone);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
      return {
        ...this.data,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v107 = require_v106();
  var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "UserSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v107.ComponentType.UserSelect });
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    setDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      }));
      return this;
    }
  };
  var import_util = require_dist();
  var import_v109 = require_v106();
  var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
  var Assertions_exports3 = {};
  __export(Assertions_exports3, {
    labelValidator: () => labelValidator,
    maxLengthValidator: () => maxLengthValidator,
    minLengthValidator: () => minLengthValidator,
    placeholderValidator: () => placeholderValidator2,
    requiredValidator: () => requiredValidator,
    textInputStyleValidator: () => textInputStyleValidator,
    validateRequiredParameters: () => validateRequiredParameters,
    valueValidator: () => valueValidator
  });
  var import_shapeshift3 = require_cjs3();
  var import_v108 = require_v106();
  var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
  var minLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var maxLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(1).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var requiredValidator = import_shapeshift3.s.boolean();
  var valueValidator = import_shapeshift3.s.string().lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var placeholderValidator2 = import_shapeshift3.s.string().lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var labelValidator = import_shapeshift3.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  function validateRequiredParameters(customId, style, label) {
    customIdValidator.parse(customId);
    textInputStyleValidator.parse(style);
    labelValidator.parse(label);
  }
  __name(validateRequiredParameters, "validateRequiredParameters");
  var TextInputBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextInputBuilder");
    }
    constructor(data) {
      super({ type: import_v109.ComponentType.TextInput, ...data });
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setLabel(label) {
      this.data.label = labelValidator.parse(label);
      return this;
    }
    setStyle(style) {
      this.data.style = textInputStyleValidator.parse(style);
      return this;
    }
    setMinLength(minLength) {
      this.data.min_length = minLengthValidator.parse(minLength);
      return this;
    }
    setMaxLength(maxLength) {
      this.data.max_length = maxLengthValidator.parse(maxLength);
      return this;
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator2.parse(placeholder);
      return this;
    }
    setValue(value) {
      this.data.value = valueValidator.parse(value);
      return this;
    }
    setRequired(required = true) {
      this.data.required = requiredValidator.parse(required);
      return this;
    }
    toJSON() {
      validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
      return {
        ...this.data
      };
    }
    equals(other) {
      if ((0, import_util.isJSONEncodable)(other)) {
        return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
      }
      return (0, import_fast_deep_equal.default)(other, this.data);
    }
  };
  var import_v1015 = require_v106();
  var Assertions_exports4 = {};
  __export(Assertions_exports4, {
    accessoryPredicate: () => accessoryPredicate,
    assertReturnOfBuilder: () => assertReturnOfBuilder,
    containerColorPredicate: () => containerColorPredicate,
    descriptionPredicate: () => descriptionPredicate2,
    dividerPredicate: () => dividerPredicate,
    filePredicate: () => filePredicate,
    spacingPredicate: () => spacingPredicate,
    spoilerPredicate: () => spoilerPredicate,
    textDisplayContentPredicate: () => textDisplayContentPredicate,
    unfurledMediaItemPredicate: () => unfurledMediaItemPredicate,
    validateComponentArray: () => validateComponentArray
  });
  var import_shapeshift4 = require_cjs3();
  var import_v1011 = require_v106();
  var import_v1010 = require_v106();
  var ThumbnailBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ThumbnailBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1010.ComponentType.Thumbnail,
        ...data,
        media: data.media ? { url: data.media.url } : undefined
      });
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var unfurledMediaItemPredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["http:", "https:", "attachment:"] }, { message: "Invalid protocol for media URL. Must be http:, https:, or attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var descriptionPredicate2 = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var filePredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["attachment:"] }, { message: "Invalid protocol for file URL. Must be attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var spoilerPredicate = import_shapeshift4.s.boolean();
  var dividerPredicate = import_shapeshift4.s.boolean();
  var spacingPredicate = import_shapeshift4.s.nativeEnum(import_v1011.SeparatorSpacingSize);
  var textDisplayContentPredicate = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var accessoryPredicate = import_shapeshift4.s.instance(ButtonBuilder).or(import_shapeshift4.s.instance(ThumbnailBuilder)).setValidationEnabled(isValidationEnabled);
  var containerColorPredicate = colorPredicate.nullish();
  function assertReturnOfBuilder(input, ExpectedInstanceOf) {
    import_shapeshift4.s.instance(ExpectedInstanceOf).setValidationEnabled(isValidationEnabled).parse(input);
  }
  __name(assertReturnOfBuilder, "assertReturnOfBuilder");
  function validateComponentArray(input, min, max, ExpectedInstanceOf) {
    (ExpectedInstanceOf ? import_shapeshift4.s.instance(ExpectedInstanceOf) : import_shapeshift4.s.instance(ComponentBuilder)).array().lengthGreaterThanOrEqual(min).lengthLessThanOrEqual(max).setValidationEnabled(isValidationEnabled).parse(input);
  }
  __name(validateComponentArray, "validateComponentArray");
  var import_v1012 = require_v106();
  var FileBuilder = class extends ComponentBuilder {
    static {
      __name(this, "FileBuilder");
    }
    constructor(data = {}) {
      super({ type: import_v1012.ComponentType.File, ...data, file: data.file ? { url: data.file.url } : undefined });
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.file = filePredicate.parse({ url });
      return this;
    }
    toJSON() {
      filePredicate.parse(this.data.file);
      return { ...this.data, file: { ...this.data.file } };
    }
  };
  var import_v1013 = require_v106();
  var SeparatorBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SeparatorBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1013.ComponentType.Separator,
        ...data
      });
    }
    setDivider(divider = true) {
      this.data.divider = dividerPredicate.parse(divider);
      return this;
    }
    setSpacing(spacing) {
      this.data.spacing = spacingPredicate.parse(spacing);
      return this;
    }
    clearSpacing() {
      this.data.spacing = undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  var import_v1014 = require_v106();
  var TextDisplayBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextDisplayBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1014.ComponentType.TextDisplay,
        ...data
      });
    }
    setContent(content) {
      this.data.content = textDisplayContentPredicate.parse(content);
      return this;
    }
    toJSON() {
      textDisplayContentPredicate.parse(this.data.content);
      return { ...this.data };
    }
  };
  var ContainerBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ContainerBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1015.ComponentType.Container, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setAccentColor(color) {
      containerColorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.accent_color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.accent_color = color;
      return this;
    }
    clearAccentColor() {
      this.data.accent_color = undefined;
      return this;
    }
    addActionRowComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, ActionRowBuilder)));
      return this;
    }
    addFileComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, FileBuilder)));
      return this;
    }
    addMediaGalleryComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, MediaGalleryBuilder)));
      return this;
    }
    addSectionComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SectionBuilder)));
      return this;
    }
    addSeparatorComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SeparatorBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, TextDisplayBuilder)));
      return this;
    }
    spliceComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((component) => component instanceof ComponentBuilder ? component : createComponentBuilder(component)));
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var import_v1016 = require_v106();
  var MediaGalleryItemBuilder = class {
    static {
      __name(this, "MediaGalleryItemBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = data;
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var MediaGalleryBuilder = class extends ComponentBuilder {
    static {
      __name(this, "MediaGalleryBuilder");
    }
    items;
    constructor({ items, ...data } = {}) {
      super({ type: import_v1016.ComponentType.MediaGallery, ...data });
      this.items = items?.map((item) => new MediaGalleryItemBuilder(item)) ?? [];
    }
    addItems(...items) {
      this.items.push(...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    spliceItems(index, deleteCount, ...items) {
      this.items.splice(index, deleteCount, ...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.items, 1, 10, MediaGalleryItemBuilder);
      return {
        ...this.data,
        items: this.items.map((item) => item.toJSON())
      };
    }
  };
  var import_v1017 = require_v106();
  var SectionBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SectionBuilder");
    }
    components;
    accessory;
    constructor({ components, accessory, ...data } = {}) {
      super({ type: import_v1017.ComponentType.Section, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
      this.accessory = accessory ? createComponentBuilder(accessory) : undefined;
    }
    setButtonAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ButtonBuilder)));
      return this;
    }
    setThumbnailAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ThumbnailBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    spliceTextDisplayComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.components, 1, 3, TextDisplayBuilder);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON()),
        accessory: accessoryPredicate.parse(this.accessory).toJSON()
      };
    }
  };
  function createComponentBuilder(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case import_v1018.ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case import_v1018.ComponentType.Button:
        return new ButtonBuilder(data);
      case import_v1018.ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case import_v1018.ComponentType.TextInput:
        return new TextInputBuilder(data);
      case import_v1018.ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case import_v1018.ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case import_v1018.ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case import_v1018.ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      case import_v1018.ComponentType.File:
        return new FileBuilder(data);
      case import_v1018.ComponentType.Container:
        return new ContainerBuilder(data);
      case import_v1018.ComponentType.Section:
        return new SectionBuilder(data);
      case import_v1018.ComponentType.Separator:
        return new SeparatorBuilder(data);
      case import_v1018.ComponentType.TextDisplay:
        return new TextDisplayBuilder(data);
      case import_v1018.ComponentType.Thumbnail:
        return new ThumbnailBuilder(data);
      case import_v1018.ComponentType.MediaGallery:
        return new MediaGalleryBuilder(data);
      default:
        throw new Error(`Cannot properly serialize component type: ${data.type}`);
    }
  }
  __name(createComponentBuilder, "createComponentBuilder");
  function isBuilder(builder, Constructor) {
    return builder instanceof Constructor;
  }
  __name(isBuilder, "isBuilder");
  function resolveBuilder(builder, Constructor) {
    if (isBuilder(builder, Constructor)) {
      return builder;
    }
    if (typeof builder === "function") {
      return builder(new Constructor);
    }
    return new Constructor(builder);
  }
  __name(resolveBuilder, "resolveBuilder");
  var ActionRowBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ActionRowBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1019.ComponentType.ActionRow, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports5 = {};
  __export(Assertions_exports5, {
    componentsValidator: () => componentsValidator,
    titleValidator: () => titleValidator,
    validateRequiredParameters: () => validateRequiredParameters2
  });
  var import_shapeshift5 = require_cjs3();
  var titleValidator = import_shapeshift5.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  var componentsValidator = import_shapeshift5.s.instance(ActionRowBuilder).array().lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
  function validateRequiredParameters2(customId, title, components) {
    customIdValidator.parse(customId);
    titleValidator.parse(title);
    componentsValidator.parse(components);
  }
  __name(validateRequiredParameters2, "validateRequiredParameters");
  var ModalBuilder = class {
    static {
      __name(this, "ModalBuilder");
    }
    data;
    components = [];
    constructor({ components, ...data } = {}) {
      this.data = { ...data };
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setTitle(title) {
      this.data.title = titleValidator.parse(title);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports6 = {};
  __export(Assertions_exports6, {
    assertReturnOfBuilder: () => assertReturnOfBuilder2,
    contextsPredicate: () => contextsPredicate,
    integrationTypesPredicate: () => integrationTypesPredicate,
    localizationMapPredicate: () => localizationMapPredicate,
    validateChoicesLength: () => validateChoicesLength,
    validateDMPermission: () => validateDMPermission,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
    validateDefaultPermission: () => validateDefaultPermission,
    validateDescription: () => validateDescription,
    validateLocale: () => validateLocale,
    validateLocalizationMap: () => validateLocalizationMap,
    validateMaxOptionsLength: () => validateMaxOptionsLength,
    validateNSFW: () => validateNSFW,
    validateName: () => validateName,
    validateRequired: () => validateRequired,
    validateRequiredParameters: () => validateRequiredParameters3
  });
  var import_shapeshift6 = require_cjs3();
  var import_v1020 = require_v106();
  var namePredicate = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
  function validateName(name) {
    namePredicate.parse(name);
  }
  __name(validateName, "validateName");
  var descriptionPredicate3 = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var localePredicate = import_shapeshift6.s.nativeEnum(import_v1020.Locale);
  function validateDescription(description) {
    descriptionPredicate3.parse(description);
  }
  __name(validateDescription, "validateDescription");
  var maxArrayLengthPredicate = import_shapeshift6.s.unknown().array().lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateLocale(locale) {
    return localePredicate.parse(locale);
  }
  __name(validateLocale, "validateLocale");
  function validateMaxOptionsLength(options) {
    maxArrayLengthPredicate.parse(options);
  }
  __name(validateMaxOptionsLength, "validateMaxOptionsLength");
  function validateRequiredParameters3(name, description, options) {
    validateName(name);
    validateDescription(description);
    validateMaxOptionsLength(options);
  }
  __name(validateRequiredParameters3, "validateRequiredParameters");
  var booleanPredicate = import_shapeshift6.s.boolean();
  function validateDefaultPermission(value) {
    booleanPredicate.parse(value);
  }
  __name(validateDefaultPermission, "validateDefaultPermission");
  function validateRequired(required) {
    booleanPredicate.parse(required);
  }
  __name(validateRequired, "validateRequired");
  var choicesLengthPredicate = import_shapeshift6.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateChoicesLength(amountAdding, choices) {
    choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
  }
  __name(validateChoicesLength, "validateChoicesLength");
  function assertReturnOfBuilder2(input, ExpectedInstanceOf) {
    import_shapeshift6.s.instance(ExpectedInstanceOf).parse(input);
  }
  __name(assertReturnOfBuilder2, "assertReturnOfBuilder");
  var localizationMapPredicate = import_shapeshift6.s.object(Object.fromEntries(Object.values(import_v1020.Locale).map((locale) => [locale, import_shapeshift6.s.string().nullish()]))).strict().nullish().setValidationEnabled(isValidationEnabled);
  function validateLocalizationMap(value) {
    localizationMapPredicate.parse(value);
  }
  __name(validateLocalizationMap, "validateLocalizationMap");
  var dmPermissionPredicate = import_shapeshift6.s.boolean().nullish();
  function validateDMPermission(value) {
    dmPermissionPredicate.parse(value);
  }
  __name(validateDMPermission, "validateDMPermission");
  var memberPermissionPredicate = import_shapeshift6.s.union([
    import_shapeshift6.s.bigint().transform((value) => value.toString()),
    import_shapeshift6.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift6.s.string().regex(/^\d+$/)
  ]).nullish();
  function validateDefaultMemberPermissions(permissions) {
    return memberPermissionPredicate.parse(permissions);
  }
  __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
  function validateNSFW(value) {
    booleanPredicate.parse(value);
  }
  __name(validateNSFW, "validateNSFW");
  var contextsPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var import_ts_mixer6 = require_cjs4();
  var SharedNameAndDescription = class {
    static {
      __name(this, "SharedNameAndDescription");
    }
    name;
    name_localizations;
    description;
    description_localizations;
    setName(name) {
      validateName(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setDescription(description) {
      validateDescription(description);
      Reflect.set(this, "description", description);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames)) {
        this.setNameLocalization(...args);
      }
      return this;
    }
    setDescriptionLocalization(locale, localizedDescription) {
      if (!this.description_localizations) {
        Reflect.set(this, "description_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedDescription === null) {
        this.description_localizations[parsedLocale] = null;
        return this;
      }
      validateDescription(localizedDescription);
      this.description_localizations[parsedLocale] = localizedDescription;
      return this;
    }
    setDescriptionLocalizations(localizedDescriptions) {
      if (localizedDescriptions === null) {
        Reflect.set(this, "description_localizations", null);
        return this;
      }
      Reflect.set(this, "description_localizations", {});
      for (const args of Object.entries(localizedDescriptions)) {
        this.setDescriptionLocalization(...args);
      }
      return this;
    }
  };
  var import_v1021 = require_v106();
  var SharedSlashCommand = class {
    static {
      __name(this, "SharedSlashCommand");
    }
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNSFW(nsfw = true) {
      validateNSFW(nsfw);
      Reflect.set(this, "nsfw", nsfw);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      return {
        ...this,
        type: import_v1021.ApplicationCommandType.ChatInput,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v1022 = require_v106();
  var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
    static {
      __name(this, "ApplicationCommandOptionBase");
    }
    required = false;
    setRequired(required) {
      validateRequired(required);
      Reflect.set(this, "required", required);
      return this;
    }
    runRequiredValidations() {
      validateRequiredParameters3(this.name, this.description, []);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      validateRequired(this.required);
    }
  };
  var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandAttachmentOption");
    }
    type = import_v1022.ApplicationCommandOptionType.Attachment;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1023 = require_v106();
  var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandBooleanOption");
    }
    type = import_v1023.ApplicationCommandOptionType.Boolean;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1025 = require_v106();
  var import_ts_mixer = require_cjs4();
  var import_shapeshift7 = require_cjs3();
  var import_v1024 = require_v106();
  var allowedChannelTypes = [
    import_v1024.ChannelType.GuildText,
    import_v1024.ChannelType.GuildVoice,
    import_v1024.ChannelType.GuildCategory,
    import_v1024.ChannelType.GuildAnnouncement,
    import_v1024.ChannelType.AnnouncementThread,
    import_v1024.ChannelType.PublicThread,
    import_v1024.ChannelType.PrivateThread,
    import_v1024.ChannelType.GuildStageVoice,
    import_v1024.ChannelType.GuildForum,
    import_v1024.ChannelType.GuildMedia
  ];
  var channelTypesPredicate = import_shapeshift7.s.array(import_shapeshift7.s.union(allowedChannelTypes.map((type) => import_shapeshift7.s.literal(type))));
  var ApplicationCommandOptionChannelTypesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionChannelTypesMixin");
    }
    channel_types;
    addChannelTypes(...channelTypes) {
      if (this.channel_types === undefined) {
        Reflect.set(this, "channel_types", []);
      }
      this.channel_types.push(...channelTypesPredicate.parse(normalizeArray(channelTypes)));
      return this;
    }
  };
  var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
    type = import_v1025.ApplicationCommandOptionType.Channel;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  __name(SlashCommandChannelOption, "SlashCommandChannelOption");
  SlashCommandChannelOption = __decorateClass([
    (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
  ], SlashCommandChannelOption);
  var import_shapeshift10 = require_cjs3();
  var import_v1027 = require_v106();
  var import_ts_mixer2 = require_cjs4();
  var ApplicationCommandNumericOptionMinMaxValueMixin = class {
    static {
      __name(this, "ApplicationCommandNumericOptionMinMaxValueMixin");
    }
    max_value;
    min_value;
  };
  var import_shapeshift8 = require_cjs3();
  var booleanPredicate2 = import_shapeshift8.s.boolean();
  var ApplicationCommandOptionWithAutocompleteMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithAutocompleteMixin");
    }
    autocomplete;
    type;
    setAutocomplete(autocomplete) {
      booleanPredicate2.parse(autocomplete);
      if (autocomplete && "choices" in this && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      Reflect.set(this, "autocomplete", autocomplete);
      return this;
    }
  };
  var import_shapeshift9 = require_cjs3();
  var import_v1026 = require_v106();
  var stringPredicate = import_shapeshift9.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
  var numberPredicate = import_shapeshift9.s.number().greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
  var choicesPredicate = import_shapeshift9.s.object({
    name: stringPredicate,
    name_localizations: localizationMapPredicate,
    value: import_shapeshift9.s.union([stringPredicate, numberPredicate])
  }).array();
  var ApplicationCommandOptionWithChoicesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithChoicesMixin");
    }
    choices;
    type;
    addChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      if (this.choices === undefined) {
        Reflect.set(this, "choices", []);
      }
      validateChoicesLength(normalizedChoices.length, this.choices);
      for (const { name, name_localizations, value } of normalizedChoices) {
        if (this.type === import_v1026.ApplicationCommandOptionType.String) {
          stringPredicate.parse(value);
        } else {
          numberPredicate.parse(value);
        }
        this.choices.push({ name, name_localizations, value });
      }
      return this;
    }
    setChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      Reflect.set(this, "choices", []);
      this.addChoices(normalizedChoices);
      return this;
    }
  };
  var numberValidator = import_shapeshift10.s.number().int();
  var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
    type = import_v1027.ApplicationCommandOptionType.Integer;
    setMaxValue(max) {
      numberValidator.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
  SlashCommandIntegerOption = __decorateClass([
    (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandIntegerOption);
  var import_v1028 = require_v106();
  var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandMentionableOption");
    }
    type = import_v1028.ApplicationCommandOptionType.Mentionable;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift11 = require_cjs3();
  var import_v1029 = require_v106();
  var import_ts_mixer3 = require_cjs4();
  var numberValidator2 = import_shapeshift11.s.number();
  var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
    type = import_v1029.ApplicationCommandOptionType.Number;
    setMaxValue(max) {
      numberValidator2.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator2.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandNumberOption, "SlashCommandNumberOption");
  SlashCommandNumberOption = __decorateClass([
    (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandNumberOption);
  var import_v1030 = require_v106();
  var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandRoleOption");
    }
    type = import_v1030.ApplicationCommandOptionType.Role;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift12 = require_cjs3();
  var import_v1031 = require_v106();
  var import_ts_mixer4 = require_cjs4();
  var minLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(0).lessThanOrEqual(6000);
  var maxLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(1).lessThanOrEqual(6000);
  var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
    type = import_v1031.ApplicationCommandOptionType.String;
    max_length;
    min_length;
    setMaxLength(max) {
      maxLengthValidator2.parse(max);
      Reflect.set(this, "max_length", max);
      return this;
    }
    setMinLength(min) {
      minLengthValidator2.parse(min);
      Reflect.set(this, "min_length", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandStringOption, "SlashCommandStringOption");
  SlashCommandStringOption = __decorateClass([
    (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandStringOption);
  var import_v1032 = require_v106();
  var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandUserOption");
    }
    type = import_v1032.ApplicationCommandOptionType.User;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var SharedSlashCommandOptions = class {
    static {
      __name(this, "SharedSlashCommandOptions");
    }
    options;
    addBooleanOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
    }
    addUserOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandUserOption);
    }
    addChannelOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
    }
    addRoleOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
    }
    addAttachmentOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
    }
    addMentionableOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
    }
    addStringOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandStringOption);
    }
    addIntegerOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
    }
    addNumberOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
    }
    _sharedAddOptionMethod(input, Instance) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new Instance) : input;
      assertReturnOfBuilder2(result, Instance);
      options.push(result);
      return this;
    }
  };
  var import_v1033 = require_v106();
  var import_ts_mixer5 = require_cjs4();
  var SlashCommandSubcommandGroupBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.SubcommandGroup,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
  SlashCommandSubcommandGroupBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription)
  ], SlashCommandSubcommandGroupBuilder);
  var SlashCommandSubcommandBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.Subcommand,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
  SlashCommandSubcommandBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
  ], SlashCommandSubcommandBuilder);
  var SharedSlashCommandSubcommands = class {
    static {
      __name(this, "SharedSlashCommandSubcommands");
    }
    options = [];
    addSubcommandGroup(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandGroupBuilder);
      options.push(result);
      return this;
    }
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
  };
  var SlashCommandBuilder = class {
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
  };
  __name(SlashCommandBuilder, "SlashCommandBuilder");
  SlashCommandBuilder = __decorateClass([
    (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription, SharedSlashCommandSubcommands, SharedSlashCommand)
  ], SlashCommandBuilder);
  var Assertions_exports7 = {};
  __export(Assertions_exports7, {
    contextsPredicate: () => contextsPredicate2,
    integrationTypesPredicate: () => integrationTypesPredicate2,
    validateDMPermission: () => validateDMPermission2,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
    validateDefaultPermission: () => validateDefaultPermission2,
    validateName: () => validateName2,
    validateRequiredParameters: () => validateRequiredParameters4,
    validateType: () => validateType
  });
  var import_shapeshift13 = require_cjs3();
  var import_v1034 = require_v106();
  var namePredicate2 = import_shapeshift13.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
  var typePredicate = import_shapeshift13.s.union([import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.User), import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.Message)]).setValidationEnabled(isValidationEnabled);
  var booleanPredicate3 = import_shapeshift13.s.boolean();
  function validateDefaultPermission2(value) {
    booleanPredicate3.parse(value);
  }
  __name(validateDefaultPermission2, "validateDefaultPermission");
  function validateName2(name) {
    namePredicate2.parse(name);
  }
  __name(validateName2, "validateName");
  function validateType(type) {
    typePredicate.parse(type);
  }
  __name(validateType, "validateType");
  function validateRequiredParameters4(name, type) {
    validateName2(name);
    validateType(type);
  }
  __name(validateRequiredParameters4, "validateRequiredParameters");
  var dmPermissionPredicate2 = import_shapeshift13.s.boolean().nullish();
  function validateDMPermission2(value) {
    dmPermissionPredicate2.parse(value);
  }
  __name(validateDMPermission2, "validateDMPermission");
  var memberPermissionPredicate2 = import_shapeshift13.s.union([
    import_shapeshift13.s.bigint().transform((value) => value.toString()),
    import_shapeshift13.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift13.s.string().regex(/^\d+$/)
  ]).nullish();
  function validateDefaultMemberPermissions2(permissions) {
    return memberPermissionPredicate2.parse(permissions);
  }
  __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
  var contextsPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var ContextMenuCommandBuilder = class {
    static {
      __name(this, "ContextMenuCommandBuilder");
    }
    name = undefined;
    name_localizations;
    type = undefined;
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate2.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate2.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setName(name) {
      validateName2(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setType(type) {
      validateType(type);
      Reflect.set(this, "type", type);
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission2(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions2(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission2(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName2(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames))
        this.setNameLocalization(...args);
      return this;
    }
    toJSON() {
      validateRequiredParameters4(this.name, this.type);
      validateLocalizationMap(this.name_localizations);
      return { ...this };
    }
  };
  function embedLength(data) {
    return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
  }
  __name(embedLength, "embedLength");
  var version = "1.11.2";
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS((exports, module) => {
  var { embedLength } = require_dist8();
  var isEqual = require_fast_deep_equal();

  class Embed {
    constructor(data) {
      this.data = { ...data };
    }
    get fields() {
      return this.data.fields ?? [];
    }
    get title() {
      return this.data.title ?? null;
    }
    get description() {
      return this.data.description ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
    get color() {
      return this.data.color ?? null;
    }
    get timestamp() {
      return this.data.timestamp ?? null;
    }
    get thumbnail() {
      if (!this.data.thumbnail)
        return null;
      return {
        url: this.data.thumbnail.url,
        proxyURL: this.data.thumbnail.proxy_url,
        height: this.data.thumbnail.height,
        width: this.data.thumbnail.width
      };
    }
    get image() {
      if (!this.data.image)
        return null;
      return {
        url: this.data.image.url,
        proxyURL: this.data.image.proxy_url,
        height: this.data.image.height,
        width: this.data.image.width
      };
    }
    get video() {
      if (!this.data.video)
        return null;
      return {
        url: this.data.video.url,
        proxyURL: this.data.video.proxy_url,
        height: this.data.video.height,
        width: this.data.video.width
      };
    }
    get author() {
      if (!this.data.author)
        return null;
      return {
        name: this.data.author.name,
        url: this.data.author.url,
        iconURL: this.data.author.icon_url,
        proxyIconURL: this.data.author.proxy_icon_url
      };
    }
    get provider() {
      return this.data.provider ?? null;
    }
    get footer() {
      if (!this.data.footer)
        return null;
      return {
        text: this.data.footer.text,
        iconURL: this.data.footer.icon_url,
        proxyIconURL: this.data.footer.proxy_icon_url
      };
    }
    get length() {
      return embedLength(this.data);
    }
    get hexColor() {
      return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
    }
    toJSON() {
      return { ...this.data };
    }
    equals(other) {
      if (other instanceof Embed) {
        return isEqual(this.data, other.data);
      }
      return this.author?.iconURL === other.author?.icon_url && this.author?.name === other.author?.name && this.author?.url === other.author?.url && this.color === (other.color ?? null) && this.description === (other.description ?? null) && this.footer?.iconURL === other.footer?.icon_url && this.footer?.text === other.footer?.text && this.image?.url === other.image?.url && this.thumbnail?.url === other.thumbnail?.url && (this.timestamp && Date.parse(this.timestamp)) === (other.timestamp ? Date.parse(other.timestamp) : null) && this.title === (other.title ?? null) && this.url === (other.url ?? null) && this.video?.url === other.video?.url && isEqual(this.fields, other.fields?.map((field) => ({ ...field, inline: field.inline ?? false })) ?? []) && isEqual(this.provider, other.provider ?? null);
    }
  }
  module.exports = Embed;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { FormattingPatterns } = require_v106();
  var { flatten } = require_Util();

  class MessageMentions {
    static EveryonePattern = /@(?<mention>everyone|here)/;
    static UsersPattern = FormattingPatterns.UserWithOptionalNickname;
    static RolesPattern = FormattingPatterns.Role;
    static ChannelsPattern = FormattingPatterns.Channel;
    static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, "g");
    static GlobalUsersPattern = new RegExp(this.UsersPattern.source, "g");
    constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
      Object.defineProperty(this, "client", { value: message.client });
      Object.defineProperty(this, "guild", { value: message.guild });
      Object.defineProperty(this, "_content", { value: message.content });
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection) {
          this.users = new Collection(users);
        } else {
          this.users = new Collection;
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members._add(Object.assign(mention.member, { user: mention }));
            }
            const user = message.client.users._add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection;
      }
      if (roles instanceof Collection) {
        this.roles = new Collection(roles);
      } else if (roles) {
        this.roles = new Collection;
        const guild = message.guild;
        if (guild) {
          for (const mention of roles) {
            const role = guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection;
      }
      this._members = null;
      this._channels = null;
      this._parsedUsers = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection) {
          this.crosspostedChannels = new Collection(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection;
          for (const crosspostedChannel of crosspostedChannels) {
            this.crosspostedChannels.set(crosspostedChannel.id, {
              channelId: crosspostedChannel.id,
              guildId: crosspostedChannel.guild_id,
              type: crosspostedChannel.type,
              name: crosspostedChannel.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection;
      }
      this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection;
      this.users.forEach((user) => {
        const member = this.guild.members.resolve(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
        const channel = this.client.channels.cache.get(matches.groups.id);
        if (channel)
          this._channels.set(channel.id, channel);
      }
      return this._channels;
    }
    get parsedUsers() {
      if (this._parsedUsers)
        return this._parsedUsers;
      this._parsedUsers = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
        const user = this.client.users.cache.get(matches[1]);
        if (user)
          this._parsedUsers.set(user.id, user);
      }
      return this._parsedUsers;
    }
    has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
      const user = this.client.users.resolve(data);
      if (!ignoreEveryone && user && this.everyone)
        return true;
      const userWasRepliedTo = user && this.repliedUser?.id === user.id;
      if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
        return true;
      if (!ignoreDirect) {
        if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
          return true;
        const role = this.guild?.roles.resolve(data);
        if (role && this.roles.has(role.id))
          return true;
        const channel = this.client.channels.resolve(data);
        if (channel && this.channels.has(channel.id))
          return true;
      }
      if (!ignoreRoles) {
        const member = this.guild?.members.resolve(data);
        if (member) {
          for (const mentionedRole of this.roles.values())
            if (member.roles.cache.has(mentionedRole.id))
              return true;
        }
      }
      return false;
    }
    toJSON() {
      return flatten(this, {
        members: true,
        channels: true
      });
    }
  }
  module.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/PollAnswer.js
var require_PollAnswer = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class PollAnswer extends Base {
    constructor(client, data, poll) {
      super(client);
      Object.defineProperty(this, "poll", { value: poll });
      this.id = data.answer_id;
      this.text = data.poll_media.text ?? null;
      Object.defineProperty(this, "_emoji", { value: data.poll_media.emoji ?? null });
      this._patch(data);
    }
    _patch(data) {
      if ("count" in data) {
        this.voteCount = data.count;
      } else {
        this.voteCount ??= 0;
      }
    }
    get emoji() {
      if (!this._emoji || !this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    fetchVoters({ after, limit } = {}) {
      return this.poll.message.channel.messages.fetchPollAnswerVoters({
        messageId: this.poll.message.id,
        answerId: this.id,
        after,
        limit
      });
    }
  }
  exports.PollAnswer = PollAnswer;
});

// node_modules/discord.js/src/structures/Poll.js
var require_Poll = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { PollAnswer } = require_PollAnswer();
  var { DiscordjsError } = require_DJSError();
  var { ErrorCodes } = require_errors2();

  class Poll extends Base {
    constructor(client, data, message) {
      super(client);
      Object.defineProperty(this, "message", { value: message });
      this.question = {
        text: data.question.text
      };
      this.answers = data.answers.reduce((acc, answer) => acc.set(answer.answer_id, new PollAnswer(this.client, answer, this)), new Collection);
      this.expiresTimestamp = Date.parse(data.expiry);
      this.allowMultiselect = data.allow_multiselect;
      this.layoutType = data.layout_type;
      this._patch(data);
    }
    _patch(data) {
      if (data.results) {
        this.resultsFinalized = data.results.is_finalized;
        for (const answerResult of data.results.answer_counts) {
          const answer = this.answers.get(answerResult.id);
          answer?._patch(answerResult);
        }
      } else {
        this.resultsFinalized ??= false;
      }
    }
    get expiresAt() {
      return new Date(this.expiresTimestamp);
    }
    async end() {
      if (Date.now() > this.expiresTimestamp) {
        throw new DiscordjsError(ErrorCodes.PollAlreadyExpired);
      }
      return this.message.channel.messages.endPoll(this.message.id);
    }
  }
  exports.Poll = Poll;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class ReactionCollector extends Collector {
    constructor(message, options = {}) {
      super(message.client, options);
      this.message = message;
      this.users = new Collection;
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.message.id))
          this.stop("messageDelete");
      };
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageReactionAdd, this.handleCollect);
      this.client.on(Events.MessageReactionRemove, this.handleDispose);
      this.client.on(Events.MessageReactionRemoveAll, this.empty);
      this.client.on(Events.MessageDelete, this._handleMessageDeletion);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageReactionAdd, this.handleCollect);
        this.client.removeListener(Events.MessageReactionRemove, this.handleDispose);
        this.client.removeListener(Events.MessageReactionRemoveAll, this.empty);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        if (reaction.count === 1) {
          this.emit("create", reaction, user);
        }
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (_reaction, user) => {
        this.total--;
        if (!this.collected.some((reaction) => reaction.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.message.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.message.guild?.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id ?? reaction.emoji.name;
    }
  }
  module.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { StickerFormatExtensionMap } = require_Constants();

  class Sticker extends Base {
    constructor(client, sticker) {
      super(client);
      this._patch(sticker);
    }
    _patch(sticker) {
      this.id = sticker.id;
      if ("description" in sticker) {
        this.description = sticker.description;
      } else {
        this.description ??= null;
      }
      if ("type" in sticker) {
        this.type = sticker.type;
      } else {
        this.type ??= null;
      }
      if ("format_type" in sticker) {
        this.format = sticker.format_type;
      }
      if ("name" in sticker) {
        this.name = sticker.name;
      }
      if ("pack_id" in sticker) {
        this.packId = sticker.pack_id;
      } else {
        this.packId ??= null;
      }
      if ("tags" in sticker) {
        this.tags = sticker.tags;
      } else {
        this.tags ??= null;
      }
      if ("available" in sticker) {
        this.available = sticker.available;
      } else {
        this.available ??= null;
      }
      if ("guild_id" in sticker) {
        this.guildId = sticker.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in sticker) {
        this.user = this.client.users._add(sticker.user);
      } else {
        this.user ??= null;
      }
      if ("sort_value" in sticker) {
        this.sortValue = sticker.sort_value;
      } else {
        this.sortValue ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get partial() {
      return !this.type;
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.sticker(this.id));
      this._patch(data);
      return this;
    }
    async fetchPack() {
      if (!this.packId)
        return null;
      return this.client.fetchStickerPacks({ packId: this.packId });
    }
    async fetchUser() {
      if (this.partial)
        await this.fetch();
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSticker);
      return this.guild.stickers.fetchUser(this);
    }
    edit(options) {
      return this.guild.stickers.edit(this, options);
    }
    async delete(reason) {
      await this.guild.stickers.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof Sticker) {
        return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
      } else {
        return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
      }
    }
  }
  exports.Sticker = Sticker;
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class BaseGuildEmoji extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requiresColons = null;
      this.managed = null;
      this.available = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
  }
  module.exports = BaseGuildEmoji;
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildEmojiRoleManager extends DataManager {
    constructor(emoji) {
      super(emoji.client, Role);
      this.emoji = emoji;
      this.guild = emoji.guild;
    }
    get cache() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    async add(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoles = [];
      for (const role of roleOrRoles.values()) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
      return this.set(newRoles);
    }
    async remove(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoleIds = [];
      for (const role of roleOrRoles.values()) {
        const roleId = this.guild.roles.resolveId(role);
        if (!roleId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoleIds.push(roleId);
      }
      const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({ roles });
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch([...this.cache.keys()]);
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = GuildEmojiRoleManager;
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();

  class GuildEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      this._patch(data);
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (data.user)
        this.author = this.client.users._add(data.user);
      if (data.roles)
        this._roles = data.roles;
    }
    get deletable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    fetchAuthor() {
      return this.guild.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.guild.emojis.edit(this.id, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async delete(reason) {
      await this.guild.emojis.delete(this.id, reason);
      return this;
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  }
  module.exports = GuildEmoji;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();
  var { flatten } = require_Util();

  class ReactionEmoji extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return flatten(this, { identifier: true });
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = ReactionEmoji;
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS((exports, module) => {
  var { UserFlags } = require_v106();
  var BitField = require_BitField();

  class UserFlagsBitField extends BitField {
    static Flags = UserFlags;
  }
  module.exports = UserFlagsBitField;
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { calculateUserDefaultAvatarIndex } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var UserFlagsBitField = require_UserFlagsBitField();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class User extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.bot = null;
      this.system = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else {
        this.username ??= null;
      }
      if ("global_name" in data) {
        this.globalName = data.global_name;
      } else {
        this.globalName ??= null;
      }
      if ("bot" in data) {
        this.bot = Boolean(data.bot);
      } else if (!this.partial && typeof this.bot !== "boolean") {
        this.bot = false;
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else {
        this.discriminator ??= null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else {
        this.avatar ??= null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else if (this.banner !== null) {
        this.banner ??= undefined;
      }
      if ("accent_color" in data) {
        this.accentColor = data.accent_color;
      } else if (this.accentColor !== null) {
        this.accentColor ??= undefined;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      } else if (!this.partial && typeof this.system !== "boolean") {
        this.system = false;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlagsBitField(data.public_flags);
      }
      if ("avatar_decoration" in data) {
        this.avatarDecoration = data.avatar_decoration;
      } else {
        this.avatarDecoration ??= null;
      }
      if (data.avatar_decoration_data) {
        this.avatarDecorationData = {
          asset: data.avatar_decoration_data.asset,
          skuId: data.avatar_decoration_data.sku_id
        };
      } else {
        this.avatarDecorationData = null;
      }
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    avatarDecorationURL(options = {}) {
      if (this.avatarDecorationData) {
        return this.client.rest.cdn.avatarDecoration(this.avatarDecorationData.asset);
      }
      return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
    }
    get defaultAvatarURL() {
      const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
      return this.client.rest.cdn.defaultAvatar(index);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.defaultAvatarURL;
    }
    get hexAccentColor() {
      if (typeof this.accentColor !== "number")
        return this.accentColor;
      return `#${this.accentColor.toString(16).padStart(6, "0")}`;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    get tag() {
      return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
    }
    get displayName() {
      return this.globalName ?? this.username;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    createDM(force = false) {
      return this.client.users.createDM(this.id, { force });
    }
    deleteDM() {
      return this.client.users.deleteDM(this.id);
    }
    equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor && this.avatarDecoration === user.avatarDecoration && this.avatarDecorationData?.asset === user.avatarDecorationData?.asset && this.avatarDecorationData?.skuId === user.avatarDecorationData?.skuId;
    }
    _equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true) && ("avatar_decoration" in user ? this.avatarDecoration === user.avatar_decoration : true) && ("avatar_decoration_data" in user ? this.avatarDecorationData?.asset === user.avatar_decoration_data?.asset && this.avatarDecorationData?.skuId === user.avatar_decoration_data?.sku_id : true);
    }
    fetchFlags(force = false) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return this.client.users.fetchFlags(this.id, { force });
    }
    fetch(force = true) {
      return this.client.users.fetch(this.id, { force });
    }
    toString() {
      return userMention(this.id);
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        hexAccentColor: true,
        tag: true
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.bannerURL = this.banner ? this.bannerURL() : this.banner;
      return json;
    }
  }
  TextBasedChannel.applyToClass(User);
  module.exports = User;
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { ReactionType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var User = require_User();

  class ReactionUserManager extends CachedManager {
    constructor(reaction, iterable) {
      super(reaction.client, User, iterable);
      this.reaction = reaction;
    }
    async fetch({ type = ReactionType.Normal, limit = 100, after } = {}) {
      const message = this.reaction.message;
      const query = makeURLSearchParams({ limit, after, type });
      const data = await this.client.rest.get(Routes.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier), { query });
      const users = new Collection;
      for (const rawUser of data) {
        const user = this.client.users._add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    async remove(user = this.client.user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsError(ErrorCodes.ReactionResolveUser);
      const message = this.reaction.message;
      const route = userId === this.client.user.id ? Routes.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
      await this.client.rest.delete(route);
      return this.reaction;
    }
  }
  module.exports = ReactionUserManager;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var { flatten } = require_Util();

  class MessageReaction {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", { value: client });
      this.message = message;
      this.me = data.me;
      this.meBurst = Boolean(data.me_burst);
      this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this.burstColors = null;
      this._patch(data);
    }
    _patch(data) {
      if (data.burst_colors) {
        this.burstColors = data.burst_colors;
      }
      if ("count" in data) {
        this.count ??= data.count;
      }
      if ("count_details" in data) {
        this.countDetails = {
          burst: data.count_details.burst,
          normal: data.count_details.normal
        };
      } else {
        this.countDetails ??= { burst: 0, normal: 0 };
      }
    }
    react() {
      return this.message.react(this.emoji);
    }
    async remove() {
      await this.client.rest.delete(Routes.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier));
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji instanceof ApplicationEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const applicationEmojis = this.message.client.application.emojis.cache;
        if (applicationEmojis.has(this._emoji.id)) {
          const emoji = applicationEmojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
      this._patch(existing ?? { count: 0 });
      return this;
    }
    toJSON() {
      return flatten(this, { emoji: "emojiId", message: "messageId" });
    }
    valueOf() {
      return this._emoji.id ?? this._emoji.name;
    }
    _add(user, burst) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0) {
        this.count++;
        if (burst)
          this.countDetails.burst++;
        else
          this.countDetails.normal++;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = true;
        else
          this.me = true;
      }
    }
    _remove(user, burst) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id) {
        this.count--;
        if (burst)
          this.countDetails.burst--;
        else
          this.countDetails.normal--;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = false;
        else
          this.me = false;
      }
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
      }
    }
  }
  module.exports = MessageReaction;
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var MessageReaction = require_MessageReaction();

  class ReactionManager extends CachedManager {
    constructor(message, iterable) {
      super(message.client, MessageReaction, iterable);
      this.message = message;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
    }
    async removeAll() {
      await this.client.rest.delete(Routes.channelMessageAllReactions(this.message.channelId, this.message.id));
      return this.message;
    }
  }
  module.exports = ReactionManager;
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS((exports, module) => {
  var isEqual = require_fast_deep_equal();

  class Component {
    constructor(data) {
      this.data = data;
    }
    get id() {
      return this.data.id;
    }
    get type() {
      return this.data.type;
    }
    equals(other) {
      if (other instanceof Component) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = Component;
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { isJSONEncodable } = require_dist();
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ActionRow extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    static from = deprecate((other) => new this(isJSONEncodable(other) ? other.toJSON() : other), "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ActionRow;
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS((exports, module) => {
  var { ActionRowBuilder: BuildersActionRow } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { createComponentBuilder } = require_Components();
  var { toSnakeCase } = require_Transformers();

  class ActionRowBuilder extends BuildersActionRow {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => createComponentBuilder(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ActionRowBuilder;
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS((exports, module) => {
  var { ButtonBuilder: BuildersButton } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class ButtonBuilder extends BuildersButton {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ButtonBuilder;
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class ButtonComponent extends Component {
    get style() {
      return this.data.style;
    }
    get label() {
      return this.data.label ?? null;
    }
    get emoji() {
      return this.data.emoji ?? null;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
    get customId() {
      return this.data.custom_id ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
  }
  module.exports = ButtonComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS((exports, module) => {
  var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ChannelSelectMenuBuilder extends BuildersChannelSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ChannelSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class BaseSelectMenuComponent extends Component {
    get placeholder() {
      return this.data.placeholder ?? null;
    }
    get maxValues() {
      return this.data.max_values ?? null;
    }
    get minValues() {
      return this.data.min_values ?? null;
    }
    get customId() {
      return this.data.custom_id;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
  }
  module.exports = BaseSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class ChannelSelectMenuComponent extends BaseSelectMenuComponent {
    get channelTypes() {
      return this.data.channel_types ?? null;
    }
  }
  module.exports = ChannelSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ContainerComponent.js
var require_ContainerComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ContainerComponent extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    get accentColor() {
      return this.data.accent_color ?? null;
    }
    get hexAccentColor() {
      return typeof this.data.accent_color === "number" ? `#${this.data.accent_color.toString(16).padStart(6, "0")}` : this.data.accent_color ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ContainerComponent;
});

// node_modules/discord.js/src/structures/UnfurledMediaItem.js
var require_UnfurledMediaItem = __commonJS((exports, module) => {
  class UnfurledMediaItem {
    constructor(data) {
      this.data = data;
    }
    get url() {
      return this.data.url;
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = UnfurledMediaItem;
});

// node_modules/discord.js/src/structures/FileComponent.js
var require_FileComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class FileComponent extends Component {
    constructor({ file, ...data }) {
      super(data);
      this.file = new UnfurledMediaItem(file);
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, file: this.file.toJSON() };
    }
  }
  module.exports = FileComponent;
});

// node_modules/discord.js/src/structures/MediaGalleryItem.js
var require_MediaGalleryItem = __commonJS((exports, module) => {
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class MediaGalleryItem {
    constructor({ media, ...data }) {
      this.data = data;
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = MediaGalleryItem;
});

// node_modules/discord.js/src/structures/MediaGalleryComponent.js
var require_MediaGalleryComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var MediaGalleryItem = require_MediaGalleryItem();

  class MediaGalleryComponent extends Component {
    constructor({ items, ...data }) {
      super(data);
      this.items = items.map((item) => new MediaGalleryItem(item));
    }
    toJSON() {
      return { ...this.data, items: this.items.map((item) => item.toJSON()) };
    }
  }
  module.exports = MediaGalleryComponent;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS((exports, module) => {
  var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class MentionableSelectMenuBuilder extends BuildersMentionableSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = MentionableSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class MentionableSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = MentionableSelectMenuComponent;
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS((exports, module) => {
  var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class RoleSelectMenuBuilder extends BuildersRoleSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = RoleSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class RoleSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = RoleSelectMenuComponent;
});

// node_modules/discord.js/src/structures/SectionComponent.js
var require_SectionComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class SectionComponent extends Component {
    constructor({ accessory, components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
      this.accessory = createComponent(accessory);
    }
    toJSON() {
      return {
        ...this.data,
        accessory: this.accessory.toJSON(),
        components: this.components.map((component) => component.toJSON())
      };
    }
  }
  module.exports = SectionComponent;
});

// node_modules/discord.js/src/structures/SeparatorComponent.js
var require_SeparatorComponent = __commonJS((exports, module) => {
  var { SeparatorSpacingSize } = require_v106();
  var Component = require_Component();

  class SeparatorComponent extends Component {
    get spacing() {
      return this.data.spacing ?? SeparatorSpacingSize.Small;
    }
    get divider() {
      return this.data.divider ?? true;
    }
  }
  module.exports = SeparatorComponent;
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS((exports, module) => {
  var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuBuilder extends BuildersSelectMenu {
    constructor({ options, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        options: options?.map(({ emoji, ...option }) => ({
          ...option,
          emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        }))
      }));
    }
    static normalizeEmoji(selectMenuOption) {
      if (isJSONEncodable(selectMenuOption)) {
        return selectMenuOption;
      }
      const { emoji, ...option } = selectMenuOption;
      return {
        ...option,
        emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      };
    }
    addOptions(...options) {
      return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    setOptions(...options) {
      return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    static from(other) {
      if (isJSONEncodable(other)) {
        return new this(other.toJSON());
      }
      return new this(other);
    }
  }
  module.exports = StringSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class StringSelectMenuComponent extends BaseSelectMenuComponent {
    get options() {
      return this.data.options;
    }
  }
  module.exports = StringSelectMenuComponent;
});

// node_modules/discord.js/src/structures/TextDisplayComponent.js
var require_TextDisplayComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextDisplayComponent extends Component {
    get content() {
      return this.data.content;
    }
  }
  module.exports = TextDisplayComponent;
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS((exports, module) => {
  var { TextInputBuilder: BuildersTextInput } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class TextInputBuilder extends BuildersTextInput {
    constructor(data) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = TextInputBuilder;
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextInputComponent extends Component {
    get customId() {
      return this.data.custom_id;
    }
    get value() {
      return this.data.value;
    }
  }
  module.exports = TextInputComponent;
});

// node_modules/discord.js/src/structures/ThumbnailComponent.js
var require_ThumbnailComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class ThumbnailComponent extends Component {
    constructor({ media, ...data }) {
      super(data);
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = ThumbnailComponent;
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS((exports, module) => {
  var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class UserSelectMenuBuilder extends BuildersUserSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = UserSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class UserSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = UserSelectMenuComponent;
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS((exports, module) => {
  var { ComponentBuilder } = require_dist8();
  var { ComponentType } = require_v106();
  function createComponent(data) {
    return data instanceof Component ? data : new (ComponentTypeToComponent[data.type] ?? Component)(data);
  }
  function createComponentBuilder(data) {
    return data instanceof ComponentBuilder ? data : new (ComponentTypeToBuilder[data.type] ?? ComponentBuilder)(data);
  }
  function extractInteractiveComponents(component) {
    switch (component.type) {
      case ComponentType.ActionRow:
        return component.components;
      case ComponentType.Section:
        return [...component.components, component.accessory];
      case ComponentType.Container:
        return component.components.flatMap(extractInteractiveComponents);
      default:
        return [component];
    }
  }
  function findComponentByCustomId(components, customId) {
    return components.flatMap(extractInteractiveComponents).find((component) => (component.customId ?? component.custom_id) === customId) ?? null;
  }
  module.exports = { createComponent, createComponentBuilder, findComponentByCustomId };
  var ActionRow = require_ActionRow();
  var ActionRowBuilder = require_ActionRowBuilder();
  var ButtonBuilder = require_ButtonBuilder();
  var ButtonComponent = require_ButtonComponent();
  var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  var Component = require_Component();
  var ContainerComponent = require_ContainerComponent();
  var FileComponent = require_FileComponent();
  var MediaGalleryComponent = require_MediaGalleryComponent();
  var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  var SectionComponent = require_SectionComponent();
  var SeparatorComponent = require_SeparatorComponent();
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var TextDisplayComponent = require_TextDisplayComponent();
  var TextInputBuilder = require_TextInputBuilder();
  var TextInputComponent = require_TextInputComponent();
  var ThumbnailComponent = require_ThumbnailComponent();
  var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  var UserSelectMenuComponent = require_UserSelectMenuComponent();
  var ComponentTypeToComponent = {
    [ComponentType.ActionRow]: ActionRow,
    [ComponentType.Button]: ButtonComponent,
    [ComponentType.StringSelect]: StringSelectMenuComponent,
    [ComponentType.TextInput]: TextInputComponent,
    [ComponentType.UserSelect]: UserSelectMenuComponent,
    [ComponentType.RoleSelect]: RoleSelectMenuComponent,
    [ComponentType.MentionableSelect]: MentionableSelectMenuComponent,
    [ComponentType.ChannelSelect]: ChannelSelectMenuComponent,
    [ComponentType.Container]: ContainerComponent,
    [ComponentType.TextDisplay]: TextDisplayComponent,
    [ComponentType.File]: FileComponent,
    [ComponentType.MediaGallery]: MediaGalleryComponent,
    [ComponentType.Section]: SectionComponent,
    [ComponentType.Separator]: SeparatorComponent,
    [ComponentType.Thumbnail]: ThumbnailComponent
  };
  var ComponentTypeToBuilder = {
    [ComponentType.ActionRow]: ActionRowBuilder,
    [ComponentType.Button]: ButtonBuilder,
    [ComponentType.StringSelect]: StringSelectMenuBuilder,
    [ComponentType.TextInput]: TextInputBuilder,
    [ComponentType.UserSelect]: UserSelectMenuBuilder,
    [ComponentType.RoleSelect]: RoleSelectMenuBuilder,
    [ComponentType.MentionableSelect]: MentionableSelectMenuBuilder,
    [ComponentType.ChannelSelect]: ChannelSelectMenuBuilder
  };
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { messageLink } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var {
    InteractionType,
    ChannelType,
    MessageType,
    MessageFlags,
    PermissionFlagsBits,
    MessageReferenceType
  } = require_v106();
  var Attachment = require_Attachment();
  var Base = require_Base();
  var ClientApplication = require_ClientApplication();
  var Embed = require_Embed();
  var InteractionCollector = require_InteractionCollector();
  var Mentions = require_MessageMentions();
  var MessagePayload = require_MessagePayload();
  var { Poll } = require_Poll();
  var ReactionCollector = require_ReactionCollector();
  var { Sticker } = require_Sticker();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ReactionManager = require_ReactionManager();
  var { createComponent, findComponentByCustomId } = require_Components();
  var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, UndeletableMessageTypes } = require_Constants();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();
  var { _transformAPIMessageInteractionMetadata } = require_Transformers();
  var { cleanContent, resolvePartialEmoji, transformResolved } = require_Util();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      this.channelId = data.channel_id;
      this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
      if ("type" in data) {
        this.type = data.type;
        this.system = !NonSystemMessageTypes.includes(this.type);
      } else {
        this.system ??= null;
        this.type ??= null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else {
        this.content ??= null;
      }
      if ("author" in data) {
        this.author = this.client.users._add(data.author, !data.webhook_id);
      } else {
        this.author ??= null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else {
        this.pinned ??= null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else {
        this.tts ??= null;
      }
      if ("nonce" in data) {
        this.nonce = data.nonce;
      } else {
        this.nonce ??= null;
      }
      if ("embeds" in data) {
        this.embeds = data.embeds.map((embed) => new Embed(embed));
      } else {
        this.embeds = this.embeds?.slice() ?? [];
      }
      if ("components" in data) {
        this.components = data.components.map((component) => createComponent(component));
      } else {
        this.components = this.components?.slice() ?? [];
      }
      if ("attachments" in data) {
        this.attachments = new Collection;
        if (data.attachments) {
          for (const attachment of data.attachments) {
            this.attachments.set(attachment.id, new Attachment(attachment));
          }
        }
      } else {
        this.attachments = new Collection(this.attachments);
      }
      if ("sticker_items" in data || "stickers" in data) {
        this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map((sticker) => [sticker.id, new Sticker(this.client, sticker)]));
      } else {
        this.stickers = new Collection(this.stickers);
      }
      if ("position" in data) {
        this.position = data.position;
      } else {
        this.position ??= null;
      }
      if ("role_subscription_data" in data) {
        this.roleSubscriptionData = {
          roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
          tierName: data.role_subscription_data.tier_name,
          totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
          isRenewal: data.role_subscription_data.is_renewal
        };
      } else {
        this.roleSubscriptionData ??= null;
      }
      if ("resolved" in data) {
        this.resolved = transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.resolved);
      } else {
        this.resolved ??= null;
      }
      if (data.edited_timestamp) {
        this.editedTimestamp = Date.parse(data.edited_timestamp);
      } else {
        this.editedTimestamp ??= null;
      }
      if ("reactions" in data) {
        this.reactions = new ReactionManager(this);
        if (data.reactions?.length > 0) {
          for (const reaction of data.reactions) {
            this.reactions._add(reaction);
          }
        }
      } else {
        this.reactions ??= new ReactionManager(this);
      }
      if (!this.mentions) {
        this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);
      } else {
        this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);
      }
      if ("webhook_id" in data) {
        this.webhookId = data.webhook_id;
      } else {
        this.webhookId ??= null;
      }
      if ("application" in data) {
        this.groupActivityApplication = new ClientApplication(this.client, data.application);
      } else {
        this.groupActivityApplication ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("activity" in data) {
        this.activity = {
          partyId: data.activity.party_id,
          type: data.activity.type
        };
      } else {
        this.activity ??= null;
      }
      if ("thread" in data) {
        this.client.channels._add(data.thread, this.guild);
      }
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members._add(Object.assign(data.member, { user: this.author }));
      }
      if ("flags" in data) {
        this.flags = new MessageFlagsBitField(data.flags).freeze();
      } else {
        this.flags = new MessageFlagsBitField(this.flags).freeze();
      }
      if ("message_reference" in data) {
        this.reference = {
          channelId: data.message_reference.channel_id,
          guildId: data.message_reference.guild_id,
          messageId: data.message_reference.message_id,
          type: data.message_reference.type
        };
      } else {
        this.reference ??= null;
      }
      if (data.referenced_message) {
        this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
      }
      if (data.interaction_metadata) {
        this.interactionMetadata = _transformAPIMessageInteractionMetadata(this.client, data.interaction_metadata);
      } else {
        this.interactionMetadata ??= null;
      }
      if (data.interaction) {
        this.interaction = {
          id: data.interaction.id,
          type: data.interaction.type,
          commandName: data.interaction.name,
          user: this.client.users._add(data.interaction.user)
        };
      } else {
        this.interaction ??= null;
      }
      if (data.poll) {
        this.poll = new Poll(this.client, data.poll, this);
      } else {
        this.poll ??= null;
      }
      if (data.message_snapshots) {
        this.messageSnapshots = data.message_snapshots.reduce((coll, snapshot) => {
          const channel = this.client.channels.resolve(this.reference.channelId);
          const snapshotData = {
            ...snapshot.message,
            id: this.reference.messageId,
            channel_id: this.reference.channelId,
            guild_id: this.reference.guildId
          };
          return coll.set(this.reference.messageId, channel ? channel.messages._add(snapshotData) : new this.constructor(this.client, snapshotData));
        }, new Collection);
      } else {
        this.messageSnapshots ??= new Collection;
      }
      if (data.call) {
        this.call = {
          endedTimestamp: data.call.ended_timestamp ? Date.parse(data.call.ended_timestamp) : null,
          participants: data.call.participants,
          get endedAt() {
            return this.endedTimestamp && new Date(this.endedTimestamp);
          }
        };
      } else {
        this.call ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    get member() {
      return this.guild?.members.resolve(this.author) ?? null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp && new Date(this.editedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
    }
    get hasThread() {
      return this.flags.has(MessageFlags.HasThread);
    }
    get thread() {
      return this.channel?.threads?.cache.get(this.id) ?? null;
    }
    get url() {
      return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
    }
    get cleanContent() {
      return this.content != null && this.channel ? cleanContent(this.content, this.channel) : null;
    }
    createReactionCollector(options = {}) {
      return new ReactionCollector(this, options);
    }
    awaitReactions(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(options);
        collector.once("end", (reactions, reason) => {
          if (options.errors?.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        message: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    get editable() {
      const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable) && this.reference?.type !== MessageReferenceType.Forward);
      if (this.channel?.isThread()) {
        if (this.channel.archived)
          return false;
        if (this.channel.locked) {
          const permissions = this.channel.permissionsFor(this.client.user);
          if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
            return false;
        }
      }
      return precheck;
    }
    get deletable() {
      if (UndeletableMessageTypes.includes(this.type))
        return false;
      if (!this.guild) {
        return this.author.id === this.client.user.id;
      }
      if (!this.channel?.viewable) {
        return false;
      }
      const permissions = this.channel?.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
    }
    get bulkDeletable() {
      return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
    }
    get pinnable() {
      const { channel } = this;
      return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));
    }
    async fetchReference() {
      if (!this.reference)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const { channelId, messageId } = this.reference;
      if (!messageId)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const channel = this.client.channels.resolve(channelId);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const message = await channel.messages.fetch(messageId);
      return message;
    }
    get crosspostable() {
      const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);
      const { channel } = this;
      return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && !this.poll && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));
    }
    async edit(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.edit(this, options);
    }
    async crosspost() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.crosspost(this.id);
    }
    async pin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.pin(this.id, reason);
      return this;
    }
    async unpin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.unpin(this.id, reason);
      return this;
    }
    async react(emoji) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.react(this.id, emoji);
      return this.client.actions.MessageReactionAdd.handle({
        [this.client.actions.injectedUser]: this.client.user,
        [this.client.actions.injectedChannel]: this.channel,
        [this.client.actions.injectedMessage]: this,
        emoji: resolvePartialEmoji(emoji)
      }, true).reaction;
    }
    async delete() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.delete(this.id);
      return this;
    }
    async reply(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      let data;
      if (options instanceof MessagePayload) {
        data = options;
      } else {
        data = MessagePayload.create(this, options, {
          reply: {
            messageReference: this,
            failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
          }
        });
      }
      return this.channel.send(data);
    }
    forward(channel) {
      const resolvedChannel = this.client.channels.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsError(ErrorCodes.InvalidType, "channel", "TextBasedChannelResolvable");
      return resolvedChannel.send({
        forward: {
          message: this.id,
          channel: this.channelId,
          guild: this.guildId
        }
      });
    }
    async startThread(options = {}) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
        throw new DiscordjsError(ErrorCodes.MessageThreadParent);
      }
      if (this.hasThread)
        throw new DiscordjsError(ErrorCodes.MessageExistingThread);
      return this.channel.threads.create({ ...options, startMessage: this });
    }
    async fetch(force = true) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.fetch({ message: this.id, force });
    }
    async fetchWebhook() {
      if (!this.webhookId)
        throw new DiscordjsError(ErrorCodes.WebhookMessage);
      if (this.webhookId === this.applicationId)
        throw new DiscordjsError(ErrorCodes.WebhookApplication);
      return this.client.fetchWebhook(this.webhookId);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlagsBitField(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.SuppressEmbeds);
      } else {
        flags.remove(MessageFlags.SuppressEmbeds);
      }
      return this.edit({ flags });
    }
    removeAttachments() {
      return this.edit({ attachments: [] });
    }
    resolveComponent(customId) {
      return findComponentByCustomId(this.components, customId);
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.nonce === message.nonce && this.tts === message.tts && this.attachments.size === message.attachments.size && this.embeds.length === message.embeds.length && this.attachments.every((attachment) => message.attachments.has(attachment.id)) && this.embeds.every((embed, index) => embed.equals(message.embeds[index]));
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
      }
      return equal;
    }
    inGuild() {
      return Boolean(this.guildId);
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelId",
        author: "authorId",
        groupActivityApplication: "groupActivityApplicationId",
        guild: "guildId",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  }
  exports.Message = Message;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { lazy } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, WebhookType } = require_v106();
  var MessagePayload = require_MessagePayload();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { resolveImage } = require_DataResolver();
  var getMessage = lazy(() => require_Message().Message);

  class Webhook {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      Object.defineProperty(this, "token", {
        value: data.token ?? null,
        writable: true,
        configurable: true
      });
      if ("avatar" in data) {
        this.avatar = data.avatar;
      }
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("user" in data) {
        this.owner = this.client.users?._add(data.user) ?? data.user;
      } else {
        this.owner ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("source_guild" in data) {
        this.sourceGuild = this.client.guilds?.cache.get(data.source_guild.id) ?? data.source_guild;
      } else {
        this.sourceGuild ??= null;
      }
      if ("source_channel" in data) {
        this.sourceChannel = this.client.channels?.cache.get(data.source_channel?.id) ?? data.source_channel;
      } else {
        this.sourceChannel ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    async send(options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const query = makeURLSearchParams({
        wait: true,
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {
        body,
        files,
        query,
        auth: false
      });
      if (!this.client.channels)
        return d;
      return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
    }
    async sendSlackMessage(body) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, "slack"), {
        query: makeURLSearchParams({ wait: true }),
        auth: false,
        body
      });
      return data.toString() === "ok";
    }
    async edit({ name = this.name, avatar, channel, reason }) {
      if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
        avatar = await resolveImage(avatar);
      }
      channel &&= channel.id ?? channel;
      const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {
        body: { name, avatar, channel_id: channel },
        reason,
        auth: !this.token || Boolean(channel)
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelId = data.channel_id;
      return this;
    }
    async fetchMessage(message, { threadId } = {}) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
      if (!this.client.channels)
        return data;
      return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
    }
    async editMessage(message, options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body, files } = await messagePayload.resolveBody().resolveFiles();
      const query = makeURLSearchParams({
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        body,
        files,
        query,
        auth: false
      });
      const channelManager = this.client.channels;
      if (!channelManager)
        return d;
      const messageManager = channelManager.cache.get(d.channel_id)?.messages;
      if (!messageManager)
        return new (getMessage())(this.client, d);
      const existing = messageManager.cache.get(d.id);
      if (!existing)
        return messageManager._add(d);
      const clone = existing._clone();
      clone._patch(d);
      return clone;
    }
    delete(reason) {
      return this.client.deleteWebhook(this.id, { token: this.token, reason });
    }
    async deleteMessage(message, threadId) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.rest.api + Routes.webhook(this.id, this.token);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    isUserCreated() {
      return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
    }
    isApplicationCreated() {
      return this.type === WebhookType.Application;
    }
    isChannelFollower() {
      return this.type === WebhookType.ChannelFollower;
    }
    isIncoming() {
      return this.type === WebhookType.Incoming;
    }
    static applyToClass(structure, ignore = []) {
      for (const prop of [
        "send",
        "sendSlackMessage",
        "fetchMessage",
        "edit",
        "editMessage",
        "delete",
        "deleteMessage",
        "createdTimestamp",
        "createdAt",
        "url"
      ]) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
      }
    }
  }
  module.exports = Webhook;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports, module) => {
  var BaseClient = require_BaseClient();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Webhook = require_Webhook();
  var { parseWebhookURL } = require_Util();

  class WebhookClient extends BaseClient {
    constructor(data, options) {
      super(options);
      Object.defineProperty(this, "client", { value: this });
      let { id, token } = data;
      if ("url" in data) {
        const parsed = parseWebhookURL(data.url);
        if (!parsed) {
          throw new DiscordjsError(ErrorCodes.WebhookURLInvalid);
        }
        ({ id, token } = parsed);
      }
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {}
    fetchMessage() {}
    editMessage() {}
    sendSlackMessage() {}
    edit() {}
    delete() {}
    deleteMessage() {}
    get createdTimestamp() {}
    get createdAt() {}
    get url() {}
  }
  Webhook.applyToClass(WebhookClient);
  module.exports = WebhookClient;
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class VoiceState extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      if ("deaf" in data) {
        this.serverDeaf = data.deaf;
      } else {
        this.serverDeaf ??= null;
      }
      if ("mute" in data) {
        this.serverMute = data.mute;
      } else {
        this.serverMute ??= null;
      }
      if ("self_deaf" in data) {
        this.selfDeaf = data.self_deaf;
      } else {
        this.selfDeaf ??= null;
      }
      if ("self_mute" in data) {
        this.selfMute = data.self_mute;
      } else {
        this.selfMute ??= null;
      }
      if ("self_video" in data) {
        this.selfVideo = data.self_video;
      } else {
        this.selfVideo ??= null;
      }
      if ("session_id" in data) {
        this.sessionId = data.session_id;
      } else {
        this.sessionId ??= null;
      }
      if ("self_video" in data) {
        this.streaming = data.self_stream ?? false;
      } else {
        this.streaming ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("suppress" in data) {
        this.suppress = data.suppress;
      } else {
        this.suppress ??= null;
      }
      if ("request_to_speak_timestamp" in data) {
        this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
      } else {
        this.requestToSpeakTimestamp ??= null;
      }
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    setMute(mute = true, reason) {
      return this.guild.members.edit(this.id, { mute, reason });
    }
    setDeaf(deaf = true, reason) {
      return this.guild.members.edit(this.id, { deaf, reason });
    }
    disconnect(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.guild.members.edit(this.id, { channel, reason });
    }
    async edit(options) {
      if (this.channel?.type !== ChannelType.GuildStageVoice)
        throw new DiscordjsError(ErrorCodes.VoiceNotStageChannel);
      const target = this.client.user.id === this.id ? "@me" : this.id;
      if (target !== "@me" && options.requestToSpeak !== undefined) {
        throw new DiscordjsError(ErrorCodes.VoiceStateNotOwn);
      }
      if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "requestToSpeak");
      }
      if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "suppressed");
      }
      await this.client.rest.patch(Routes.guildVoiceState(this.guild.id, target), {
        body: {
          channel_id: this.channelId,
          request_to_speak_timestamp: options.requestToSpeak ? new Date().toISOString() : options.requestToSpeak === false ? null : undefined,
          suppress: options.suppressed
        }
      });
      return this;
    }
    fetch(force = true) {
      return this.guild.voiceStates.fetch(this.id, { force });
    }
    setRequestToSpeak(requestToSpeak = true) {
      return this.edit({ requestToSpeak });
    }
    setSuppressed(suppressed = true) {
      return this.edit({ suppressed });
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionId: true,
        channelId: "channel"
      });
    }
  }
  module.exports = VoiceState;
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildMemberRoleManager extends DataManager {
    constructor(member) {
      super(member.client, Role);
      this.member = member;
      this.guild = member.guild;
    }
    get cache() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get hoist() {
      const hoistedRoles = this.cache.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get icon() {
      const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
      if (!iconRoles.size)
        return null;
      return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this.cache.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get botRole() {
      if (!this.member.user.bot)
        return null;
      return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.put(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        clone._roles = [...this.cache.keys(), roleOrRoles];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({ roles, reason });
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this.cache.keys()];
      return clone;
    }
  }
  module.exports = GuildMemberRoleManager;
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS((exports) => {
  var { GuildMemberFlags } = require_v106();
  var BitField = require_BitField();

  class GuildMemberFlagsBitField extends BitField {
    static Flags = GuildMemberFlags;
  }
  exports.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports) => {
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var VoiceState = require_VoiceState();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class GuildMember extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.premiumSinceTimestamp = null;
      this.nickname = null;
      this.pending = null;
      this.communicationDisabledUntilTimestamp = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else {
        this.banner ??= null;
      }
      if ("joined_at" in data)
        this.joinedTimestamp = Date.parse(data.joined_at);
      if ("premium_since" in data) {
        this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
      }
      if ("roles" in data)
        this._roles = data.roles;
      if ("pending" in data) {
        this.pending = data.pending;
      } else if (!this.partial) {
        this.pending ??= false;
      }
      if ("communication_disabled_until" in data) {
        this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
      }
      if ("flags" in data) {
        this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new GuildMemberFlagsBitField().freeze();
      }
      if (data.avatar_decoration_data) {
        this.avatarDecorationData = {
          asset: data.avatar_decoration_data.asset,
          skuId: data.avatar_decoration_data.sku_id
        };
      } else {
        this.avatarDecorationData = null;
      }
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return this.joinedTimestamp === null;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get voice() {
      return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
    }
    avatarDecorationURL() {
      return this.avatarDecorationData ? this.client.rest.cdn.avatarDecoration(this.avatarDecorationData.asset) : null;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.guildMemberBanner(this.guild.id, this.id, this.banner, options);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
    }
    displayBannerURL(options) {
      return this.bannerURL(options) ?? this.user.bannerURL(options);
    }
    displayAvatarDecorationURL() {
      return this.avatarDecorationURL() ?? this.user.avatarDecorationURL();
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get communicationDisabledUntil() {
      return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
    }
    get premiumSince() {
      return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
    }
    get presence() {
      return this.guild.presences.cache.get(this.id) ?? null;
    }
    get displayColor() {
      return this.roles.color?.color ?? 0;
    }
    get displayHexColor() {
      return this.roles.color?.hexColor ?? "#000000";
    }
    get id() {
      return this.user.id;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    get displayName() {
      return this.nickname ?? this.user.displayName;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerId)
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      return new PermissionsBitField(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerId)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerId)
        return true;
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
    }
    get bannable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
    }
    get moderatable() {
      return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
    }
    isCommunicationDisabled() {
      return this.communicationDisabledUntilTimestamp > Date.now();
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.permissionsFor(this);
    }
    edit(options) {
      return this.guild.members.edit(this, options);
    }
    setFlags(flags, reason) {
      return this.edit({ flags, reason });
    }
    setNickname(nick, reason) {
      return this.edit({ nick, reason });
    }
    createDM(force = false) {
      return this.user.createDM(force);
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.guild.members.kick(this, reason);
    }
    ban(options) {
      return this.guild.bans.create(this, options);
    }
    disableCommunicationUntil(communicationDisabledUntil, reason) {
      return this.edit({ communicationDisabledUntil, reason });
    }
    timeout(timeout, reason) {
      return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
    }
    fetch(force = true) {
      return this.guild.members.fetch({ user: this.id, cache: true, force });
    }
    equals(member) {
      return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.banner === member.banner && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, index) => role === member._roles[index])) && this.avatarDecorationData?.asset === member.avatarDecorationData?.asset && this.avatarDecorationData?.skuId === member.avatarDecorationData?.skuId;
    }
    toString() {
      return this.user.toString();
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        user: "userId",
        displayName: true,
        roles: true
      });
      json.avatarURL = this.avatarURL();
      json.bannerURL = this.bannerURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.displayBannerURL = this.displayBannerURL();
      json.avatarDecorationURL = this.avatarDecorationURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(GuildMember);
  exports.GuildMember = GuildMember;
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Message } = require_Message();
  var MessagePayload = require_MessagePayload();
  var { MakeCacheOverrideSymbol } = require_Symbols();
  var { resolvePartialEmoji } = require_Util();

  class MessageManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = MessageManager;
    constructor(channel, iterable) {
      super(channel.client, Message, iterable);
      this.channel = channel;
    }
    _add(data, cache) {
      return super._add(data, cache);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { message, cache, force } = options;
      const resolvedMessage = this.resolveId(message ?? options);
      if (resolvedMessage)
        return this._fetchSingle({ message: resolvedMessage, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ message, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(message);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection);
    }
    async fetchPinned(cache = true) {
      const data = await this.client.rest.get(Routes.channelPins(this.channel.id));
      const messages = new Collection;
      for (const message of data)
        messages.set(message.id, this._add(message, cache));
      return messages;
    }
    async edit(message, options) {
      const messageId = this.resolveId(message);
      if (!messageId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });
      const existing = this.cache.get(messageId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async crosspost(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));
      return this.cache.get(data.id) ?? this._add(data);
    }
    async pin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.put(Routes.channelPin(this.channel.id, message), { reason });
    }
    async unpin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelPin(this.channel.id, message), { reason });
    }
    async react(message, emoji) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      emoji = resolvePartialEmoji(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.EmojiType, "emoji", "EmojiIdentifierResolvable");
      const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
      await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));
    }
    async delete(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));
    }
    async endPoll(messageId) {
      const message = await this.client.rest.post(Routes.expirePoll(this.channel.id, messageId));
      return this._add(message, false);
    }
    async fetchPollAnswerVoters({ messageId, answerId, after, limit }) {
      const voters = await this.client.rest.get(Routes.pollAnswerVoters(this.channel.id, messageId, answerId), {
        query: makeURLSearchParams({ limit, after })
      });
      return voters.users.reduce((acc, user) => acc.set(user.id, this.client.users._add(user, false)), new Collection);
    }
  }
  module.exports = MessageManager;
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS((exports, module) => {
  var Webhook = require_Webhook();

  class InteractionWebhook {
    constructor(client, id, token) {
      Object.defineProperty(this, "client", { value: client });
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {}
    fetchMessage() {}
    editMessage() {}
    deleteMessage() {}
    get url() {}
  }
  Webhook.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
  module.exports = InteractionWebhook;
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var { lazy, isJSONEncodable } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { MessageFlags, MessageReferenceType } = require_v106();
  var { DiscordjsError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var { resolveFile } = require_DataResolver();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var { basename, verifyString, resolvePartialEmoji } = require_Util();
  var getBaseInteraction = lazy(() => require_BaseInteraction());

  class MessagePayload {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.body = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const { Message } = require_Message();
      return this.target instanceof Message;
    }
    get isMessageManager() {
      const MessageManager = require_MessageManager();
      return this.target instanceof MessageManager;
    }
    get isInteraction() {
      const BaseInteraction = getBaseInteraction();
      const InteractionWebhook = require_InteractionWebhook();
      return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
    }
    makeContent() {
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (this.options.content !== undefined) {
        content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);
      }
      return content;
    }
    resolveBody() {
      if (this.body)
        return this;
      const isInteraction = this.isInteraction;
      const isWebhook = this.isWebhook;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (this.options.nonce !== undefined) {
        nonce = this.options.nonce;
        if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
          throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);
        }
      }
      let enforce_nonce = Boolean(this.options.enforceNonce);
      if (nonce === undefined) {
        if (this.options.enforceNonce !== false && this.target.client.options.enforceNonce) {
          nonce = DiscordSnowflake.generate().toString();
          enforce_nonce = true;
        } else if (enforce_nonce) {
          throw new DiscordjsError(ErrorCodes.MessageNonceRequired);
        }
      }
      const components = this.options.components?.map((component) => isJSONEncodable(component) ? component.toJSON() : this.target.client.options.jsonTransformer(component));
      let username;
      let avatarURL;
      let threadName;
      let appliedTags;
      if (isWebhook) {
        username = this.options.username ?? this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
        if (this.options.threadName)
          threadName = this.options.threadName;
        if (this.options.appliedTags)
          appliedTags = this.options.appliedTags;
      }
      let flags;
      if (this.options.flags != null) {
        flags = new MessageFlagsBitField(this.options.flags).bitfield;
      }
      if (isInteraction && this.options.ephemeral) {
        flags |= MessageFlags.Ephemeral;
      }
      let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (allowedMentions?.repliedUser !== undefined) {
        allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
        delete allowedMentions.repliedUser;
      }
      let message_reference;
      if (typeof this.options.reply === "object") {
        const reference = this.options.reply.messageReference;
        const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
        if (message_id) {
          message_reference = {
            message_id,
            fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
          };
        }
      }
      if (typeof this.options.forward === "object") {
        const reference = this.options.forward.message;
        const channel_id = reference.channelId ?? this.target.client.channels.resolveId(this.options.forward.channel);
        const guild_id = reference.guildId ?? this.target.client.guilds.resolveId(this.options.forward.guild);
        const message_id = this.target.messages.resolveId(reference);
        if (message_id) {
          if (!channel_id)
            throw new DiscordjsError(ErrorCodes.InvalidType, "channelId", "TextBasedChannelResolvable");
          message_reference = {
            type: MessageReferenceType.Forward,
            message_id,
            channel_id,
            guild_id: guild_id ?? undefined
          };
        }
      }
      const attachments = this.options.files?.map((file, index) => ({
        id: index.toString(),
        description: file.description
      }));
      if (Array.isArray(this.options.attachments)) {
        this.options.attachments.push(...attachments ?? []);
      } else {
        this.options.attachments = attachments;
      }
      let poll;
      if (this.options.poll) {
        poll = {
          question: {
            text: this.options.poll.question.text
          },
          answers: this.options.poll.answers.map((answer) => ({
            poll_media: { text: answer.text, emoji: resolvePartialEmoji(answer.emoji) }
          })),
          duration: this.options.poll.duration,
          allow_multiselect: this.options.poll.allowMultiselect,
          layout_type: this.options.poll.layoutType
        };
      }
      this.body = {
        content,
        tts,
        nonce,
        enforce_nonce,
        embeds: this.options.embeds?.map((embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),
        components,
        username,
        avatar_url: avatarURL,
        allowed_mentions: this.isMessage && message_reference === undefined && this.target.author.id !== this.target.client.user.id ? undefined : allowedMentions,
        flags,
        message_reference,
        attachments: this.options.attachments,
        sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
        thread_name: threadName,
        applied_tags: appliedTags,
        poll
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
      return this;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return basename(thing);
        }
        if (thing.path) {
          return basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name ?? findName(attachment);
      }
      const { data, contentType } = await resolveFile(attachment);
      return { data, name, contentType };
    }
    static create(target, options, extra = {}) {
      return new this(target, typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra });
    }
  }
  module.exports = MessagePayload;
});

// node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class GuildMessageManager extends MessageManager {
  }
  module.exports = GuildMessageManager;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, Routes } = require_v106();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { MaxBulkDeletableMessageAge } = require_Constants();
  var InteractionCollector = require_InteractionCollector();
  var MessageCollector = require_MessageCollector();
  var MessagePayload = require_MessagePayload();

  class TextBasedChannel {
    constructor() {
      this.messages = new GuildMessageManager(this);
      this.lastMessageId = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.resolve(this.lastMessageId);
    }
    get lastPinAt() {
      return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
    }
    async send(options) {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        const dm = await this.createDM();
        return dm.send(options);
      }
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });
      return this.messages.cache.get(d.id) ?? this.messages._add(d);
    }
    async sendTyping() {
      await this.client.rest.post(Routes.channelTyping(this.id));
    }
    createMessageCollector(options = {}) {
      return new MessageCollector(this, options);
    }
    awaitMessages(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(options);
        collector.once("end", (collection, reason) => {
          if (options.errors?.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        channel: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection) {
        let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map((message) => message.id ?? message);
        if (filterOld) {
          messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);
        }
        if (messageIds.length === 0)
          return new Collection;
        if (messageIds.length === 1) {
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIds[0]
          }, this);
          await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));
          return message ? new Collection([[message.id, message]]) : new Collection;
        }
        await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });
        return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection);
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({ limit: messages });
        return this.bulkDelete(msgs, filterOld);
      }
      throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);
    }
    fetchWebhooks() {
      return this.guild.channels.fetchWebhooks(this.id);
    }
    createWebhook(options) {
      return this.guild.channels.createWebhook({ channel: this.id, ...options });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setNSFW(nsfw = true, reason) {
      return this.edit({ nsfw, reason });
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "sendTyping", "createMessageCollector", "awaitMessages", "createMessageComponentCollector", "awaitMessageComponent", "fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  }
  module.exports = TextBasedChannel;
  var GuildMessageManager = require_GuildMessageManager();
});

// node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class DMMessageManager extends MessageManager {
  }
  module.exports = DMMessageManager;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var DMMessageManager = require_DMMessageManager();
  var Partials = require_Partials();

  class DMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.type = ChannelType.DM;
      this.messages = new DMMessageManager(this);
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        const recipient = data.recipients[0];
        this.recipientId = recipient.id;
        if ("username" in recipient || this.client.options.partials.includes(Partials.User)) {
          this.client.users._add(recipient);
        }
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    get partial() {
      return this.lastMessageId === undefined;
    }
    get recipient() {
      return this.client.users.resolve(this.recipientId);
    }
    fetch(force = true) {
      return this.client.users.createDM(this.recipientId, { force });
    }
    toString() {
      return userMention(this.recipientId);
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
  }
  TextBasedChannel.applyToClass(DMChannel, true, [
    "bulkDelete",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = DMChannel;
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();

  class GuildForumThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      message,
      reason,
      rateLimitPerUser,
      appliedTags
    } = {}) {
      if (!message) {
        throw new DiscordjsTypeError(ErrorCodes.GuildForumMessageRequired);
      }
      const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
      const data = await this.client.rest.post(Routes.threads(this.channel.id), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          rate_limit_per_user: rateLimitPerUser,
          applied_tags: appliedTags,
          message: body
        },
        files,
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildForumThreadManager;
});

// node_modules/discord.js/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildForumThreadManager = require_GuildForumThreadManager();
  var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();

  class ThreadOnlyChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.threads = new GuildForumThreadManager(this);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("available_tags" in data) {
        this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
      } else {
        this.availableTags ??= [];
      }
      if ("default_reaction_emoji" in data) {
        this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
      } else {
        this.defaultReactionEmoji ??= null;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      } else {
        this.defaultAutoArchiveDuration ??= null;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      } else {
        this.nsfw ??= false;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("default_sort_order" in data) {
        this.defaultSortOrder = data.default_sort_order;
      } else {
        this.defaultSortOrder ??= null;
      }
    }
    setAvailableTags(availableTags, reason) {
      return this.edit({ availableTags, reason });
    }
    setDefaultReactionEmoji(defaultReactionEmoji, reason) {
      return this.edit({ defaultReactionEmoji, reason });
    }
    setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
      return this.edit({ defaultThreadRateLimitPerUser, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    setDefaultSortOrder(defaultSortOrder, reason) {
      return this.edit({ defaultSortOrder, reason });
    }
    createWebhook() {}
    fetchWebhooks() {}
    setNSFW() {}
    setRateLimitPerUser() {}
  }
  TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
    "send",
    "lastMessage",
    "lastPinAt",
    "bulkDelete",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "createMessageComponentCollector",
    "awaitMessageComponent"
  ]);
  module.exports = ThreadOnlyChannel;
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS((exports, module) => {
  var BitField = require_BitField();

  class ThreadMemberFlagsBitField extends BitField {
    static Flags = {};
  }
  module.exports = ThreadMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS((exports, module) => {
  var Base = require_Base();
  var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();

  class ThreadMember extends Base {
    constructor(thread, data, extra = {}) {
      super(thread.client);
      this.thread = thread;
      this.joinedTimestamp = null;
      this.flags = null;
      this.id = data.user_id;
      this._patch(data, extra);
    }
    _patch(data, extra = {}) {
      if ("join_timestamp" in data)
        this.joinedTimestamp = Date.parse(data.join_timestamp);
      if ("flags" in data)
        this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      if ("member" in data) {
        this.member = this.thread.guild.members._add(data.member, extra.cache);
      } else {
        this.member ??= null;
      }
    }
    get partial() {
      return this.flags === null;
    }
    get guildMember() {
      return this.member ?? this.thread.guild.members.cache.get(this.id) ?? null;
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get user() {
      return this.client.users.cache.get(this.id) ?? null;
    }
    get manageable() {
      return !this.thread.archived && this.thread.editable;
    }
    async remove(reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      await this.thread.members.remove(this.id, reason);
      return this;
    }
  }
  module.exports = ThreadMember;
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadMember = require_ThreadMember();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();
  var deprecationEmittedForAdd = false;

  class ThreadMemberManager extends CachedManager {
    constructor(thread, iterable) {
      super(thread.client, ThreadMember, iterable);
      this.thread = thread;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (cache)
        existing?._patch(data, { cache });
      if (existing)
        return existing;
      const member = new ThreadMember(this.thread, data, { cache });
      if (cache)
        this.cache.set(data.user_id, member);
      return member;
    }
    fetchMe(options) {
      return this.fetch({ ...options, member: this.client.user.id });
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? null;
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return super.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(member, reason) {
      if (reason !== undefined && !deprecationEmittedForAdd) {
        process2.emitWarning("The reason parameter of ThreadMemberManager#add() is deprecated as Discord does not parse them. It will be removed in the next major version.", "DeprecationWarning");
        deprecationEmittedForAdd = true;
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    async remove(member, reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { member, withMember, cache, force } = options;
      const resolvedMember = this.resolveId(member ?? options);
      if (resolvedMember)
        return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ member, withMember, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(member);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member), {
        query: makeURLSearchParams({ with_member: withMember })
      });
      return this._add(data, cache);
    }
    async _fetchMany({ withMember, after, limit, cache } = {}) {
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id), {
        query: makeURLSearchParams({ with_member: withMember, after, limit })
      });
      return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection);
    }
  }
  module.exports = ThreadMemberManager;
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS((exports, module) => {
  var { DiscordAPIError } = require_dist5();
  var { lazy } = require_dist();
  var { RESTJSONErrorCodes, ChannelFlags, ChannelType, PermissionFlagsBits, Routes } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var getThreadOnlyChannel = lazy(() => require_ThreadOnlyChannel());
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();
  var GuildMessageManager = require_GuildMessageManager();
  var ThreadMemberManager = require_ThreadMemberManager();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();

  class ThreadChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(guild?.client ?? client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.ownerId = data.owner_id;
      this.messages = new GuildMessageManager(this);
      this.members = new ThreadMemberManager(this);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("message" in data)
        this.messages._add(data.message);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("thread_metadata" in data) {
        this.locked = data.thread_metadata.locked ?? false;
        this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
        this.archived = data.thread_metadata.archived;
        this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
        this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
        if ("create_timestamp" in data.thread_metadata) {
          this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
        }
      } else {
        this.locked ??= null;
        this.archived ??= null;
        this.autoArchiveDuration ??= null;
        this.archiveTimestamp ??= null;
        this.invitable ??= null;
      }
      this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("message_count" in data) {
        this.messageCount = data.message_count;
      } else {
        this.messageCount ??= null;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("total_message_sent" in data) {
        this.totalMessageSent = data.total_message_sent;
      } else {
        this.totalMessageSent ??= null;
      }
      if (data.member && this.client.user)
        this.members._add({ user_id: this.client.user.id, ...data.member });
      if (data.messages)
        for (const message of data.messages)
          this.messages._add(message);
      if ("applied_tags" in data) {
        this.appliedTags = data.applied_tags;
      } else {
        this.appliedTags ??= [];
      }
    }
    get createdTimestamp() {
      return this._createdTimestamp;
    }
    get guildMembers() {
      return this.members.cache.mapValues((member) => member.guildMember);
    }
    get archivedAt() {
      return this.archiveTimestamp && new Date(this.archiveTimestamp);
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    async join() {
      await this.members.add("@me");
      return this;
    }
    async leave() {
      await this.members.remove("@me");
      return this;
    }
    permissionsFor(memberOrRole, checkAdmin) {
      return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
    }
    async fetchOwner(options) {
      const member = await this.members._fetchSingle({ ...options, member: this.ownerId }).catch((error) => {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownMember) {
          return null;
        }
        throw error;
      });
      return member;
    }
    async fetchStarterMessage(options) {
      const channel = this.parent instanceof getThreadOnlyChannel() ? this : this.parent;
      return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
    }
    async edit(options) {
      const newData = await this.client.rest.patch(Routes.channel(this.id), {
        body: {
          name: (options.name ?? this.name).trim(),
          archived: options.archived,
          auto_archive_duration: options.autoArchiveDuration,
          rate_limit_per_user: options.rateLimitPerUser,
          locked: options.locked,
          invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,
          applied_tags: options.appliedTags,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    setArchived(archived = true, reason) {
      return this.edit({ archived, reason });
    }
    setAutoArchiveDuration(autoArchiveDuration, reason) {
      return this.edit({ autoArchiveDuration, reason });
    }
    async setInvitable(invitable = true, reason) {
      if (this.type !== ChannelType.PrivateThread) {
        throw new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type);
      }
      return this.edit({ invitable, reason });
    }
    setLocked(locked = true, reason) {
      return this.edit({ locked, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setAppliedTags(appliedTags, reason) {
      return this.edit({ appliedTags, reason });
    }
    pin(reason) {
      return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
    }
    unpin(reason) {
      return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
    }
    get joined() {
      return this.members.cache.has(this.client.user?.id);
    }
    get editable() {
      return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
    }
    get joinable() {
      return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);
    }
    get manageable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    get sendable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
    }
    get unarchivable() {
      return this.archived && this.sendable && (!this.locked || this.manageable);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
  }
  TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
  module.exports = ThreadChannel;
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadChannel = require_ThreadChannel();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class ThreadManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = ThreadManager;
    constructor(channel, iterable) {
      super(channel.client, ThreadChannel, iterable);
      this.channel = channel;
    }
    _add(thread) {
      const existing = this.cache.get(thread.id);
      if (existing)
        return existing;
      this.cache.set(thread.id, thread);
      return thread;
    }
    fetch(options, { cache, force } = {}) {
      if (!options)
        return this.fetchActive(cache);
      const channel = this.client.channels.resolveId(options);
      if (channel)
        return this.client.channels.fetch(channel, { cache, force });
      if (options.archived) {
        return this.fetchArchived(options.archived, cache);
      }
      return this.fetchActive(cache);
    }
    async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
      let path = Routes.channelThreads(this.channel.id, type);
      if (type === "private" && !fetchAll) {
        path = Routes.channelJoinedArchivedThreads(this.channel.id);
      }
      let timestamp;
      let id;
      const query = makeURLSearchParams({ limit });
      if (before !== undefined) {
        if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
          id = this.resolveId(before);
          timestamp = this.resolve(before)?.archivedAt?.toISOString();
          const toUse = type === "private" && !fetchAll ? id : timestamp;
          if (toUse) {
            query.set("before", toUse);
          }
        } else {
          try {
            timestamp = new Date(before).toISOString();
            if (type === "public" || fetchAll) {
              query.set("before", timestamp);
            }
          } catch {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
          }
        }
      }
      const raw = await this.client.rest.get(path, { query });
      return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
    }
    async fetchActive(cache = true) {
      const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
      return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
    }
    static _mapThreads(rawThreads, client, { parent, guild, cache }) {
      const threads = rawThreads.threads.reduce((coll, raw) => {
        const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });
        if (parent && thread.parentId !== parent.id)
          return coll;
        return coll.set(thread.id, thread);
      }, new Collection);
      const threadMembers = rawThreads.members.reduce((coll, raw) => {
        const thread = threads.get(raw.id);
        return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;
      }, new Collection);
      const response = { threads, members: threadMembers };
      if ("has_more" in rawThreads)
        response.hasMore = rawThreads.has_more;
      return response;
    }
  }
  module.exports = ThreadManager;
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class GuildTextThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      startMessage,
      type,
      invitable,
      reason,
      rateLimitPerUser
    } = {}) {
      let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
      let startMessageId;
      if (startMessage) {
        startMessageId = this.channel.messages.resolveId(startMessage);
        if (!startMessageId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "startMessage", "MessageResolvable");
      } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
        resolvedType = type ?? resolvedType;
      }
      const data = await this.client.rest.post(Routes.threads(this.channel.id, startMessageId), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          type: resolvedType,
          invitable: resolvedType === ChannelType.PrivateThread ? invitable : undefined,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildTextThreadManager;
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();

  class BaseGuildTextChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.threads = new GuildTextThreadManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("nsfw" in data) {
        this.nsfw = Boolean(data.nsfw);
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setType(type, reason) {
      return this.edit({ type, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
    fetchWebhooks() {}
    createWebhook() {}
    setRateLimitPerUser() {}
    setNSFW() {}
  }
  TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
  module.exports = BaseGuildTextChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var BaseGuildTextChannel = require_BaseGuildTextChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class NewsChannel extends BaseGuildTextChannel {
    async addFollower(channel, reason) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      await this.client.rest.post(Routes.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
      return this;
    }
  }
  module.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { PermissionFlagsBits } = require_v106();
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();

  class BaseGuildVoiceChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("rtc_region" in data) {
        this.rtcRegion = data.rtc_region;
      }
      if ("bitrate" in data) {
        this.bitrate = data.bitrate;
      }
      if ("user_limit" in data) {
        this.userLimit = data.user_limit;
      }
      if ("video_quality_mode" in data) {
        this.videoQualityMode = data.video_quality_mode;
      } else {
        this.videoQualityMode ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      }
    }
    get members() {
      const coll = new Collection;
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelId === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get joinable() {
      if (!this.viewable)
        return false;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setBitrate(bitrate, reason) {
      return this.edit({ bitrate, reason });
    }
    setRTCRegion(rtcRegion, reason) {
      return this.edit({ rtcRegion, reason });
    }
    setUserLimit(userLimit, reason) {
      return this.edit({ userLimit, reason });
    }
    setVideoQualityMode(videoQualityMode, reason) {
      return this.edit({ videoQualityMode, reason });
    }
    get lastMessage() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
    fetchWebhooks() {}
    createWebhook() {}
    setRateLimitPerUser() {}
    setNSFW() {}
  }
  TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
  module.exports = BaseGuildVoiceChannel;
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS((exports, module) => {
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class StageChannel extends BaseGuildVoiceChannel {
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
    }
    get stageInstance() {
      return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
    }
    createStageInstance(options) {
      return this.guild.stageInstances.create(this.id, options);
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
  }
  module.exports = StageChannel;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports, module) => {
  var BaseGuildTextChannel = require_BaseGuildTextChannel();

  class TextChannel extends BaseGuildTextChannel {
    _patch(data) {
      super._patch(data);
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
  }
  module.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports, module) => {
  var { PermissionFlagsBits, Routes } = require_v106();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class VoiceChannel extends BaseGuildVoiceChannel {
    get joinable() {
      if (!super.joinable)
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
        return false;
      return true;
    }
    get speakable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
    }
    async sendSoundboardSound(sound) {
      await this.client.rest.post(Routes.sendSoundboardSound(this.id), {
        body: {
          sound_id: sound.soundId,
          source_guild_id: sound.guildId ?? undefined
        }
      });
    }
  }
  module.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();

  class DirectoryChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(client, data);
      this.guild = guild;
      this.guildId = guild.id;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
    }
  }
  module.exports = DirectoryChannel;
});

// node_modules/discord.js/src/managers/PartialGroupDMMessageManager.js
var require_PartialGroupDMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class PartialGroupDMMessageManager extends MessageManager {
  }
  module.exports = PartialGroupDMMessageManager;
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PartialGroupDMMessageManager = require_PartialGroupDMMessageManager();

  class PartialGroupDMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.flags = null;
      this.name = data.name;
      this.icon = data.icon ?? null;
      this.recipients = data.recipients ?? [];
      this.messages = new PartialGroupDMMessageManager(this);
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      } else {
        this.ownerId ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "group DM");
      }
      return this.client.users.fetch(this.ownerId, options);
    }
    async delete() {
      throw new DiscordjsError(ErrorCodes.DeleteGroupDMChannel);
    }
    async fetch() {
      throw new DiscordjsError(ErrorCodes.FetchGroupDMChannel);
    }
    get lastMessage() {}
    get lastPinAt() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
  }
  TextBasedChannel.applyToClass(PartialGroupDMChannel, true, [
    "bulkDelete",
    "send",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = PartialGroupDMChannel;
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class ForumChannel extends ThreadOnlyChannel {
    _patch(data) {
      super._patch(data);
      this.defaultForumLayout = data.default_forum_layout;
    }
    setDefaultForumLayout(defaultForumLayout, reason) {
      return this.edit({ defaultForumLayout, reason });
    }
  }
  module.exports = ForumChannel;
});

// node_modules/discord.js/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class MediaChannel extends ThreadOnlyChannel {
  }
  module.exports = MediaChannel;
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ChannelType } = require_v106();
  var getCategoryChannel = lazy(() => require_CategoryChannel());
  var getDMChannel = lazy(() => require_DMChannel());
  var getNewsChannel = lazy(() => require_NewsChannel());
  var getStageChannel = lazy(() => require_StageChannel());
  var getTextChannel = lazy(() => require_TextChannel());
  var getThreadChannel = lazy(() => require_ThreadChannel());
  var getVoiceChannel = lazy(() => require_VoiceChannel());
  var getDirectoryChannel = lazy(() => require_DirectoryChannel());
  var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
  var getForumChannel = lazy(() => require_ForumChannel());
  var getMediaChannel = lazy(() => require_MediaChannel());
  function createChannel(client, data, guild, { allowUnknownGuild } = {}) {
    let channel;
    if (!data.guild_id && !guild) {
      if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
        channel = new (getDMChannel())(client, data);
      } else if (data.type === ChannelType.GroupDM) {
        channel = new (getPartialGroupDMChannel())(client, data);
      }
    } else {
      guild ??= client.guilds.cache.get(data.guild_id);
      if (guild || allowUnknownGuild) {
        switch (data.type) {
          case ChannelType.GuildText: {
            channel = new (getTextChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildVoice: {
            channel = new (getVoiceChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildCategory: {
            channel = new (getCategoryChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildAnnouncement: {
            channel = new (getNewsChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildStageVoice: {
            channel = new (getStageChannel())(guild, data, client);
            break;
          }
          case ChannelType.AnnouncementThread:
          case ChannelType.PublicThread:
          case ChannelType.PrivateThread: {
            channel = new (getThreadChannel())(guild, data, client);
            if (!allowUnknownGuild)
              channel.parent?.threads.cache.set(channel.id, channel);
            break;
          }
          case ChannelType.GuildDirectory:
            channel = new (getDirectoryChannel())(guild, data, client);
            break;
          case ChannelType.GuildForum:
            channel = new (getForumChannel())(guild, data, client);
            break;
          case ChannelType.GuildMedia:
            channel = new (getMediaChannel())(guild, data, client);
            break;
        }
        if (channel && !allowUnknownGuild)
          guild.channels?.cache.set(channel.id, channel);
      }
    }
    return channel;
  }
  function transformAPIGuildForumTag(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji: tag.emoji_id ?? tag.emoji_name ? {
        id: tag.emoji_id,
        name: tag.emoji_name
      } : null
    };
  }
  function transformGuildForumTag(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji_id: tag.emoji?.id ?? null,
      emoji_name: tag.emoji?.name ?? null
    };
  }
  function transformAPIGuildDefaultReaction(defaultReaction) {
    return {
      id: defaultReaction.emoji_id,
      name: defaultReaction.emoji_name
    };
  }
  function transformGuildDefaultReaction(defaultReaction) {
    return {
      emoji_id: defaultReaction.id,
      emoji_name: defaultReaction.name
    };
  }
  module.exports = {
    createChannel,
    transformAPIGuildForumTag,
    transformGuildForumTag,
    transformAPIGuildDefaultReaction,
    transformGuildDefaultReaction
  };
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var { createChannel } = require_Channels();

  class ChannelUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (channel.type !== data.type) {
          const newChannel = createChannel(this.client, data, channel.guild);
          if (!newChannel) {
            this.client.channels.cache.delete(channel.id);
            return {};
          }
          if (channel.isTextBased() && newChannel.isTextBased()) {
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
          }
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      } else {
        client.channels._add(data);
      }
      return {};
    }
  }
  module.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/client/actions/EntitlementCreate.js
var require_EntitlementCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementCreate, entitlement);
      return {};
    }
  }
  module.exports = EntitlementCreateAction;
});

// node_modules/discord.js/src/client/actions/EntitlementDelete.js
var require_EntitlementDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data, false);
      client.application.entitlements.cache.delete(entitlement.id);
      client.emit(Events.EntitlementDelete, entitlement);
      return {};
    }
  }
  module.exports = EntitlementDeleteAction;
});

// node_modules/discord.js/src/client/actions/EntitlementUpdate.js
var require_EntitlementUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const oldEntitlement = client.application.entitlements.cache.get(data.id)?._clone() ?? null;
      const newEntitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementUpdate, oldEntitlement, newEntitlement);
      return {};
    }
  }
  module.exports = EntitlementUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationRule extends Base {
    constructor(client, data, guild) {
      super(client);
      this.id = data.id;
      this.guild = guild;
      this.creatorId = data.creator_id;
      this.triggerType = data.trigger_type;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("event_type" in data) {
        this.eventType = data.event_type;
      }
      if ("trigger_metadata" in data) {
        this.triggerMetadata = {
          keywordFilter: data.trigger_metadata.keyword_filter ?? [],
          regexPatterns: data.trigger_metadata.regex_patterns ?? [],
          presets: data.trigger_metadata.presets ?? [],
          allowList: data.trigger_metadata.allow_list ?? [],
          mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
          mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
        };
      }
      if ("actions" in data) {
        this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
      }
      if ("enabled" in data) {
        this.enabled = data.enabled;
      }
      if ("exempt_roles" in data) {
        this.exemptRoles = new Collection(data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)]));
      }
      if ("exempt_channels" in data) {
        this.exemptChannels = new Collection(data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)]));
      }
    }
    edit(options) {
      return this.guild.autoModerationRules.edit(this.id, options);
    }
    delete(reason) {
      return this.guild.autoModerationRules.delete(this.id, reason);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setEventType(eventType, reason) {
      return this.edit({ eventType, reason });
    }
    setKeywordFilter(keywordFilter, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
    }
    setRegexPatterns(regexPatterns, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
    }
    setPresets(presets, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
    }
    setAllowList(allowList, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
    }
    setMentionTotalLimit(mentionTotalLimit, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
    }
    setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
    }
    setActions(actions, reason) {
      return this.edit({ actions, reason });
    }
    setEnabled(enabled = true, reason) {
      return this.edit({ enabled, reason });
    }
    setExemptRoles(exemptRoles, reason) {
      return this.edit({ exemptRoles, reason });
    }
    setExemptChannels(exemptChannels, reason) {
      return this.edit({ exemptChannels, reason });
    }
  }
  module.exports = AutoModerationRule;
});

// node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class GuildOnboardingPromptOption extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      const guild = this.guild;
      this.id = data.id;
      this.channels = data.channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.roles = data.role_ids.reduce((roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)), new Collection);
      this._emoji = data.emoji;
      this.title = data.title;
      this.description = data.description;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
    get emoji() {
      if (!this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  exports.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
});

// node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();

  class GuildOnboardingPrompt extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      this.id = data.id;
      this.options = data.options.reduce((options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)), new Collection);
      this.title = data.title;
      this.singleSelect = data.single_select;
      this.required = data.required;
      this.inOnboarding = data.in_onboarding;
      this.type = data.type;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPrompt = GuildOnboardingPrompt;
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();

  class Integration extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled ?? null;
      if ("syncing" in data) {
        this.syncing = data.syncing;
      } else {
        this.syncing ??= null;
      }
      this.role = this.guild.roles.resolve(data.role_id);
      if ("enable_emoticons" in data) {
        this.enableEmoticons = data.enable_emoticons;
      } else {
        this.enableEmoticons ??= null;
      }
      if (data.user) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
      this.account = data.account;
      if ("synced_at" in data) {
        this.syncedTimestamp = Date.parse(data.synced_at);
      } else {
        this.syncedTimestamp ??= null;
      }
      if ("subscriber_count" in data) {
        this.subscriberCount = data.subscriber_count;
      } else {
        this.subscriberCount ??= null;
      }
      if ("revoked" in data) {
        this.revoked = data.revoked;
      } else {
        this.revoked ??= null;
      }
      this._patch(data);
    }
    get syncedAt() {
      return this.syncedTimestamp && new Date(this.syncedTimestamp);
    }
    get roles() {
      const roles = this.guild.roles.cache;
      return roles.filter((role) => role.tags?.integrationId === this.id);
    }
    _patch(data) {
      if ("expire_behavior" in data) {
        this.expireBehavior = data.expire_behavior;
      } else {
        this.expireBehavior ??= null;
      }
      if ("expire_grace_period" in data) {
        this.expireGracePeriod = data.expire_grace_period;
      } else {
        this.expireGracePeriod ??= null;
      }
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else {
        this.application ??= null;
      }
      if ("scopes" in data) {
        this.scopes = data.scopes;
      } else {
        this.scopes ??= [];
      }
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.guildIntegration(this.guild.id, this.id), { reason });
      return this;
    }
    toJSON() {
      return super.toJSON({
        role: "roleId",
        guild: "guildId",
        user: "userId"
      });
    }
  }
  module.exports = Integration;
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class StageInstance extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      }
      if ("discoverable_disabled" in data) {
        this.discoverableDisabled = data.discoverable_disabled;
      } else {
        this.discoverableDisabled ??= null;
      }
      if ("guild_scheduled_event_id" in data) {
        this.guildScheduledEventId = data.guild_scheduled_event_id;
      } else {
        this.guildScheduledEventId ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get guildScheduledEvent() {
      return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
    }
    edit(options) {
      return this.guild.stageInstances.edit(this.channelId, options);
    }
    async delete() {
      await this.guild.stageInstances.delete(this.channelId);
      const clone = this._clone();
      return clone;
    }
    setTopic(topic) {
      return this.guild.stageInstances.edit(this.channelId, { topic });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  exports.StageInstance = StageInstance;
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { AuditLogOptionsType, AuditLogEvent } = require_v106();
  var AutoModerationRule = require_AutoModerationRule();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var Integration = require_Integration();
  var Invite = require_Invite();
  var { StageInstance } = require_StageInstance();
  var { Sticker } = require_Sticker();
  var Webhook = require_Webhook();
  var Partials = require_Partials();
  var { flatten } = require_Util();
  var Targets = {
    All: "All",
    Guild: "Guild",
    GuildScheduledEvent: "GuildScheduledEvent",
    Channel: "Channel",
    User: "User",
    Role: "Role",
    Invite: "Invite",
    Webhook: "Webhook",
    Emoji: "Emoji",
    Message: "Message",
    Integration: "Integration",
    StageInstance: "StageInstance",
    Sticker: "Sticker",
    Thread: "Thread",
    ApplicationCommand: "ApplicationCommand",
    AutoModeration: "AutoModeration",
    GuildOnboarding: "GuildOnboarding",
    GuildOnboardingPrompt: "GuildOnboardingPrompt",
    SoundboardSound: "SoundboardSound",
    Unknown: "Unknown"
  };
  function changesReduce(changes, initialData = {}) {
    return changes.reduce((accumulator, change) => {
      accumulator[change.key] = change.new ?? change.old;
      return accumulator;
    }, initialData);
  }

  class GuildAuditLogsEntry {
    static Targets = Targets;
    constructor(guild, data, logs) {
      this.targetType = GuildAuditLogsEntry.targetType(data.action_type);
      const targetType = this.targetType;
      this.actionType = GuildAuditLogsEntry.actionType(data.action_type);
      this.action = data.action_type;
      this.reason = data.reason ?? null;
      this.executorId = data.user_id;
      this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
      this.changes = data.changes?.map((change) => ({
        key: change.key,
        ..."old_value" in change ? { old: change.old_value } : {},
        ..."new_value" in change ? { new: change.new_value } : {}
      })) ?? [];
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case AuditLogEvent.MemberPrune:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case AuditLogEvent.MemberMove:
        case AuditLogEvent.MessageDelete:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.MessagePin:
        case AuditLogEvent.MessageUnpin:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            messageId: data.options.message_id
          };
          break;
        case AuditLogEvent.MessageBulkDelete:
        case AuditLogEvent.MemberDisconnect:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.ChannelOverwriteCreate:
        case AuditLogEvent.ChannelOverwriteUpdate:
        case AuditLogEvent.ChannelOverwriteDelete:
          switch (data.options.type) {
            case AuditLogOptionsType.Role:
              this.extra = guild.roles.cache.get(data.options.id) ?? {
                id: data.options.id,
                name: data.options.role_name,
                type: AuditLogOptionsType.Role
              };
              break;
            case AuditLogOptionsType.Member:
              this.extra = guild.members.cache.get(data.options.id) ?? {
                id: data.options.id,
                type: AuditLogOptionsType.Member
              };
              break;
            default:
              break;
          }
          break;
        case AuditLogEvent.StageInstanceCreate:
        case AuditLogEvent.StageInstanceDelete:
        case AuditLogEvent.StageInstanceUpdate:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.ApplicationCommandPermissionUpdate:
          this.extra = {
            applicationId: data.options.application_id
          };
          break;
        case AuditLogEvent.AutoModerationBlockMessage:
        case AuditLogEvent.AutoModerationFlagToChannel:
        case AuditLogEvent.AutoModerationUserCommunicationDisabled:
          this.extra = {
            autoModerationRuleName: data.options.auto_moderation_rule_name,
            autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.MemberKick:
        case AuditLogEvent.MemberRoleUpdate: {
          if (data.integration_type) {
            this.extra = {
              integrationType: data.integration_type
            };
          }
          break;
        }
        default:
          break;
      }
      this.targetId = data.target_id;
      this.target = null;
      if (targetType === Targets.Unknown) {
        this.target = changesReduce(this.changes);
        this.target.id = data.target_id;
      } else if (targetType === Targets.User && data.target_id) {
        this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Guild) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.Webhook) {
        this.target = logs?.webhooks.get(data.target_id) ?? new Webhook(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Invite) {
        const inviteChange = this.changes.find(({ key }) => key === "code");
        this.target = guild.invites.cache.get(inviteChange.new ?? inviteChange.old) ?? new Invite(guild.client, changesReduce(this.changes, { guild }));
      } else if (targetType === Targets.Message) {
        this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Integration) {
        this.target = logs?.integrations.get(data.target_id) ?? new Integration(guild.client, changesReduce(this.changes, { id: data.target_id }), guild);
      } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
        this.target = guild.channels.cache.get(data.target_id) ?? changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.StageInstance) {
        this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          channel_id: data.options?.channel_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Sticker) {
        this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker(guild.client, changesReduce(this.changes, { id: data.target_id }));
      } else if (targetType === Targets.GuildScheduledEvent) {
        this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }));
      } else if (targetType === Targets.ApplicationCommand) {
        this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.AutoModeration) {
        this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }), guild);
      } else if (targetType === Targets.GuildOnboardingPrompt) {
        this.target = data.action_type === AuditLogEvent.OnboardingPromptCreate ? new GuildOnboardingPrompt(guild.client, changesReduce(this.changes, { id: data.target_id }), guild.id) : changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.Role) {
        this.target = guild.roles.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.Emoji) {
        this.target = guild.emojis.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.SoundboardSound) {
        this.target = guild.soundboardSounds.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (data.target_id) {
        this.target = { id: data.target_id };
      }
    }
    static targetType(target) {
      if (target < 10)
        return Targets.Guild;
      if (target < 20)
        return Targets.Channel;
      if (target < 30)
        return Targets.User;
      if (target < 40)
        return Targets.Role;
      if (target < 50)
        return Targets.Invite;
      if (target < 60)
        return Targets.Webhook;
      if (target < 70)
        return Targets.Emoji;
      if (target < 80)
        return Targets.Message;
      if (target < 83)
        return Targets.Integration;
      if (target < 86)
        return Targets.StageInstance;
      if (target < 100)
        return Targets.Sticker;
      if (target < 110)
        return Targets.GuildScheduledEvent;
      if (target < 120)
        return Targets.Thread;
      if (target < 130)
        return Targets.ApplicationCommand;
      if (target < 140)
        return Targets.SoundboardSound;
      if (target < 143)
        return Targets.AutoModeration;
      if (target < 146)
        return Targets.User;
      if (target >= 163 && target <= 165)
        return Targets.GuildOnboardingPrompt;
      if (target >= 160 && target < 170)
        return Targets.GuildOnboarding;
      return Targets.Unknown;
    }
    static actionType(action) {
      if ([
        AuditLogEvent.ChannelCreate,
        AuditLogEvent.ChannelOverwriteCreate,
        AuditLogEvent.MemberBanRemove,
        AuditLogEvent.BotAdd,
        AuditLogEvent.RoleCreate,
        AuditLogEvent.InviteCreate,
        AuditLogEvent.WebhookCreate,
        AuditLogEvent.EmojiCreate,
        AuditLogEvent.MessagePin,
        AuditLogEvent.IntegrationCreate,
        AuditLogEvent.StageInstanceCreate,
        AuditLogEvent.StickerCreate,
        AuditLogEvent.GuildScheduledEventCreate,
        AuditLogEvent.ThreadCreate,
        AuditLogEvent.SoundboardSoundCreate,
        AuditLogEvent.AutoModerationRuleCreate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.OnboardingPromptCreate,
        AuditLogEvent.OnboardingCreate
      ].includes(action)) {
        return "Create";
      }
      if ([
        AuditLogEvent.ChannelDelete,
        AuditLogEvent.ChannelOverwriteDelete,
        AuditLogEvent.MemberKick,
        AuditLogEvent.MemberPrune,
        AuditLogEvent.MemberBanAdd,
        AuditLogEvent.MemberDisconnect,
        AuditLogEvent.RoleDelete,
        AuditLogEvent.InviteDelete,
        AuditLogEvent.WebhookDelete,
        AuditLogEvent.EmojiDelete,
        AuditLogEvent.MessageDelete,
        AuditLogEvent.MessageBulkDelete,
        AuditLogEvent.MessageUnpin,
        AuditLogEvent.IntegrationDelete,
        AuditLogEvent.StageInstanceDelete,
        AuditLogEvent.StickerDelete,
        AuditLogEvent.GuildScheduledEventDelete,
        AuditLogEvent.ThreadDelete,
        AuditLogEvent.SoundboardSoundDelete,
        AuditLogEvent.AutoModerationRuleDelete,
        AuditLogEvent.OnboardingPromptDelete
      ].includes(action)) {
        return "Delete";
      }
      if ([
        AuditLogEvent.GuildUpdate,
        AuditLogEvent.ChannelUpdate,
        AuditLogEvent.ChannelOverwriteUpdate,
        AuditLogEvent.MemberUpdate,
        AuditLogEvent.MemberRoleUpdate,
        AuditLogEvent.MemberMove,
        AuditLogEvent.RoleUpdate,
        AuditLogEvent.InviteUpdate,
        AuditLogEvent.WebhookUpdate,
        AuditLogEvent.EmojiUpdate,
        AuditLogEvent.IntegrationUpdate,
        AuditLogEvent.StageInstanceUpdate,
        AuditLogEvent.StickerUpdate,
        AuditLogEvent.GuildScheduledEventUpdate,
        AuditLogEvent.ThreadUpdate,
        AuditLogEvent.SoundboardSoundUpdate,
        AuditLogEvent.ApplicationCommandPermissionUpdate,
        AuditLogEvent.AutoModerationRuleUpdate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.AutoModerationFlagToChannel,
        AuditLogEvent.AutoModerationUserCommunicationDisabled,
        AuditLogEvent.OnboardingPromptUpdate,
        AuditLogEvent.OnboardingUpdate
      ].includes(action)) {
        return "Update";
      }
      return "All";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return flatten(this, { createdTimestamp: true });
    }
  }
  module.exports = GuildAuditLogsEntry;
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Events = require_Events();

  class GuildAuditLogEntryCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let auditLogEntry;
      if (guild) {
        auditLogEntry = new GuildAuditLogsEntry(guild, data);
        client.emit(Events.GuildAuditLogEntryCreate, auditLogEntry, guild);
      }
      return { auditLogEntry };
    }
  }
  module.exports = GuildAuditLogEntryCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildBanAdd extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildBanAdd, guild.bans._add(data));
    }
  }
  module.exports = GuildBanAdd;
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS((exports, module) => {
  var Base = require_Base();

  class GuildBan extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("reason" in data) {
        this.reason = data.reason;
      }
    }
    get partial() {
      return !("reason" in this);
    }
    fetch(force = true) {
      return this.guild.bans.fetch({ user: this.user, cache: true, force });
    }
  }
  module.exports = GuildBan;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildBan = require_GuildBan();
  var Events = require_Events();

  class GuildBanRemove extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
        guild.bans.cache.delete(ban.user.id);
        client.emit(Events.GuildBanRemove, ban);
      }
    }
  }
  module.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildChannelsPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events.GuildUnavailable, guild);
          return;
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels._remove(channel.id);
        client.voice.adapters.get(data.id)?.destroy();
        client.guilds.cache.delete(guild.id);
        client.emit(Events.GuildDelete, guild);
      }
    }
  }
  module.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiCreateAction extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis._add(createdEmoji);
      if (!already)
        this.client.emit(Events.GuildEmojiCreate, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiDeleteAction extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      this.client.emit(Events.GuildEmojiDelete, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildEmojiUpdate, old, current);
      return { emoji: current };
    }
  }
  module.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildEmojisUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  }
  module.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildIntegrationsUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildIntegrationsUpdate, guild);
    }
  }
  module.exports = GuildIntegrationsUpdate;
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "Ready",
    "Connecting",
    "Reconnecting",
    "Idle",
    "Nearly",
    "Disconnected",
    "WaitingForGuilds",
    "Identifying",
    "Resuming"
  ]);
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberRemoveAction extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({ user: data.user }, guild);
        guild.memberCount--;
        if (member) {
          guild.members.cache.delete(member.id);
          if (shard.status === Status.Ready)
            client.emit(Events.GuildMemberRemove, member);
        }
        guild.presences.cache.delete(data.user.id);
        guild.voiceStates.cache.delete(data.user.id);
      }
      return { guild, member };
    }
  }
  module.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberUpdateAction extends Action {
    handle(data, shard) {
      const { client } = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users._add(data.user);
        } else if (!user._equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({ user: data.user }, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status.Ready && !member.equals(old))
            client.emit(Events.GuildMemberUpdate, old, member);
        } else {
          const newMember = guild.members._add(data);
          this.client.emit(Events.GuildMemberAvailable, newMember);
        }
      }
    }
  }
  module.exports = GuildMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleCreate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles._add(data.role);
        if (!already)
          client.emit(Events.GuildRoleCreate, role);
      }
      return { role };
    }
  }
  module.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          client.emit(Events.GuildRoleDelete, role);
        }
      }
      return { role };
    }
  }
  module.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events.GuildRoleUpdate, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildRolesPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventCreate, guildScheduledEvent);
        return { guildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        if (guildScheduledEvent) {
          guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
          client.emit(Events.GuildScheduledEventDelete, guildScheduledEvent);
          return { guildScheduledEvent };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
        const newGuildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
        return { oldGuildScheduledEvent, newGuildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserAddAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserAdd, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserAddAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserRemoveAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserRemove, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildSoundboardSoundDelete.js
var require_GuildSoundboardSoundDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildSoundboardSoundDeleteAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      const soundboardSound = this.getSoundboardSound(data, guild);
      if (soundboardSound) {
        guild.soundboardSounds.cache.delete(soundboardSound.soundId);
        this.client.emit(Events.GuildSoundboardSoundDelete, soundboardSound);
      }
      return { soundboardSound };
    }
  }
  module.exports = GuildSoundboardSoundDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerCreateAction extends Action {
    handle(guild, createdSticker) {
      const already = guild.stickers.cache.has(createdSticker.id);
      const sticker = guild.stickers._add(createdSticker);
      if (!already)
        this.client.emit(Events.GuildStickerCreate, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerDeleteAction extends Action {
    handle(sticker) {
      sticker.guild.stickers.cache.delete(sticker.id);
      this.client.emit(Events.GuildStickerDelete, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildStickerUpdate, old, current);
      return { sticker: current };
    }
  }
  module.exports = GuildStickerUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildStickersUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.stickers)
        return;
      const deletions = new Map(guild.stickers.cache);
      for (const sticker of data.stickers) {
        const cachedSticker = guild.stickers.cache.get(sticker.id);
        if (cachedSticker) {
          deletions.delete(sticker.id);
          if (!cachedSticker.equals(sticker)) {
            this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
          }
        } else {
          this.client.actions.GuildStickerCreate.handle(guild, sticker);
        }
      }
      for (const sticker of deletions.values()) {
        this.client.actions.GuildStickerDelete.handle(sticker);
      }
    }
  }
  module.exports = GuildStickersUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events.GuildUpdate, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS((exports, module) => {
  var { ApplicationCommandOptionType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class CommandInteractionOptionResolver {
    constructor(client, options, resolved) {
      Object.defineProperty(this, "client", { value: client });
      this._group = null;
      this._subcommand = null;
      this._hoistedOptions = options;
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
        this._group = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
        this._subcommand = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
      Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
    }
    get(name, required = false) {
      const option = this._hoistedOptions.find((opt) => opt.name === name);
      if (!option) {
        if (required) {
          throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);
        }
        return null;
      }
      return option;
    }
    _getTypedOption(name, allowedTypes, properties, required) {
      const option = this.get(name, required);
      if (!option) {
        return null;
      } else if (!allowedTypes.includes(option.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
      } else if (required && properties.every((prop) => option[prop] === null || option[prop] === undefined)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);
      }
      return option;
    }
    getSubcommand(required = true) {
      if (required && !this._subcommand) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);
      }
      return this._subcommand;
    }
    getSubcommandGroup(required = false) {
      if (required && !this._group) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);
      }
      return this._group;
    }
    getBoolean(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
      return option?.value ?? null;
    }
    getChannel(name, required = false, channelTypes = []) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
      const channel = option?.channel ?? null;
      if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionInvalidChannelType, name, channel.type, channelTypes.join(", "));
      }
      return channel;
    }
    getString(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
      return option?.value ?? null;
    }
    getInteger(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
      return option?.value ?? null;
    }
    getNumber(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
      return option?.value ?? null;
    }
    getUser(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["user"], required);
      return option?.user ?? null;
    }
    getMember(name) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["member"], false);
      return option?.member ?? null;
    }
    getRole(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable], ["role"], required);
      return option?.role ?? null;
    }
    getAttachment(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
      return option?.attachment ?? null;
    }
    getMentionable(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Mentionable], ["user", "member", "role"], required);
      return option?.member ?? option?.user ?? option?.role ?? null;
    }
    getMessage(name, required = false) {
      const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
      return option?.message ?? null;
    }
    getFocused(getFull = false) {
      const focusedOption = this._hoistedOptions.find((option) => option.focused);
      if (!focusedOption)
        throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);
      return getFull ? focusedOption : focusedOption.value;
    }
  }
  module.exports = CommandInteractionOptionResolver;
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS((exports, module) => {
  var { InteractionResponseType, Routes } = require_v106();
  var BaseInteraction = require_BaseInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class AutocompleteInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.responded = false;
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    async respond(options) {
      if (this.responded)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ApplicationCommandAutocompleteResult,
          data: {
            choices: options.map(({ nameLocalizations, ...option }) => ({
              ...this.client.options.jsonTransformer(option),
              name_localizations: nameLocalizations
            }))
          }
        },
        auth: false
      });
      this.responded = true;
    }
  }
  module.exports = AutocompleteInteraction;
});

// node_modules/discord.js/src/structures/InteractionCallback.js
var require_InteractionCallback = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();

  class InteractionCallback {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.id = data.id;
      this.type = data.type;
      this.activityInstanceId = data.activity_instance_id ?? null;
      this.responseMessageId = data.response_message_id ?? null;
      this.responseMessageLoading = data.response_message_loading ?? null;
      this.responseMessageEphemeral = data.response_message_ephemeral ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  module.exports = InteractionCallback;
});

// node_modules/discord.js/src/structures/InteractionCallbackResource.js
var require_InteractionCallbackResource = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var getMessage = lazy(() => require_Message().Message);

  class InteractionCallbackResource {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.type = data.type;
      this.activityInstance = data.activity_instance ?? null;
      if ("message" in data) {
        this.message = this.client.channels.cache.get(data.message.channel_id)?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      } else {
        this.message = null;
      }
    }
  }
  module.exports = InteractionCallbackResource;
});

// node_modules/discord.js/src/structures/InteractionCallbackResponse.js
var require_InteractionCallbackResponse = __commonJS((exports, module) => {
  var InteractionCallback = require_InteractionCallback();
  var InteractionCallbackResource = require_InteractionCallbackResource();

  class InteractionCallbackResponse {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.interaction = new InteractionCallback(client, data.interaction);
      this.resource = data.resource ? new InteractionCallbackResource(client, data.resource) : null;
    }
  }
  module.exports = InteractionCallbackResponse;
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class InteractionResponse {
    constructor(interaction, id) {
      this.interaction = interaction;
      this.id = id ?? interaction.id;
      this.client = interaction.client;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionResponse: this,
        interactionType: InteractionType.MessageComponent
      });
    }
    fetch() {
      return this.interaction.fetchReply();
    }
    delete() {
      return this.interaction.deleteReply();
    }
    edit(options) {
      return this.interaction.editReply(options);
    }
  }
  var InteractionCollector = require_InteractionCollector();
  module.exports = InteractionResponse;
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { deprecate } = __require("node:util");
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { InteractionResponseType, MessageFlags, Routes, InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var InteractionCallbackResponse = require_InteractionCallbackResponse();
  var InteractionCollector = require_InteractionCollector();
  var InteractionResponse = require_InteractionResponse();
  var MessagePayload = require_MessagePayload();
  var deprecationEmittedForEphemeralOption = false;
  var deprecationEmittedForFetchReplyOption = false;

  class InteractionResponses {
    async deferReply(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("ephemeral" in options) {
        if (!deprecationEmittedForEphemeralOption) {
          process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
          deprecationEmittedForEphemeralOption = true;
        }
      }
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const flags = new MessageFlagsBitField(options.flags);
      if (options.ephemeral) {
        flags.add(MessageFlags.Ephemeral);
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredChannelMessageWithSource,
          data: {
            flags: flags.bitfield
          }
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      this.ephemeral = flags.has(MessageFlags.Ephemeral);
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    async reply(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string") {
        if ("ephemeral" in options) {
          if (!deprecationEmittedForEphemeralOption) {
            process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
            deprecationEmittedForEphemeralOption = true;
          }
        }
        if ("fetchReply" in options) {
          if (!deprecationEmittedForFetchReplyOption) {
            process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
            deprecationEmittedForFetchReplyOption = true;
          }
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ChannelMessageWithSource,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.ephemeral = Boolean(data.flags & MessageFlags.Ephemeral);
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    fetchReply(message = "@original") {
      return this.webhook.fetchMessage(message);
    }
    async editReply(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.editMessage(options.message ?? "@original", options);
      this.replied = true;
      return msg;
    }
    async deleteReply(message = "@original") {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      await this.webhook.deleteMessage(message);
    }
    async followUp(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.send(options);
      this.replied = true;
      return msg;
    }
    async deferUpdate(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredMessageUpdate
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interactionMetadata?.id);
    }
    async update(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string" && "fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.UpdateMessage,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interactionMetadata?.id);
    }
    async launchActivity({ withResponse } = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        query: makeURLSearchParams({ with_response: withResponse ?? false }),
        body: {
          type: InteractionResponseType.LaunchActivity
        },
        auth: false
      });
      this.replied = true;
      return withResponse ? new InteractionCallbackResponse(this.client, response) : undefined;
    }
    async showModal(modal, options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.Modal,
          data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : undefined;
    }
    async sendPremiumRequired() {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.PremiumRequired
        },
        auth: false
      });
      this.replied = true;
    }
    async awaitModalSubmit(options) {
      if (typeof options.time !== "number")
        throw new DiscordjsError(ErrorCodes.InvalidType, "time", "number");
      const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
      return new Promise((resolve, reject) => {
        const collector = new InteractionCollector(this.client, _options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    static applyToClass(structure, ignore = []) {
      const props = [
        "deferReply",
        "reply",
        "fetchReply",
        "editReply",
        "deleteReply",
        "followUp",
        "deferUpdate",
        "update",
        "launchActivity",
        "showModal",
        "sendPremiumRequired",
        "awaitModalSubmit"
      ];
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));
      }
    }
  }
  InteractionResponses.prototype.sendPremiumRequired = deprecate(InteractionResponses.prototype.sendPremiumRequired, "InteractionResponses#sendPremiumRequired() is deprecated. Sending a premium-style button is the new Discord behaviour.");
  module.exports = InteractionResponses;
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();
  var { findComponentByCustomId } = require_Components();
  var getMessage = lazy(() => require_Message().Message);

  class MessageComponentInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      this.customId = data.data.custom_id;
      this.componentType = data.data.component_type;
      this.deferred = false;
      this.ephemeral = null;
      this.replied = false;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get component() {
      return findComponentByCustomId(this.message.components, this.customId);
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    deferUpdate() {}
    update() {}
    launchActivity() {}
    showModal() {}
    sendPremiumRequired() {}
    awaitModalSubmit() {}
  }
  InteractionResponses.applyToClass(MessageComponentInteraction);
  module.exports = MessageComponentInteraction;
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ButtonInteraction extends MessageComponentInteraction {
  }
  module.exports = ButtonInteraction;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ChannelSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.channels = new Collection;
      for (const channel of Object.values(resolved?.channels ?? {})) {
        this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
      }
    }
  }
  module.exports = ChannelSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS((exports, module) => {
  var Attachment = require_Attachment();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();

  class CommandInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    transformOption(option, resolved) {
      const result = {
        name: option.name,
        type: option.type
      };
      if ("value" in option)
        result.value = option.value;
      if ("options" in option)
        result.options = option.options.map((opt) => this.transformOption(opt, resolved));
      if (resolved) {
        const user = resolved.users?.[option.value];
        if (user)
          result.user = this.client.users._add(user);
        const member = resolved.members?.[option.value];
        if (member)
          result.member = this.guild?.members._add({ user, ...member }) ?? member;
        const channel = resolved.channels?.[option.value];
        if (channel)
          result.channel = this.client.channels._add(channel, this.guild) ?? channel;
        const role = resolved.roles?.[option.value];
        if (role)
          result.role = this.guild?.roles._add(role) ?? role;
        const attachment = resolved.attachments?.[option.value];
        if (attachment)
          result.attachment = new Attachment(attachment);
      }
      return result;
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    launchActivity() {}
    showModal() {}
    sendPremiumRequired() {}
    awaitModalSubmit() {}
  }
  InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
  module.exports = CommandInteraction;
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();

  class ChatInputCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [], transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
    }
    toString() {
      const properties = [
        this.commandName,
        this.options._group,
        this.options._subcommand,
        ...this.options._hoistedOptions.map((option) => `${option.name}:${option.value}`)
      ];
      return `/${properties.filter(Boolean).join(" ")}`;
    }
  }
  module.exports = ChatInputCommandInteraction;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class MentionableSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      const { members, users, roles } = resolved ?? {};
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      this.roles = new Collection;
      if (members) {
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          if (!user) {
            this.client.emit(Events.Debug, `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
      if (users) {
        for (const user of Object.values(users)) {
          this.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        for (const role of Object.values(roles)) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    }
  }
  module.exports = MentionableSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ApplicationCommandOptionType } = require_v106();
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();
  var getMessage = lazy(() => require_Message().Message);

  class ContextMenuCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, this.resolveContextMenuOptions(data.data), transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
      this.targetId = data.data.target_id;
    }
    resolveContextMenuOptions({ target_id, resolved }) {
      const result = [];
      if (resolved.users?.[target_id]) {
        result.push(this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved));
      }
      if (resolved.messages?.[target_id]) {
        result.push({
          name: "message",
          type: "_MESSAGE",
          value: target_id,
          message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
        });
      }
      return result;
    }
  }
  module.exports = ContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class MessageContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetMessage() {
      return this.options.getMessage("message");
    }
  }
  module.exports = MessageContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ComponentType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ModalSubmitFields {
    constructor(components) {
      this.components = components;
      this.fields = components.reduce((accumulator, next) => {
        next.components.forEach((component) => accumulator.set(component.customId, component));
        return accumulator;
      }, new Collection);
    }
    getField(customId, type) {
      const field = this.fields.get(customId);
      if (!field)
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldNotFound, customId);
      if (type !== undefined && type !== field.type) {
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldType, customId, field.type, type);
      }
      return field;
    }
    getTextInputValue(customId) {
      return this.getField(customId, ComponentType.TextInput).value;
    }
  }
  module.exports = ModalSubmitFields;
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var ModalSubmitFields = require_ModalSubmitFields();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class ModalSubmitInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.customId = data.data.custom_id;
      if ("message" in data) {
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
      } else {
        this.message = null;
      }
      this.components = data.data.components?.map((component) => ModalSubmitInteraction.transformComponent(component));
      this.fields = new ModalSubmitFields(this.components);
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    static transformComponent(rawComponent) {
      return rawComponent.components ? {
        type: rawComponent.type,
        components: rawComponent.components.map((component) => this.transformComponent(component))
      } : {
        value: rawComponent.value,
        type: rawComponent.type,
        customId: rawComponent.custom_id
      };
    }
    isFromMessage() {
      return Boolean(this.message);
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    deferUpdate() {}
    update() {}
    sendPremiumRequired() {}
    launchActivity() {}
  }
  InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
  module.exports = ModalSubmitInteraction;
});

// node_modules/discord.js/src/structures/PrimaryEntryPointCommandInteraction.js
var require_PrimaryEntryPointCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();

  class PrimaryEntryPointCommandInteraction extends CommandInteraction {
  }
  module.exports = PrimaryEntryPointCommandInteraction;
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class RoleSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.roles = new Collection;
      for (const role of Object.values(resolved?.roles ?? {})) {
        this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
      }
    }
  }
  module.exports = RoleSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class StringSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      this.values = data.data.values ?? [];
    }
  }
  module.exports = StringSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class UserContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetUser() {
      return this.options.getUser("user");
    }
    get targetMember() {
      return this.options.getMember("user");
    }
  }
  module.exports = UserContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class UserSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      for (const user of Object.values(resolved?.users ?? {})) {
        this.users.set(user.id, this.client.users._add(user));
      }
      for (const [id, member] of Object.entries(resolved?.members ?? {})) {
        const user = resolved.users[id];
        if (!user) {
          this.client.emit(Events.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
          continue;
        }
        this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
      }
    }
  }
  module.exports = UserSelectMenuInteraction;
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS((exports, module) => {
  var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
  var Action = require_Action();
  var AutocompleteInteraction = require_AutocompleteInteraction();
  var ButtonInteraction = require_ButtonInteraction();
  var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  var ModalSubmitInteraction = require_ModalSubmitInteraction();
  var PrimaryEntryPointCommandInteraction = require_PrimaryEntryPointCommandInteraction();
  var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  var Events = require_Events();

  class InteractionCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = data.channel && this.getChannel(data.channel);
      let InteractionClass;
      switch (data.type) {
        case InteractionType.ApplicationCommand:
          switch (data.data.type) {
            case ApplicationCommandType.ChatInput:
              InteractionClass = ChatInputCommandInteraction;
              break;
            case ApplicationCommandType.User:
              InteractionClass = UserContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.Message:
              if (channel && !channel.isTextBased())
                return;
              InteractionClass = MessageContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.PrimaryEntryPoint:
              InteractionClass = PrimaryEntryPointCommandInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`);
              return;
          }
          break;
        case InteractionType.MessageComponent:
          if (channel && !channel.isTextBased())
            return;
          switch (data.data.component_type) {
            case ComponentType.Button:
              InteractionClass = ButtonInteraction;
              break;
            case ComponentType.StringSelect:
              InteractionClass = StringSelectMenuInteraction;
              break;
            case ComponentType.UserSelect:
              InteractionClass = UserSelectMenuInteraction;
              break;
            case ComponentType.RoleSelect:
              InteractionClass = RoleSelectMenuInteraction;
              break;
            case ComponentType.MentionableSelect:
              InteractionClass = MentionableSelectMenuInteraction;
              break;
            case ComponentType.ChannelSelect:
              InteractionClass = ChannelSelectMenuInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);
              return;
          }
          break;
        case InteractionType.ApplicationCommandAutocomplete:
          InteractionClass = AutocompleteInteraction;
          break;
        case InteractionType.ModalSubmit:
          InteractionClass = ModalSubmitInteraction;
          break;
        default:
          client.emit(Events.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
          return;
      }
      const interaction = new InteractionClass(client, data);
      client.emit(Events.InteractionCreate, interaction);
    }
  }
  module.exports = InteractionCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class InviteCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = guild.invites._add(inviteData);
      client.emit(Events.InviteCreate, invite);
      return { invite };
    }
  }
  module.exports = InviteCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Invite = require_Invite();
  var Events = require_Events();

  class InviteDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = new Invite(client, inviteData);
      guild.invites.cache.delete(invite.code);
      client.emit(Events.InviteDelete, invite);
      return { invite };
    }
  }
  module.exports = InviteDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({
        id: data.channel_id,
        author: data.author,
        ..."guild_id" in data && { guild_id: data.guild_id }
      });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread()) {
          channel.messageCount++;
          channel.totalMessageSent++;
        }
        const existing = channel.messages.cache.get(data.id);
        if (existing && existing.author?.id !== this.client.user.id)
          return { message: existing };
        const message = existing ?? channel.messages._add(data);
        channel.lastMessageId = data.id;
        client.emit(Events.MessageCreate, message);
        return { message };
      }
      return {};
    }
  }
  module.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      let message;
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount--;
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          client.emit(Events.MessageDelete, message);
        }
      }
      return { message };
    }
  }
  module.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteBulkAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount -= data.ids.length;
        const ids = data.ids;
        const messages = new Collection;
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events.MessageBulkDelete, messages, channel);
        return { messages };
      }
      return {};
    }
  }
  module.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessagePollVoteAdd.js
var require_MessagePollVoteAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteAddAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount++;
      this.client.emit(Events.MessagePollVoteAdd, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteAddAction;
});

// node_modules/discord.js/src/client/actions/MessagePollVoteRemove.js
var require_MessagePollVoteRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteRemoveAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount--;
      this.client.emit(Events.MessagePollVoteRemove, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteRemoveAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class MessageReactionAdd extends Action {
    handle(data, fromStructure = false) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id,
        ...this.spreadInjectedData(data)
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const includePartial = this.client.options.partials.includes(Partials.Reaction);
      if (message.partial && !includePartial)
        return false;
      const reaction = message.reactions._add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id,
        burst_colors: data.burst_colors
      });
      if (!reaction)
        return false;
      reaction._add(user, data.burst);
      if (fromStructure)
        return { message, reaction, user };
      this.client.emit(Events.MessageReactionAdd, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemove extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user, data.burst);
      this.client.emit(Events.MessageReactionRemove, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveAll extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const removed = message.reactions.cache.clone();
      message.reactions.cache.clear();
      this.client.emit(Events.MessageReactionRemoveAll, message, removed);
      return { message };
    }
  }
  module.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveEmoji extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
      this.client.emit(Events.MessageReactionRemoveEmoji, reaction);
      return { reaction };
    }
  }
  module.exports = MessageReactionRemoveEmoji;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class MessageUpdateAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        const { id, channel_id, guild_id, author, timestamp, type } = data;
        const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
        if (message) {
          const old = message._update(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  }
  module.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class PresenceUpdateAction extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && (("username" in data.user) || this.client.options.partials.includes(Partials.User))) {
        user = this.client.users._add(data.user);
      }
      if (!user)
        return;
      if (data.user.username) {
        if (!user._equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members._add({
          user,
          deaf: false,
          mute: false
        });
        this.client.emit(Events.GuildMemberAvailable, member);
      }
      const newPresence = guild.presences._add(Object.assign(data, { guild }));
      if (this.client.listenerCount(Events.PresenceUpdate) && !newPresence.equals(oldPresence)) {
        this.client.emit(Events.PresenceUpdate, oldPresence, newPresence);
      }
    }
  }
  module.exports = PresenceUpdateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceCreate, stageInstance);
        return { stageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceCreateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        if (stageInstance) {
          channel.guild.stageInstances.cache.delete(stageInstance.id);
          client.emit(Events.StageInstanceDelete, stageInstance);
          return { stageInstance };
        }
      }
      return {};
    }
  }
  module.exports = StageInstanceDeleteAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
        const newStageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceUpdate, oldStageInstance, newStageInstance);
        return { oldStageInstance, newStageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const thread = client.channels._add(data);
      if (!existing && thread) {
        client.emit(Events.ThreadCreate, thread, data.newly_created ?? false);
      }
      return { thread };
    }
  }
  module.exports = ThreadCreateAction;
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        client.channels._remove(thread.id);
        client.emit(Events.ThreadDelete, thread);
      }
      return { thread };
    }
  }
  module.exports = ThreadDeleteAction;
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadListSyncAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      if (data.channel_ids) {
        for (const id of data.channel_ids) {
          const channel = client.channels.cache.get(id);
          if (channel)
            this.removeStale(channel);
        }
      } else {
        for (const channel of guild.channels.cache.values()) {
          this.removeStale(channel);
        }
      }
      const syncedThreads = data.threads.reduce((coll, rawThread) => {
        const thread = client.channels._add(rawThread);
        return coll.set(thread.id, thread);
      }, new Collection);
      for (const rawMember of Object.values(data.members)) {
        const thread = client.channels.cache.get(rawMember.id);
        if (thread) {
          thread.members._add(rawMember);
        }
      }
      client.emit(Events.ThreadListSync, syncedThreads, guild);
      return {
        syncedThreads
      };
    }
    removeStale(channel) {
      channel.threads?.cache.forEach((thread) => {
        if (!thread.archived) {
          this.client.channels._remove(thread.id);
        }
      });
    }
  }
  module.exports = ThreadListSyncAction;
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMemberUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        const member = thread.members.cache.get(data.user_id);
        if (!member) {
          const newMember = thread.members._add(data);
          return { newMember };
        }
        const old = member._update(data);
        client.emit(Events.ThreadMemberUpdate, old, member);
      }
      return {};
    }
  }
  module.exports = ThreadMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMembersUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        thread.memberCount = data.member_count;
        const addedMembers = new Collection;
        const removedMembers = new Collection;
        data.added_members?.reduce((_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)), addedMembers);
        data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
          const threadMember = this.getThreadMember(removedMembersId, thread.members);
          if (threadMember)
            removedMembersIds.set(threadMember.id, threadMember);
          thread.members.cache.delete(removedMembersId);
          return removedMembersIds;
        }, removedMembers);
        if (addedMembers.size === 0 && removedMembers.size === 0) {
          return {};
        }
        client.emit(Events.ThreadMembersUpdate, addedMembers, removedMembers, thread);
      }
      return {};
    }
  }
  module.exports = ThreadMembersUpdateAction;
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS((exports, module) => {
  var Base = require_Base();

  class Typing extends Base {
    constructor(channel, user, data) {
      super(channel.client);
      this.channel = channel;
      this.user = user;
      this._patch(data);
    }
    _patch(data) {
      if ("timestamp" in data) {
        this.startedTimestamp = data.timestamp * 1000;
      }
    }
    inGuild() {
      return this.guild !== null;
    }
    get startedAt() {
      return new Date(this.startedTimestamp);
    }
    get guild() {
      return this.channel.guild ?? null;
    }
    get member() {
      return this.guild?.members.resolve(this.user) ?? null;
    }
  }
  module.exports = Typing;
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports, module) => {
  var Action = require_Action();
  var Typing = require_Typing();
  var Events = require_Events();

  class TypingStart extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel)
        return;
      if (!channel.isTextBased()) {
        this.client.emit(Events.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      if (user) {
        this.client.emit(Events.TypingStart, new Typing(channel, user, data));
      }
    }
  }
  module.exports = TypingStart;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class UserUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events.UserUpdate, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var VoiceState = require_VoiceState();
  var Events = require_Events();

  class VoiceStateUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
        const newState = guild.voiceStates._add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member?.user && data.member.joined_at) {
          member = guild.members._add(data.member);
        }
        if (member?.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events.VoiceStateUpdate, oldState, newState);
      }
    }
  }
  module.exports = VoiceStateUpdate;
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var Action = require_Action();
  var deprecationEmitted = false;

  class WebhooksUpdate extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (!channel)
        return;
      client.emit("webhooksUpdate", channel);
      if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
      }
    }
  }
  module.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports, module) => {
  class ActionsManager {
    injectedUser = Symbol("djs.actions.injectedUser");
    injectedChannel = Symbol("djs.actions.injectedChannel");
    injectedMessage = Symbol("djs.actions.injectedMessage");
    constructor(client) {
      this.client = client;
      this.register(require_ApplicationCommandPermissionsUpdate());
      this.register(require_AutoModerationActionExecution2());
      this.register(require_AutoModerationRuleCreate());
      this.register(require_AutoModerationRuleDelete());
      this.register(require_AutoModerationRuleUpdate());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_EntitlementCreate());
      this.register(require_EntitlementDelete());
      this.register(require_EntitlementUpdate());
      this.register(require_GuildAuditLogEntryCreate());
      this.register(require_GuildBanAdd());
      this.register(require_GuildBanRemove());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildScheduledEventCreate());
      this.register(require_GuildScheduledEventDelete());
      this.register(require_GuildScheduledEventUpdate());
      this.register(require_GuildScheduledEventUserAdd());
      this.register(require_GuildScheduledEventUserRemove());
      this.register(require_GuildSoundboardSoundDelete());
      this.register(require_GuildStickerCreate());
      this.register(require_GuildStickerDelete());
      this.register(require_GuildStickerUpdate());
      this.register(require_GuildStickersUpdate());
      this.register(require_GuildUpdate());
      this.register(require_InteractionCreate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessagePollVoteAdd());
      this.register(require_MessagePollVoteRemove());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_MessageUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_StageInstanceCreate());
      this.register(require_StageInstanceDelete());
      this.register(require_StageInstanceUpdate());
      this.register(require_ThreadCreate());
      this.register(require_ThreadDelete());
      this.register(require_ThreadListSync());
      this.register(require_ThreadMemberUpdate());
      this.register(require_ThreadMembersUpdate());
      this.register(require_TypingStart());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_WebhooksUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  }
  module.exports = ActionsManager;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports, module) => {
  var Events = require_Events();

  class ClientVoiceManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
      this.adapters = new Map;
      client.on(Events.ShardDisconnect, (_, shardId) => {
        for (const [guildId, adapter] of this.adapters.entries()) {
          if (client.guilds.cache.get(guildId)?.shardId === shardId) {
            adapter.destroy();
          }
        }
      });
    }
    onVoiceServer(payload) {
      this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
    }
    onVoiceStateUpdate(payload) {
      if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
        this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
      }
    }
  }
  module.exports = ClientVoiceManager;
});

// node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js
var require_dist9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// node_modules/ws/lib/constants.js
var require_constants6 = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants6();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate2 = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants6();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants6();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate2();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants6();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender2 = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate2();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants6();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants6();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event2 {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event2.prototype, "target", { enumerable: true });
  Object.defineProperty(Event2.prototype, "type", { enumerable: true });

  class CloseEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget2 = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event2("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event: Event2,
    EventTarget: EventTarget2,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate2();
  var Receiver = require_receiver2();
  var Sender = require_sender2();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants6();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket.CLOSED)
      return;
    if (websocket.readyState === WebSocket.OPEN) {
      websocket._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket2();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate2();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket2();
  var { GUID, kWebSocket } = require_constants6();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket = require_websocket2();
  WebSocket.createWebSocketStream = require_stream();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver2();
  WebSocket.Sender = require_sender2();
  WebSocket.WebSocket = WebSocket;
  WebSocket.WebSocketServer = WebSocket.Server;
  module.exports = WebSocket;
});

// node_modules/@discordjs/ws/dist/index.js
var require_dist10 = __commonJS((exports, module) => {
  var __dirname = "/Users/Shared/Dev/badsk/node_modules/@discordjs/ws/dist";
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export(src_exports, {
    CloseCodes: () => CloseCodes,
    CompressionMethod: () => CompressionMethod,
    DefaultDeviceProperty: () => DefaultDeviceProperty,
    DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
    Encoding: () => Encoding,
    ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
    KnownNetworkErrorCodes: () => KnownNetworkErrorCodes,
    SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
    SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
    SimpleShardingStrategy: () => SimpleShardingStrategy,
    WebSocketManager: () => WebSocketManager,
    WebSocketShard: () => WebSocketShard,
    WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
    WebSocketShardEvents: () => WebSocketShardEvents,
    WebSocketShardStatus: () => WebSocketShardStatus,
    WorkerBootstrapper: () => WorkerBootstrapper,
    WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
    WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
    WorkerSendPayloadOp: () => WorkerSendPayloadOp,
    WorkerShardingStrategy: () => WorkerShardingStrategy,
    getInitialSendRateLimitState: () => getInitialSendRateLimitState,
    managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  async function managerToFetchingStrategyOptions(manager) {
    const {
      buildIdentifyThrottler,
      buildStrategy,
      retrieveSessionInfo,
      updateSessionInfo,
      shardCount,
      shardIds,
      rest,
      ...managerOptions
    } = manager.options;
    return {
      ...managerOptions,
      gatewayInformation: await manager.fetchGatewayInformation(),
      shardCount: await manager.getShardCount()
    };
  }
  __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
  var SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    static {
      __name(this, "SimpleContextFetchingStrategy");
    }
    static throttlerCache = /* @__PURE__ */ new WeakMap;
    static async ensureThrottler(manager) {
      const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
      if (throttler) {
        return throttler;
      }
      const newThrottler = await manager.options.buildIdentifyThrottler(manager);
      _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);
      return newThrottler;
    }
    async retrieveSessionInfo(shardId) {
      return this.manager.options.retrieveSessionInfo(shardId);
    }
    updateSessionInfo(shardId, sessionInfo) {
      return this.manager.options.updateSessionInfo(shardId, sessionInfo);
    }
    async waitForIdentify(shardId, signal) {
      const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);
      await throttler.waitForIdentify(shardId, signal);
    }
  };
  var import_node_worker_threads2 = __require("worker_threads");
  var import_collection2 = require_dist9();
  var import_node_events = __require("events");
  var import_node_path = __require("path");
  var import_node_worker_threads = __require("worker_threads");
  var import_collection = require_dist9();
  var WorkerSendPayloadOp = /* @__PURE__ */ ((WorkerSendPayloadOp2) => {
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
    return WorkerSendPayloadOp2;
  })(WorkerSendPayloadOp || {});
  var WorkerReceivePayloadOp = /* @__PURE__ */ ((WorkerReceivePayloadOp2) => {
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
    return WorkerReceivePayloadOp2;
  })(WorkerReceivePayloadOp || {});
  var WorkerShardingStrategy = class {
    static {
      __name(this, "WorkerShardingStrategy");
    }
    manager;
    options;
    #workers = [];
    #workerByShardId = new import_collection.Collection;
    connectPromises = new import_collection.Collection;
    destroyPromises = new import_collection.Collection;
    fetchStatusPromises = new import_collection.Collection;
    waitForIdentifyControllers = new import_collection.Collection;
    throttler;
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    async spawn(shardIds) {
      const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      const loops = Math.ceil(shardIds.length / shardsPerWorker);
      const promises = [];
      for (let idx = 0;idx < loops; idx++) {
        const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
        const workerData2 = {
          ...strategyOptions,
          shardIds: slice
        };
        promises.push(this.setupWorker(workerData2));
      }
      await Promise.all(promises);
    }
    async connect() {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 0,
          shardId
        };
        const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
        worker.postMessage(payload);
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    async destroy(options = {}) {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 1,
          shardId,
          options
        };
        promises.push(new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));
        worker.postMessage(payload);
      }
      this.#workers = [];
      this.#workerByShardId.clear();
      await Promise.all(promises);
    }
    send(shardId, data) {
      const worker = this.#workerByShardId.get(shardId);
      if (!worker) {
        throw new Error(`No worker found for shard ${shardId}`);
      }
      const payload = {
        op: 2,
        shardId,
        payload: data
      };
      worker.postMessage(payload);
    }
    async fetchStatus() {
      const statuses = new import_collection.Collection;
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
        worker.postMessage(payload);
        const status = await promise;
        statuses.set(shardId, status);
      }
      return statuses;
    }
    async setupWorker(workerData2) {
      const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
      await (0, import_node_events.once)(worker, "online");
      await this.waitForWorkerReady(worker);
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        if ("op" in payload) {
          await this.onMessage(worker, payload);
        } else {
          await this.options.unknownPayloadHandler?.(payload);
        }
      });
      this.#workers.push(worker);
      for (const shardId of workerData2.shardIds) {
        this.#workerByShardId.set(shardId, worker);
      }
    }
    resolveWorkerPath() {
      const path = this.options.workerPath;
      if (!path) {
        return (0, import_node_path.join)(__dirname, "defaultWorker.js");
      }
      if ((0, import_node_path.isAbsolute)(path)) {
        return path;
      }
      if (/^\.\.?[/\\]/.test(path)) {
        return (0, import_node_path.resolve)(path);
      }
      try {
        return __require.resolve(path);
      } catch {
        return (0, import_node_path.resolve)(path);
      }
    }
    async waitForWorkerReady(worker) {
      return new Promise((resolve2) => {
        const handler = /* @__PURE__ */ __name((payload) => {
          if (payload.op === 7) {
            resolve2();
            worker.off("message", handler);
          }
        }, "handler");
        worker.on("message", handler);
      });
    }
    async onMessage(worker, payload) {
      switch (payload.op) {
        case 0: {
          this.connectPromises.get(payload.shardId)?.();
          this.connectPromises.delete(payload.shardId);
          break;
        }
        case 1: {
          this.destroyPromises.get(payload.shardId)?.();
          this.destroyPromises.delete(payload.shardId);
          break;
        }
        case 2: {
          this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
          break;
        }
        case 3: {
          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
          const response = {
            op: 3,
            nonce: payload.nonce,
            session
          };
          worker.postMessage(response);
          break;
        }
        case 4: {
          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
          break;
        }
        case 5: {
          const throttler = await this.ensureThrottler();
          try {
            const controller = new AbortController;
            this.waitForIdentifyControllers.set(payload.nonce, controller);
            await throttler.waitForIdentify(payload.shardId, controller.signal);
          } catch {
            return;
          }
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: true
          };
          worker.postMessage(response);
          break;
        }
        case 6: {
          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);
          this.fetchStatusPromises.delete(payload.nonce);
          break;
        }
        case 7: {
          break;
        }
        case 8: {
          this.waitForIdentifyControllers.get(payload.nonce)?.abort();
          this.waitForIdentifyControllers.delete(payload.nonce);
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: false
          };
          worker.postMessage(response);
          break;
        }
        default: {
          await this.options.unknownPayloadHandler?.(payload);
          break;
        }
      }
    }
    async ensureThrottler() {
      this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);
      return this.throttler;
    }
  };
  var WorkerContextFetchingStrategy = class {
    constructor(options) {
      this.options = options;
      if (import_node_worker_threads2.isMainThread) {
        throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
      }
      import_node_worker_threads2.parentPort.on("message", (payload) => {
        if (payload.op === 3) {
          this.sessionPromises.get(payload.nonce)?.(payload.session);
          this.sessionPromises.delete(payload.nonce);
        }
        if (payload.op === 4) {
          const promise = this.waitForIdentifyPromises.get(payload.nonce);
          if (payload.ok) {
            promise?.resolve();
          } else {
            promise?.reject(promise.signal.reason);
          }
          this.waitForIdentifyPromises.delete(payload.nonce);
        }
      });
    }
    static {
      __name(this, "WorkerContextFetchingStrategy");
    }
    sessionPromises = new import_collection2.Collection;
    waitForIdentifyPromises = new import_collection2.Collection;
    async retrieveSessionInfo(shardId) {
      const nonce = Math.random();
      const payload = {
        op: 3,
        shardId,
        nonce
      };
      const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
      import_node_worker_threads2.parentPort.postMessage(payload);
      return promise;
    }
    updateSessionInfo(shardId, sessionInfo) {
      const payload = {
        op: 4,
        shardId,
        session: sessionInfo
      };
      import_node_worker_threads2.parentPort.postMessage(payload);
    }
    async waitForIdentify(shardId, signal) {
      const nonce = Math.random();
      const payload = {
        op: 5,
        nonce,
        shardId
      };
      const promise = new Promise((resolve2, reject) => this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject }));
      import_node_worker_threads2.parentPort.postMessage(payload);
      const listener = /* @__PURE__ */ __name(() => {
        const payload2 = {
          op: 8,
          nonce
        };
        import_node_worker_threads2.parentPort.postMessage(payload2);
      }, "listener");
      signal.addEventListener("abort", listener);
      try {
        await promise;
      } finally {
        signal.removeEventListener("abort", listener);
      }
    }
  };
  var import_collection6 = require_dist9();
  var import_node_buffer = __require("buffer");
  var import_node_events2 = __require("events");
  var import_node_timers = __require("timers");
  var import_promises2 = __require("timers/promises");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_node_zlib = __require("zlib");
  var import_collection5 = require_dist9();
  var import_util2 = require_dist();
  var import_async_queue2 = require_cjs2();
  var import_async_event_emitter = require_dist3();
  var import_v102 = require_v106();
  var import_ws = require_ws();
  var import_node_process = __toESM2(__require("process"));
  var import_collection4 = require_dist9();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var import_promises = __require("timers/promises");
  var import_collection3 = require_dist9();
  var import_async_queue = require_cjs2();
  var SimpleIdentifyThrottler = class {
    constructor(maxConcurrency) {
      this.maxConcurrency = maxConcurrency;
    }
    static {
      __name(this, "SimpleIdentifyThrottler");
    }
    states = new import_collection3.Collection;
    async waitForIdentify(shardId, signal) {
      const key = shardId % this.maxConcurrency;
      const state = this.states.ensure(key, () => {
        return {
          queue: new import_async_queue.AsyncQueue,
          resetsAt: Number.POSITIVE_INFINITY
        };
      });
      await state.queue.wait({ signal });
      try {
        const diff = state.resetsAt - Date.now();
        if (diff > 0 && diff <= 5000) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        state.resetsAt = Date.now() + 5000;
      } finally {
        state.queue.shift();
      }
    }
  };
  var Encoding = /* @__PURE__ */ ((Encoding2) => {
    Encoding2["JSON"] = "json";
    return Encoding2;
  })(Encoding || {});
  var CompressionMethod = /* @__PURE__ */ ((CompressionMethod2) => {
    CompressionMethod2["ZlibStream"] = "zlib-stream";
    return CompressionMethod2;
  })(CompressionMethod || {});
  var DefaultDeviceProperty = `@discordjs/ws 1.2.3`;
  var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection);
  var DefaultWebSocketManagerOptions = {
    async buildIdentifyThrottler(manager) {
      const info = await manager.fetchGatewayInformation();
      return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
    },
    buildStrategy: /* @__PURE__ */ __name((manager) => new SimpleShardingStrategy(manager), "buildStrategy"),
    shardCount: null,
    shardIds: null,
    largeThreshold: null,
    initialPresence: null,
    identifyProperties: {
      browser: DefaultDeviceProperty,
      device: DefaultDeviceProperty,
      os: import_node_process.default.platform
    },
    version: import_v10.APIVersion,
    encoding: "json",
    compression: null,
    retrieveSessionInfo(shardId) {
      const store = getDefaultSessionStore();
      return store.get(shardId) ?? null;
    },
    updateSessionInfo(shardId, info) {
      const store = getDefaultSessionStore();
      if (info) {
        store.set(shardId, info);
      } else {
        store.delete(shardId);
      }
    },
    handshakeTimeout: 30000,
    helloTimeout: 60000,
    readyTimeout: 15000
  };
  var ImportantGatewayOpcodes = /* @__PURE__ */ new Set([
    import_v10.GatewayOpcodes.Heartbeat,
    import_v10.GatewayOpcodes.Identify,
    import_v10.GatewayOpcodes.Resume
  ]);
  function getInitialSendRateLimitState() {
    return {
      sent: 0,
      resetAt: Date.now() + 60000
    };
  }
  __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
  var KnownNetworkErrorCodes = /* @__PURE__ */ new Set(["ECONNRESET", "ECONNREFUSED", "ETIMEDOUT", "EAI_AGAIN"]);
  var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
  var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
    WebSocketShardEvents2["Closed"] = "closed";
    WebSocketShardEvents2["Debug"] = "debug";
    WebSocketShardEvents2["Dispatch"] = "dispatch";
    WebSocketShardEvents2["Error"] = "error";
    WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
    WebSocketShardEvents2["Hello"] = "hello";
    WebSocketShardEvents2["Ready"] = "ready";
    WebSocketShardEvents2["Resumed"] = "resumed";
    return WebSocketShardEvents2;
  })(WebSocketShardEvents || {});
  var WebSocketShardStatus = /* @__PURE__ */ ((WebSocketShardStatus2) => {
    WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
    WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
    WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
    WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
    return WebSocketShardStatus2;
  })(WebSocketShardStatus || {});
  var WebSocketShardDestroyRecovery = /* @__PURE__ */ ((WebSocketShardDestroyRecovery2) => {
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
    return WebSocketShardDestroyRecovery2;
  })(WebSocketShardDestroyRecovery || {});
  var CloseCodes = /* @__PURE__ */ ((CloseCodes2) => {
    CloseCodes2[CloseCodes2["Normal"] = 1000] = "Normal";
    CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
    return CloseCodes2;
  })(CloseCodes || {});
  var WebSocketConstructor = (0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? globalThis.WebSocket : import_ws.WebSocket;
  var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "WebSocketShard");
    }
    connection = null;
    useIdentifyCompress = false;
    inflate = null;
    textDecoder = new import_node_util.TextDecoder;
    replayedEvents = 0;
    isAck = true;
    sendRateLimitState = getInitialSendRateLimitState();
    initialHeartbeatTimeoutController = null;
    heartbeatInterval = null;
    lastHeartbeatAt = -1;
    initialConnectResolved = false;
    failedToConnectDueToNetworkError = false;
    sendQueue = new import_async_queue2.AsyncQueue;
    timeoutAbortControllers = new import_collection5.Collection;
    strategy;
    id;
    #status = 0;
    get status() {
      return this.#status;
    }
    constructor(strategy, id) {
      super();
      this.strategy = strategy;
      this.id = id;
    }
    async connect() {
      const controller = new AbortController;
      let promise;
      if (!this.initialConnectResolved) {
        promise = Promise.race([
          (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
          (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
        ]);
      }
      this.internalConnect();
      try {
        await promise;
      } catch ({ error }) {
        throw error;
      } finally {
        controller.abort();
      }
      this.initialConnectResolved = true;
    }
    async internalConnect() {
      if (this.#status !== 0) {
        throw new Error("Tried to connect a shard that wasn't idle");
      }
      const { version: version2, encoding, compression } = this.strategy.options;
      const params = new import_node_url.URLSearchParams({ v: version2, encoding });
      if (compression) {
        const zlib = await getZlibSync();
        if (zlib) {
          params.append("compress", compression);
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            to: "string"
          });
        } else if (!this.useIdentifyCompress) {
          this.useIdentifyCompress = true;
          console.warn("WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress");
        }
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
      this.debug([`Connecting to ${url}`]);
      const connection = new WebSocketConstructor(url, [], {
        handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined
      });
      connection.binaryType = "arraybuffer";
      connection.onmessage = (event) => {
        this.onMessage(event.data, event.data instanceof ArrayBuffer);
      };
      connection.onerror = (event) => {
        this.onError(event.error);
      };
      connection.onclose = (event) => {
        this.onClose(event.code);
      };
      connection.onopen = () => {
        this.sendRateLimitState = getInitialSendRateLimitState();
      };
      this.connection = connection;
      this.#status = 1;
      const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
      if (!ok) {
        return;
      }
      if (session?.shardCount === this.strategy.options.shardCount) {
        await this.resume(session);
      } else {
        await this.identify();
      }
    }
    async destroy(options = {}) {
      if (this.#status === 0) {
        this.debug(["Tried to destroy a shard that was idle"]);
        return;
      }
      if (!options.code) {
        options.code = options.recover === 1 ? 4200 : 1000;
      }
      this.debug([
        "Destroying shard",
        `Reason: ${options.reason ?? "none"}`,
        `Code: ${options.code}`,
        `Recover: ${options.recover === undefined ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
      ]);
      this.isAck = true;
      if (this.heartbeatInterval) {
        (0, import_node_timers.clearInterval)(this.heartbeatInterval);
      }
      if (this.initialHeartbeatTimeoutController) {
        this.initialHeartbeatTimeoutController.abort();
        this.initialHeartbeatTimeoutController = null;
      }
      this.lastHeartbeatAt = -1;
      for (const controller of this.timeoutAbortControllers.values()) {
        controller.abort();
      }
      this.timeoutAbortControllers.clear();
      this.failedToConnectDueToNetworkError = false;
      if (options.recover !== 1) {
        await this.strategy.updateSessionInfo(this.id, null);
      }
      if (this.connection) {
        this.connection.onmessage = null;
        this.connection.onclose = null;
        const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
        this.debug([
          "Connection status during destroy",
          `Needs closing: ${shouldClose}`,
          `Ready state: ${this.connection.readyState}`
        ]);
        if (shouldClose) {
          let outerResolve;
          const promise = new Promise((resolve2) => {
            outerResolve = resolve2;
          });
          this.connection.onclose = outerResolve;
          this.connection.close(options.code, options.reason);
          await promise;
          this.emit("closed", { code: options.code });
        }
        this.connection.onerror = null;
      } else {
        this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
      }
      this.#status = 0;
      if (options.recover !== undefined) {
        await (0, import_promises2.setTimeout)(500);
        return this.internalConnect();
      }
    }
    async waitForEvent(event, timeoutDuration) {
      this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
      const timeoutController = new AbortController;
      const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
      this.timeoutAbortControllers.set(event, timeoutController);
      const closeController = new AbortController;
      try {
        const closed = await Promise.race([
          (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
        ]);
        return { ok: !closed };
      } catch {
        this.destroy({
          code: 1000,
          reason: "Something timed out or went wrong while waiting for an event",
          recover: 0
        });
        return { ok: false };
      } finally {
        if (timeout) {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        this.timeoutAbortControllers.delete(event);
        if (!closeController.signal.aborted) {
          closeController.abort();
        }
      }
    }
    async send(payload) {
      if (!this.connection) {
        throw new Error("WebSocketShard wasn't connected");
      }
      if (ImportantGatewayOpcodes.has(payload.op)) {
        this.connection.send(JSON.stringify(payload));
        return;
      }
      if (this.#status !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
        this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
        try {
          await (0, import_node_events2.once)(this, "ready");
        } catch {
          return this.send(payload);
        }
      }
      await this.sendQueue.wait();
      const now = Date.now();
      if (now >= this.sendRateLimitState.resetAt) {
        this.sendRateLimitState = getInitialSendRateLimitState();
      }
      if (this.sendRateLimitState.sent + 1 >= 115) {
        const sleepFor = this.sendRateLimitState.resetAt - now + Math.random() * 1500;
        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
        const controller = new AbortController;
        const interrupted = await Promise.race([
          (0, import_promises2.setTimeout)(sleepFor).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
        ]);
        if (interrupted) {
          this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
          this.sendQueue.shift();
          return this.send(payload);
        }
        controller.abort();
      }
      this.sendRateLimitState.sent++;
      this.sendQueue.shift();
      this.connection.send(JSON.stringify(payload));
    }
    async identify() {
      this.debug(["Waiting for identify throttle"]);
      const controller = new AbortController;
      const closeHandler = /* @__PURE__ */ __name(() => {
        controller.abort();
      }, "closeHandler");
      this.on("closed", closeHandler);
      try {
        await this.strategy.waitForIdentify(this.id, controller.signal);
      } catch {
        if (controller.signal.aborted) {
          this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
          return;
        }
        this.debug([
          "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
          "If you're using a custom strategy, this is probably nothing to worry about.",
          "If you're not, please open an issue on GitHub."
        ]);
        await this.destroy({
          reason: "Identify throttling logic failed",
          recover: 1
        });
      } finally {
        this.off("closed", closeHandler);
      }
      this.debug([
        "Identifying",
        `shard id: ${this.id.toString()}`,
        `shard count: ${this.strategy.options.shardCount}`,
        `intents: ${this.strategy.options.intents}`,
        `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
      ]);
      const d = {
        token: this.strategy.options.token,
        properties: this.strategy.options.identifyProperties,
        intents: this.strategy.options.intents,
        compress: this.useIdentifyCompress,
        shard: [this.id, this.strategy.options.shardCount]
      };
      if (this.strategy.options.largeThreshold) {
        d.large_threshold = this.strategy.options.largeThreshold;
      }
      if (this.strategy.options.initialPresence) {
        d.presence = this.strategy.options.initialPresence;
      }
      await this.send({
        op: import_v102.GatewayOpcodes.Identify,
        d
      });
      await this.waitForEvent("ready", this.strategy.options.readyTimeout);
    }
    async resume(session) {
      this.debug([
        "Resuming session",
        `resume url: ${session.resumeURL}`,
        `sequence: ${session.sequence}`,
        `shard id: ${this.id.toString()}`
      ]);
      this.#status = 2;
      this.replayedEvents = 0;
      return this.send({
        op: import_v102.GatewayOpcodes.Resume,
        d: {
          token: this.strategy.options.token,
          seq: session.sequence,
          session_id: session.sessionId
        }
      });
    }
    async heartbeat(requested = false) {
      if (!this.isAck && !requested) {
        return this.destroy({ reason: "Zombie connection", recover: 1 });
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      await this.send({
        op: import_v102.GatewayOpcodes.Heartbeat,
        d: session?.sequence ?? null
      });
      this.lastHeartbeatAt = Date.now();
      this.isAck = false;
    }
    async unpackMessage(data, isBinary) {
      if (!isBinary) {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      }
      const decompressable = new Uint8Array(data);
      if (this.useIdentifyCompress) {
        return new Promise((resolve2, reject) => {
          (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve2(JSON.parse(this.textDecoder.decode(result)));
          });
        });
      }
      if (this.inflate) {
        const l = decompressable.length;
        const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
        const zlib = await getZlibSync();
        this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
        if (this.inflate.err) {
          this.emit("error", {
            error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
          });
        }
        if (!flush) {
          return null;
        }
        const { result } = this.inflate;
        if (!result) {
          return null;
        }
        return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
      }
      this.debug([
        "Received a message we were unable to decompress",
        `isBinary: ${isBinary.toString()}`,
        `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
        `inflate: ${Boolean(this.inflate).toString()}`
      ]);
      return null;
    }
    async onMessage(data, isBinary) {
      const payload = await this.unpackMessage(data, isBinary);
      if (!payload) {
        return;
      }
      switch (payload.op) {
        case import_v102.GatewayOpcodes.Dispatch: {
          if (this.#status === 2) {
            this.replayedEvents++;
          }
          switch (payload.t) {
            case import_v102.GatewayDispatchEvents.Ready: {
              this.#status = 3;
              const session2 = {
                sequence: payload.s,
                sessionId: payload.d.session_id,
                shardId: this.id,
                shardCount: this.strategy.options.shardCount,
                resumeURL: payload.d.resume_gateway_url
              };
              await this.strategy.updateSessionInfo(this.id, session2);
              this.emit("ready", { data: payload.d });
              break;
            }
            case import_v102.GatewayDispatchEvents.Resumed: {
              this.#status = 3;
              this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
              this.emit("resumed");
              break;
            }
            default: {
              break;
            }
          }
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (session) {
            if (payload.s > session.sequence) {
              await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
            }
          } else {
            this.debug([
              `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
            ]);
          }
          this.emit("dispatch", { data: payload });
          break;
        }
        case import_v102.GatewayOpcodes.Heartbeat: {
          await this.heartbeat(true);
          break;
        }
        case import_v102.GatewayOpcodes.Reconnect: {
          await this.destroy({
            reason: "Told to reconnect by Discord",
            recover: 1
          });
          break;
        }
        case import_v102.GatewayOpcodes.InvalidSession: {
          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (payload.d && session) {
            await this.resume(session);
          } else {
            await this.destroy({
              reason: "Invalid session",
              recover: 0
            });
          }
          break;
        }
        case import_v102.GatewayOpcodes.Hello: {
          this.emit("hello");
          const jitter = Math.random();
          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
          try {
            const controller = new AbortController;
            this.initialHeartbeatTimeoutController = controller;
            await (0, import_promises2.setTimeout)(firstWait, undefined, { signal: controller.signal });
          } catch {
            this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
            return;
          } finally {
            this.initialHeartbeatTimeoutController = null;
          }
          await this.heartbeat();
          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
          break;
        }
        case import_v102.GatewayOpcodes.HeartbeatAck: {
          this.isAck = true;
          const ackAt = Date.now();
          this.emit("heartbeat", {
            ackAt,
            heartbeatAt: this.lastHeartbeatAt,
            latency: ackAt - this.lastHeartbeatAt
          });
          break;
        }
      }
    }
    onError(error) {
      if ("code" in error && KnownNetworkErrorCodes.has(error.code)) {
        this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
        this.failedToConnectDueToNetworkError = true;
        return;
      }
      this.emit("error", { error });
    }
    async onClose(code) {
      this.emit("closed", { code });
      switch (code) {
        case 1000: {
          return this.destroy({
            code,
            reason: "Got disconnected by Discord",
            recover: 0
          });
        }
        case 4200: {
          break;
        }
        case import_v102.GatewayCloseCodes.UnknownError: {
          this.debug([`An unknown error occurred: ${code}`]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.UnknownOpcode: {
          this.debug(["An invalid opcode was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.DecodeError: {
          this.debug(["An invalid payload was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.NotAuthenticated: {
          this.debug(["A request was somehow sent before the identify/resume payload."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.AuthenticationFailed: {
          this.emit("error", {
            error: new Error("Authentication failed")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
          this.debug(["More than one auth payload was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.InvalidSeq: {
          this.debug(["An invalid sequence was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.RateLimited: {
          this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.SessionTimedOut: {
          this.debug(["Session timed out."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.InvalidShard: {
          this.emit("error", {
            error: new Error("Invalid shard")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.ShardingRequired: {
          this.emit("error", {
            error: new Error("Sharding is required")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
          this.emit("error", {
            error: new Error("Used an invalid API version")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidIntents: {
          this.emit("error", {
            error: new Error("Used invalid intents")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.DisallowedIntents: {
          this.emit("error", {
            error: new Error("Used disallowed intents")
          });
          return this.destroy({ code });
        }
        default: {
          this.debug([
            `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
          ]);
          return this.destroy({
            code,
            recover: this.failedToConnectDueToNetworkError ? 0 : 1
          });
        }
      }
    }
    debug(messages) {
      this.emit("debug", { message: messages.join(`
	`) });
    }
  };
  var SimpleShardingStrategy = class {
    static {
      __name(this, "SimpleShardingStrategy");
    }
    manager;
    shards = new import_collection6.Collection;
    constructor(manager) {
      this.manager = manager;
    }
    async spawn(shardIds) {
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      for (const shardId of shardIds) {
        const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
        const shard = new WebSocketShard(strategy, shardId);
        for (const event of Object.values(WebSocketShardEvents)) {
          shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
        }
        this.shards.set(shardId, shard);
      }
    }
    async connect() {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.connect());
      }
      await Promise.all(promises);
    }
    async destroy(options) {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.destroy(options));
      }
      await Promise.all(promises);
      this.shards.clear();
    }
    async send(shardId, payload) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} not found`);
      }
      return shard.send(payload);
    }
    async fetchStatus() {
      return this.shards.mapValues((shard) => shard.status);
    }
  };
  var import_node_worker_threads3 = __require("worker_threads");
  var import_collection7 = require_dist9();
  var WorkerBootstrapper = class {
    static {
      __name(this, "WorkerBootstrapper");
    }
    data = import_node_worker_threads3.workerData;
    shards = new import_collection7.Collection;
    constructor() {
      if (import_node_worker_threads3.isMainThread) {
        throw new Error("Expected WorkerBootstrap to not be used within the main thread");
      }
    }
    async connect(shardId) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.connect();
    }
    async destroy(shardId, options) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.destroy(options);
    }
    setupThreadEvents() {
      import_node_worker_threads3.parentPort.on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        switch (payload.op) {
          case 0: {
            await this.connect(payload.shardId);
            const response = {
              op: 0,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 1: {
            await this.destroy(payload.shardId, payload.options);
            const response = {
              op: 1,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 2: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new RangeError(`Shard ${payload.shardId} does not exist`);
            }
            await shard.send(payload.payload);
            break;
          }
          case 3: {
            break;
          }
          case 4: {
            break;
          }
          case 5: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new Error(`Shard ${payload.shardId} does not exist`);
            }
            const response = {
              op: 6,
              status: shard.status,
              nonce: payload.nonce
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
        }
      });
    }
    async bootstrap(options = {}) {
      for (const shardId of this.data.shardIds) {
        const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
        for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
          shard.on(event, (data) => {
            const payload = {
              op: 2,
              event,
              data,
              shardId
            };
            import_node_worker_threads3.parentPort.postMessage(payload);
          });
        }
        await options.shardCallback?.(shard);
        this.shards.set(shardId, shard);
      }
      this.setupThreadEvents();
      const message = {
        op: 7
      };
      import_node_worker_threads3.parentPort.postMessage(message);
    }
  };
  var import_util3 = require_dist();
  var import_util4 = require_dist();
  var import_async_event_emitter2 = require_dist3();
  var import_v103 = require_v106();
  (0, import_util4.polyfillDispose)();
  var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
    static {
      __name(this, "WebSocketManager");
    }
    options;
    gatewayInformation = null;
    shardIds = null;
    strategy;
    constructor(options) {
      super();
      this.options = { ...DefaultWebSocketManagerOptions, ...options };
      this.strategy = this.options.buildStrategy(this);
    }
    async fetchGatewayInformation(force = false) {
      if (this.gatewayInformation) {
        if (this.gatewayInformation.expiresAt <= Date.now()) {
          this.gatewayInformation = null;
        } else if (!force) {
          return this.gatewayInformation.data;
        }
      }
      const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
      this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5000) };
      return this.gatewayInformation.data;
    }
    async updateShardCount(shardCount) {
      await this.strategy.destroy({ reason: "User is adjusting their shards" });
      this.options.shardCount = shardCount;
      const shardIds = await this.getShardIds(true);
      await this.strategy.spawn(shardIds);
      return this;
    }
    async getShardCount() {
      if (this.options.shardCount) {
        return this.options.shardCount;
      }
      const shardIds = await this.getShardIds();
      return Math.max(...shardIds) + 1;
    }
    async getShardIds(force = false) {
      if (this.shardIds && !force) {
        return this.shardIds;
      }
      let shardIds;
      if (this.options.shardIds) {
        if (Array.isArray(this.options.shardIds)) {
          shardIds = this.options.shardIds;
        } else {
          const { start, end } = this.options.shardIds;
          shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
        }
      } else {
        const data = await this.fetchGatewayInformation();
        shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
      }
      this.shardIds = shardIds;
      return shardIds;
    }
    async connect() {
      const shardCount = await this.getShardCount();
      await this.updateShardCount(shardCount);
      const shardIds = await this.getShardIds();
      const data = await this.fetchGatewayInformation();
      if (data.session_start_limit.remaining < shardIds.length) {
        throw new Error(`Not enough sessions remaining to spawn ${shardIds.length} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);
      }
      await this.strategy.connect();
    }
    destroy(options) {
      return this.strategy.destroy(options);
    }
    send(shardId, payload) {
      return this.strategy.send(shardId, payload);
    }
    fetchStatus() {
      return this.strategy.fetchStatus();
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  };
  var version = "1.2.3";
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Close: "close",
    Destroyed: "destroyed",
    InvalidSession: "invalidSession",
    Ready: "ready",
    Resumed: "resumed",
    AllReady: "allReady"
  };
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { GatewayIntentBits } = require_v106();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var deprecationEmittedForImportant = false;

  class WebSocketShard extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status.Idle;
      this.closeSequence = 0;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
      Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
      Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
    }
    debug(messages) {
      this.manager.debug(messages, this.id);
    }
    emitClose(event = {
      code: 1011,
      reason: "INTERNAL_ERROR",
      wasClean: false
    }) {
      this.debug([
        "[CLOSE]",
        `Event Code: ${event.code}`,
        `Clean     : ${event.wasClean}`,
        `Reason    : ${event.reason ?? "No reason received"}`
      ]);
      this.emit(WebSocketShardEvents.Close, event);
    }
    onReadyPacket(packet) {
      if (!packet) {
        this.debug([`Received broken packet: '${packet}'.`]);
        return;
      }
      this.emit(WebSocketShardEvents.Ready);
      this.expectedGuilds = new Set(packet.guilds.map((guild) => guild.id));
      this.status = Status.WaitingForGuilds;
    }
    gotGuild(guildId) {
      this.expectedGuilds.delete(guildId);
      this.checkReady();
    }
    checkReady() {
      if (this.readyTimeout) {
        clearTimeout2(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug(["Shard received all its guilds. Marking as fully ready."]);
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady);
        return;
      }
      const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
      const { waitGuildTimeout } = this.manager.client.options;
      this.readyTimeout = setTimeout2(() => {
        this.debug([
          hasGuildsIntent ? `Shard did not receive any guild packets in ${waitGuildTimeout} ms.` : "Shard will not receive anymore guild packets.",
          `Unavailable guild count: ${this.expectedGuilds.size}`
        ]);
        this.readyTimeout = null;
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
      }, hasGuildsIntent ? waitGuildTimeout : 0).unref();
    }
    send(data, important = false) {
      if (important && !deprecationEmittedForImportant) {
        process2.emitWarning("Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.", "DeprecationWarning");
        deprecationEmittedForImportant = true;
      }
      this.manager._ws.send(this.id, data);
    }
  }
  module.exports = WebSocketShard;
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationActionExecution.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const channel = client.channels.cache.get(data.channel_id);
    const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
    if (channel) {
      channel.lastPinTimestamp = time;
      client.emit(Events.ChannelPinsUpdate, channel, time);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ChannelUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_CREATE.js
var require_ENTITLEMENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_DELETE.js
var require_ENTITLEMENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_UPDATE.js
var require_ENTITLEMENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildAuditLogEntryCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      if (!guild.available && !data.unavailable) {
        guild._patch(data);
        client.emit(Events.GuildAvailable, guild);
      }
    } else {
      data.shardId = shard.id;
      guild = client.guilds._add(data);
      if (client.ws.status === Status.Ready) {
        client.emit(Events.GuildCreate, guild);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildEmojisUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildIntegrationsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const members = new Collection;
    for (const member of data.members)
      members.set(member.user.id, guild.members._add(member));
    if (data.presences) {
      for (const presence of data.presences)
        guild.presences._add(Object.assign(presence, { guild }));
    }
    client.emit(Events.GuildMembersChunk, members, guild, {
      index: data.chunk_index,
      count: data.chunk_count,
      notFound: data.not_found,
      nonce: data.nonce
    });
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      guild.memberCount++;
      const member = guild.members._add(data);
      if (shard.status === Status.Ready) {
        client.emit(Events.GuildMemberAdd, member);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberRemove.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberUpdate.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUNDS_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUNDS_UPDATE = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.GuildSoundboardSoundsUpdate, soundboardSounds, guild);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_CREATE.js
var require_GUILD_SOUNDBOARD_SOUND_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundCreate, soundboardSound);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_DELETE.js
var require_GUILD_SOUNDBOARD_SOUND_DELETE = __commonJS((exports, module) => {
  module.exports = (client, { d: data }) => {
    client.actions.GuildSoundboardSoundDelete.handle(data);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUND_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const oldGuildSoundboardSound = guild.soundboardSounds.cache.get(data.sound_id)?._clone() ?? null;
    const newGuildSoundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundUpdate, oldGuildSoundboardSound, newGuildSoundboardSound);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildStickersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InteractionCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDeleteBulk.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_ADD.js
var require_MESSAGE_POLL_VOTE_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_REMOVE.js
var require_MESSAGE_POLL_VOTE_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveAll.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveEmoji.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.MessageUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.PresenceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var User = require_User();
  var { resolveImage } = require_DataResolver();

  class ClientUser extends User {
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else {
        this.mfaEnabled ??= null;
      }
      if ("token" in data)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    async edit({ username, avatar, banner }) {
      const data = await this.client.rest.patch(Routes.user(), {
        body: {
          username,
          avatar: avatar && await resolveImage(avatar),
          banner: banner && await resolveImage(banner)
        }
      });
      const { updated } = this.client.actions.UserUpdate.handle(data);
      return updated ?? this;
    }
    setUsername(username) {
      return this.edit({ username });
    }
    setAvatar(avatar) {
      return this.edit({ avatar });
    }
    setBanner(banner) {
      return this.edit({ banner });
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardId) {
      return this.setPresence({ status, shardId });
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({ activities: [], shardId: options.shardId });
      const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
      return this.setPresence({ activities: [activity], shardId: activity.shardId });
    }
    setAFK(afk = true, shardId) {
      return this.setPresence({ afk, shardId });
    }
  }
  module.exports = ClientUser;
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS((exports, module) => {
  var ClientApplication = require_ClientApplication();
  var ClientUser;
  module.exports = (client, { d: data }, shard) => {
    if (client.user) {
      client.user._patch(data.user);
    } else {
      ClientUser ??= require_ClientUser();
      client.user = new ClientUser(client, data.user);
      client.users.cache.set(client.user.id, client.user);
    }
    for (const guild of data.guilds) {
      guild.shardId = shard.id;
      client.guilds._add(guild);
    }
    if (client.application) {
      client.application._patch(data.application);
    } else {
      client.application = new ClientApplication(client, data.application);
    }
    shard.checkReady();
  };
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet, shard) => {
    const replayed = shard.sessionInfo.sequence - shard.closeSequence;
    client.emit(Events.ShardResume, shard.id, replayed);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SOUNDBOARD_SOUNDS.js
var require_SOUNDBOARD_SOUNDS = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.SoundboardSounds, soundboardSounds, guild);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_CREATE.js
var require_SUBSCRIPTION_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionCreate, subscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_DELETE.js
var require_SUBSCRIPTION_DELETE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data, false);
    client.application.subscriptions.cache.delete(subscription.id);
    client.emit(Events.SubscriptionDelete, subscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_UPDATE.js
var require_SUBSCRIPTION_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const oldSubscription = client.application.subscriptions.cache.get(data.id)?._clone() ?? null;
    const newSubscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionUpdate, oldSubscription, newSubscription);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadListSync.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMembersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMemberUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ThreadUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.TypingStart.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.UserUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/VoiceChannelEffect.js
var require_VoiceChannelEffect = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class VoiceChannelEffect {
    constructor(data, guild) {
      this.guild = guild;
      this.channelId = data.channel_id;
      this.userId = data.user_id;
      this.emoji = data.emoji ? new Emoji(guild.client, data.emoji) : null;
      this.animationType = data.animation_type ?? null;
      this.animationId = data.animation_id ?? null;
      this.soundId = data.sound_id ?? null;
      this.soundVolume = data.sound_volume ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get soundboardSound() {
      return this.guild.soundboardSounds.cache.get(this.soundId) ?? null;
    }
  }
  module.exports = VoiceChannelEffect;
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_CHANNEL_EFFECT_SEND.js
var require_VOICE_CHANNEL_EFFECT_SEND = __commonJS((exports, module) => {
  var VoiceChannelEffect = require_VoiceChannelEffect();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    client.emit(Events.VoiceChannelEffectSend, new VoiceChannelEffect(data, guild));
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
    client.voice.onVoiceServer(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.VoiceStateUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.WebhooksUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports, module) => {
  var handlers = Object.fromEntries([
    ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
    ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
    ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
    ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
    ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
    ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
    ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
    ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
    ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
    ["ENTITLEMENT_CREATE", require_ENTITLEMENT_CREATE()],
    ["ENTITLEMENT_DELETE", require_ENTITLEMENT_DELETE()],
    ["ENTITLEMENT_UPDATE", require_ENTITLEMENT_UPDATE()],
    ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
    ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
    ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
    ["GUILD_CREATE", require_GUILD_CREATE()],
    ["GUILD_DELETE", require_GUILD_DELETE()],
    ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
    ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
    ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
    ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
    ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
    ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
    ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
    ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
    ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
    ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
    ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
    ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
    ["GUILD_SOUNDBOARD_SOUNDS_UPDATE", require_GUILD_SOUNDBOARD_SOUNDS_UPDATE()],
    ["GUILD_SOUNDBOARD_SOUND_CREATE", require_GUILD_SOUNDBOARD_SOUND_CREATE()],
    ["GUILD_SOUNDBOARD_SOUND_DELETE", require_GUILD_SOUNDBOARD_SOUND_DELETE()],
    ["GUILD_SOUNDBOARD_SOUND_UPDATE", require_GUILD_SOUNDBOARD_SOUND_UPDATE()],
    ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
    ["GUILD_UPDATE", require_GUILD_UPDATE()],
    ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
    ["INVITE_CREATE", require_INVITE_CREATE()],
    ["INVITE_DELETE", require_INVITE_DELETE()],
    ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
    ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
    ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
    ["MESSAGE_POLL_VOTE_ADD", require_MESSAGE_POLL_VOTE_ADD()],
    ["MESSAGE_POLL_VOTE_REMOVE", require_MESSAGE_POLL_VOTE_REMOVE()],
    ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
    ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
    ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
    ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
    ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
    ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
    ["READY", require_READY()],
    ["RESUMED", require_RESUMED()],
    ["SOUNDBOARD_SOUNDS", require_SOUNDBOARD_SOUNDS()],
    ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
    ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
    ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
    ["SUBSCRIPTION_CREATE", require_SUBSCRIPTION_CREATE()],
    ["SUBSCRIPTION_DELETE", require_SUBSCRIPTION_DELETE()],
    ["SUBSCRIPTION_UPDATE", require_SUBSCRIPTION_UPDATE()],
    ["THREAD_CREATE", require_THREAD_CREATE()],
    ["THREAD_DELETE", require_THREAD_DELETE()],
    ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
    ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
    ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
    ["THREAD_UPDATE", require_THREAD_UPDATE()],
    ["TYPING_START", require_TYPING_START()],
    ["USER_UPDATE", require_USER_UPDATE()],
    ["VOICE_CHANNEL_EFFECT_SEND", require_VOICE_CHANNEL_EFFECT_SEND()],
    ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
    ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
    ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
  ]);
  module.exports = handlers;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setImmediate: setImmediate2 } = __require("node:timers");
  var { Collection } = require_dist6();
  var {
    WebSocketManager: WSWebSocketManager,
    WebSocketShardEvents: WSWebSocketShardEvents,
    CompressionMethod,
    CloseCodes
  } = require_dist10();
  var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var zlib;
  try {
    zlib = (()=>{throw new Error("Cannot require module "+"zlib-sync");})();
  } catch {}
  var BeforeReadyWhitelist = [
    GatewayDispatchEvents.Ready,
    GatewayDispatchEvents.Resumed,
    GatewayDispatchEvents.GuildCreate,
    GatewayDispatchEvents.GuildDelete,
    GatewayDispatchEvents.GuildMembersChunk,
    GatewayDispatchEvents.GuildMemberAdd,
    GatewayDispatchEvents.GuildMemberRemove
  ];
  var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
  var UNRECOVERABLE_CLOSE_CODES = [
    GatewayCloseCodes.AuthenticationFailed,
    GatewayCloseCodes.InvalidShard,
    GatewayCloseCodes.ShardingRequired,
    GatewayCloseCodes.InvalidAPIVersion,
    GatewayCloseCodes.InvalidIntents,
    GatewayCloseCodes.DisallowedIntents
  ];
  var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
  var deprecationEmittedForInvalidSessionEvent = false;
  var deprecationEmittedForDestroyedEvent = false;

  class WebSocketManager extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.gateway = null;
      this.shards = new Collection;
      Object.defineProperty(this, "packetQueue", { value: [] });
      this.status = Status.Idle;
      this.destroyed = false;
      this._ws = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(messages, shardId) {
      this.client.emit(Events.Debug, `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${messages.join(`
	`)}`);
    }
    async connect() {
      const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
      const { shards, shardCount, intents, ws } = this.client.options;
      if (this._ws && this._ws.options.token !== this.client.token) {
        await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
        this._ws = null;
      }
      if (!this._ws) {
        const wsOptions = {
          intents: intents.bitfield,
          rest: this.client.rest,
          token: this.client.token,
          largeThreshold: ws.large_threshold,
          version: ws.version,
          shardIds: shards === "auto" ? null : shards,
          shardCount: shards === "auto" ? null : shardCount,
          initialPresence: ws.presence,
          retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
          updateSessionInfo: (shardId, sessionInfo) => {
            this.shards.get(shardId).sessionInfo = sessionInfo;
          },
          compression: zlib ? CompressionMethod.ZlibStream : null
        };
        if (ws.buildIdentifyThrottler)
          wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
        if (ws.buildStrategy)
          wsOptions.buildStrategy = ws.buildStrategy;
        this._ws = new WSWebSocketManager(wsOptions);
        this.attachEvents();
      }
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this._ws.fetchGatewayInformation().catch((error) => {
        throw error.status === 401 ? invalidToken : error;
      });
      const { total, remaining } = sessionStartLimit;
      this.debug(["Fetched Gateway Information", `URL: ${gatewayURL}`, `Recommended Shards: ${recommendedShards}`]);
      this.debug(["Session Limit Information", `Total: ${total}`, `Remaining: ${remaining}`]);
      this.gateway = `${gatewayURL}/`;
      this.client.options.shardCount = await this._ws.getShardCount();
      this.client.options.shards = await this._ws.getShardIds();
      this.totalShards = this.client.options.shards.length;
      for (const id of this.client.options.shards) {
        if (!this.shards.has(id)) {
          const shard = new WebSocketShard(this, id);
          this.shards.set(id, shard);
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
            this.checkShardsReady();
          });
          shard.status = Status.Connecting;
        }
      }
      await this._ws.connect();
      this.shards.forEach((shard) => {
        if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
          process2.emitWarning("The WebSocketShard#invalidSession event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForInvalidSessionEvent = true;
        }
        if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
          process2.emitWarning("The WebSocketShard#destroyed event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForDestroyedEvent = true;
        }
      });
    }
    attachEvents() {
      this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug([message], shardId));
      this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
        this.client.emit(Events.Raw, data, shardId);
        this.emit(data.t, data.d, shardId);
        const shard = this.shards.get(shardId);
        this.handlePacket(data, shard);
        if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
          shard.gotGuild(data.d.id);
        }
      });
      this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
        this.shards.get(shardId).onReadyPacket(data);
      });
      this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
        const shard = this.shards.get(shardId);
        shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
        if (UNRECOVERABLE_CLOSE_CODES.includes(code)) {
          shard.status = Status.Disconnected;
          this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
          this.debug([`Shard not recoverable: ${code} (${GatewayCloseCodes[code] ?? CloseCodes[code]})`], shardId);
          return;
        }
        this.shards.get(shardId).status = Status.Connecting;
        this.client.emit(Events.ShardReconnecting, shardId);
      });
      this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        if (shard.sessionInfo) {
          shard.closeSequence = shard.sessionInfo.sequence;
          shard.status = Status.Resuming;
        } else {
          shard.status = Status.Identifying;
        }
      });
      this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        shard.status = Status.Ready;
        shard.emit(WebSocketShardEvents.Resumed);
      });
      this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
        this.debug([`Heartbeat acknowledged, latency of ${latency}ms.`], shardId);
        const shard = this.shards.get(shardId);
        shard.lastPingTimestamp = heartbeatAt;
        shard.ping = latency;
      });
      this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
        this.client.emit(Events.ShardError, error, shardId);
      });
    }
    broadcast(packet) {
      for (const shardId of this.shards.keys())
        this._ws.send(shardId, packet);
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.debug([Object.assign(new Error, { name: "Manager was destroyed:" }).stack]);
      this.destroyed = true;
      await this._ws?.destroy({ code: CloseCodes.Normal, reason: "Manager was destroyed" });
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status.Ready) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({ packet, shard });
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        setImmediate2(() => {
          this.handlePacket(item.packet, item.shard);
        }).unref();
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    checkShardsReady() {
      if (this.status === Status.Ready)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((shard) => shard.status !== Status.Ready)) {
        return;
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status.Ready;
      this.client.readyTimestamp = Date.now();
      this.client.emit(Events.ClientReady, this.client);
      this.handlePacket();
    }
  }
  module.exports = WebSocketManager;
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var { parseEmoji } = require_Util();

  class BaseGuildEmojiManager extends CachedManager {
    constructor(client, iterable) {
      super(client, GuildEmoji, iterable);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return this.cache.get(emoji.id) ?? null;
      if (emoji instanceof ApplicationEmoji)
        return this.cache.get(emoji.id) ?? null;
      return super.resolve(emoji);
    }
    resolveId(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      if (emoji instanceof ApplicationEmoji)
        return emoji.id;
      return super.resolveId(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (emoji instanceof ApplicationEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res?.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        return emoji;
      }
      return null;
    }
  }
  module.exports = BaseGuildEmojiManager;
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { BaseChannel } = require_BaseChannel();
  var { createChannel } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var Events = require_Events();
  var cacheWarningEmitted = false;

  class ChannelManager extends CachedManager {
    constructor(client, iterable) {
      super(client, BaseChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (cache)
          existing._patch(data);
        guild?.channels?._add(existing);
        if (ThreadChannelTypes.includes(existing.type)) {
          existing.parent?.threads?._add(existing);
        }
        return existing;
      }
      const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
      if (!channel) {
        this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache && !allowUnknownGuild)
        this.cache.set(channel.id, channel);
      return channel;
    }
    _remove(id) {
      const channel = this.cache.get(id);
      channel?.guild?.channels.cache.delete(id);
      for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
        if (invite.channelId === id)
          channel.guild.invites.cache.delete(code);
      }
      channel?.parent?.threads?.cache.delete(id);
      this.cache.delete(id);
      if (channel?.threads) {
        for (const threadId of channel.threads.cache.keys()) {
          this.cache.delete(threadId);
          channel.guild?.channels.cache.delete(threadId);
        }
      }
    }
    async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channel(id));
      return this._add(data, null, { cache, allowUnknownGuild });
    }
  }
  module.exports = ChannelManager;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { calculateShardId } = require_dist();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var { makeError, makePlainError } = require_Util();

  class ShardClientUtil {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      switch (mode) {
        case "process":
          process2.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            process2.send({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            process2.send({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            process2.send({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            process2.send({ _resume: true });
          });
          break;
        case "worker":
          this.parentPort = __require("node:worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            this.parentPort.postMessage({ _resume: true });
          });
          break;
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        switch (this.mode) {
          case "process":
            process2.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
            break;
          case "worker":
            this.parentPort.postMessage(message);
            resolve();
            break;
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        const listener = (message) => {
          if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    broadcastEval(script2, options = {}) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        if (typeof script2 !== "function") {
          reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
          return;
        }
        script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
        const listener = (message) => {
          if (message?._sEval !== script2 || message._sEvalShard !== options.shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        try {
          const props = message._fetchProp.split(".");
          let value = this.client;
          for (const prop of props)
            value = value[prop];
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
        } catch (err) {
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
        }
      } else if (message._eval) {
        try {
          this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
        } catch (err) {
          this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
        error.stack = err.stack;
        this.client.emit(Events.Error, error);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events.Warn, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIdForGuildId(guildId, shardCount) {
      const shard = calculateShardId(guildId, shardCount);
      if (shard < 0)
        throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);
      return shard;
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = ShardClientUtil;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var ApplicationCommand = require_ApplicationCommand();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var { flatten } = require_Util();

  class GuildAuditLogs {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users._add(user);
      if (data.threads)
        for (const thread of data.threads)
          guild.client.channels._add(thread, guild);
      this.webhooks = new Collection;
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.integrations = new Collection;
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.guildScheduledEvents = data.guild_scheduled_events.reduce((guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)), new Collection);
      this.applicationCommands = new Collection;
      if (data.application_commands) {
        for (const command of data.application_commands) {
          this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
        }
      }
      this.autoModerationRules = data.auto_moderation_rules.reduce((autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)), new Collection);
      this.entries = new Collection;
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(guild, item, this);
        this.entries.set(entry.id, entry);
      }
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();

  class GuildOnboarding extends Base {
    constructor(client, data) {
      super(client);
      this.guildId = data.guild_id;
      const guild = this.guild;
      this.prompts = data.prompts.reduce((prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)), new Collection);
      this.defaultChannels = data.default_channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.enabled = data.enabled;
      this.mode = data.mode;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboarding = GuildOnboarding;
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports, module) => {
  var BaseGuildEmoji = require_BaseGuildEmoji();

  class GuildPreviewEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.roles = data.roles;
    }
  }
  module.exports = GuildPreviewEmoji;
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var { Sticker } = require_Sticker();

  class GuildPreview extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      }
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("features" in data) {
        this.features = data.features;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if (!this.emojis) {
        this.emojis = new Collection;
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
      this.stickers = data.stickers.reduce((stickers, sticker) => stickers.set(sticker.id, new Sticker(this.client, sticker)), new Collection);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      this._patch(data);
      return this;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  }
  module.exports = GuildPreview;
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var AutoModerationRule = require_AutoModerationRule();

  class AutoModerationRuleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, AutoModerationRule, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({
      name,
      eventType,
      triggerType,
      triggerMetadata,
      actions,
      enabled,
      exemptRoles,
      exemptChannels,
      reason
    }) {
      const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {
        body: {
          name,
          event_type: eventType,
          trigger_type: triggerType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
        body: {
          name,
          event_type: eventType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions?.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { autoModerationRule, cache, force } = options;
      const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
      if (resolvedAutoModerationRule) {
        return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ autoModerationRule, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(autoModerationRule);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));
      return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection);
    }
    async delete(autoModerationRule, reason) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
    }
  }
  module.exports = AutoModerationRuleManager;
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS((exports, module) => {
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();

  class GuildApplicationCommandManager extends ApplicationCommandManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
  }
  module.exports = GuildApplicationCommandManager;
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var GuildBan = require_GuildBan();
  var { GuildMember } = require_GuildMember();
  var deprecationEmittedForDeleteMessageDays = false;

  class GuildBanManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildBan, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(ban) {
      return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user, cache, force, limit, before, after } = options;
      const resolvedUser = this.client.users.resolveId(user ?? options);
      if (resolvedUser)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      if (!before && !after && !limit && cache === undefined) {
        throw new DiscordjsError(ErrorCodes.FetchBanResolveId);
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildBan(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildBans(this.guild.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection);
    }
    async create(user, options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId, true);
      if (options.deleteMessageDays !== undefined && !deprecationEmittedForDeleteMessageDays) {
        process2.emitWarning("The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.", "DeprecationWarning");
        deprecationEmittedForDeleteMessageDays = true;
      }
      await this.client.rest.put(Routes.guildBan(this.guild.id, id), {
        body: {
          delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : undefined)
        },
        reason: options.reason
      });
      if (user instanceof GuildMember)
        return user;
      const _user = this.client.users.cache.get(id);
      if (_user) {
        return this.guild.members.resolve(_user) ?? _user;
      }
      return id;
    }
    async remove(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId);
      await this.client.rest.delete(Routes.guildBan(this.guild.id, id), { reason });
      return this.client.users.resolve(user);
    }
    async bulkCreate(users, options = {}) {
      if (!users || !(Array.isArray(users) || users instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users", "Array or Collection of UserResolvable", true);
      }
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const userIds = users.map((user) => this.client.users.resolveId(user));
      if (userIds.length === 0)
        throw new DiscordjsError(ErrorCodes.BulkBanUsersOptionEmpty);
      const result = await this.client.rest.post(Routes.guildBulkBan(this.guild.id), {
        body: { delete_message_seconds: options.deleteMessageSeconds, user_ids: userIds },
        reason: options.reason
      });
      return { bannedUsers: result.banned_users, failedUsers: result.failed_users };
    }
  }
  module.exports = GuildBanManager;
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var ThreadChannel = require_ThreadChannel();
  var Webhook = require_Webhook();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var { resolveImage } = require_DataResolver();
  var { setPosition } = require_Util();
  var cacheWarningEmitted = false;

  class GuildChannelManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    get channelCountWithoutThreads() {
      return this.cache.reduce((acc, channel) => {
        if (ThreadChannelTypes.includes(channel.type))
          return acc;
        return ++acc;
      }, 0);
    }
    _add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    resolve(channel) {
      if (channel instanceof ThreadChannel)
        return this.cache.get(channel.id) ?? null;
      return super.resolve(channel);
    }
    resolveId(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolveId(channel.id);
      return super.resolveId(channel);
    }
    async addFollower(channel, targetChannel, reason) {
      const channelId = this.resolveId(channel);
      if (!channelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "NewsChannelResolvable");
      }
      const targetChannelId = this.resolveId(targetChannel);
      if (!targetChannelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "targetChannel", "TextChannelResolvable");
      }
      const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {
        body: { webhook_channel_id: targetChannelId },
        reason
      });
      return webhook_id;
    }
    async create({
      name,
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      rtcRegion,
      videoQualityMode,
      defaultThreadRateLimitPerUser,
      availableTags,
      defaultReactionEmoji,
      defaultAutoArchiveDuration,
      defaultSortOrder,
      defaultForumLayout,
      reason
    }) {
      parent &&= this.client.channels.resolveId(parent);
      permissionOverwrites &&= permissionOverwrites.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {
        body: {
          name,
          topic,
          type,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser,
          rtc_region: rtcRegion,
          video_quality_mode: videoQualityMode,
          default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser,
          available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
          default_auto_archive_duration: defaultAutoArchiveDuration,
          default_sort_order: defaultSortOrder,
          default_forum_layout: defaultForumLayout
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async createWebhook({ channel, name, avatar, reason }) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      if (typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await resolveImage(avatar);
      }
      const data = await this.client.rest.post(Routes.channelWebhooks(id), {
        body: {
          name,
          avatar
        },
        reason
      });
      return new Webhook(this.client, data);
    }
    async edit(channel, options) {
      const resolvedChannel = this.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const parentId = options.parent && this.client.channels.resolveId(options.parent);
      if (options.position !== undefined) {
        await this.setPosition(resolvedChannel, options.position, { position: options.position, reason: options.reason });
      }
      let permission_overwrites = options.permissionOverwrites?.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      if (options.lockPermissions) {
        if (parentId) {
          const newParent = this.cache.get(parentId);
          if (newParent?.type === ChannelType.GuildCategory) {
            permission_overwrites = newParent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
          }
        } else if (resolvedChannel.parent) {
          permission_overwrites = resolvedChannel.parent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
        }
      }
      const newData = await this.client.rest.patch(Routes.channel(resolvedChannel.id), {
        body: {
          name: options.name,
          type: options.type,
          topic: options.topic,
          nsfw: options.nsfw,
          bitrate: options.bitrate,
          user_limit: options.userLimit,
          rtc_region: options.rtcRegion,
          video_quality_mode: options.videoQualityMode,
          parent_id: parentId,
          lock_permissions: options.lockPermissions,
          rate_limit_per_user: options.rateLimitPerUser,
          default_auto_archive_duration: options.defaultAutoArchiveDuration,
          permission_overwrites,
          available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
          default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,
          default_sort_order: options.defaultSortOrder,
          default_forum_layout: options.defaultForumLayout
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    async setPosition(channel, position, { relative, reason } = {}) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels
      });
      return channel;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      if (id) {
        const data2 = await this.client.rest.get(Routes.channel(id));
        if (this.guild.id !== data2.guild_id)
          throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);
        return this.client.channels._add(data2, this.guild, { cache });
      }
      const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));
      const channels = new Collection;
      for (const channel of data)
        channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
      return channels;
    }
    async fetchWebhooks(channel) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const data = await this.client.rest.get(Routes.channelWebhooks(id));
      return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection);
    }
    async setPositions(channelPositions) {
      channelPositions = channelPositions.map((channelPosition) => ({
        id: this.client.channels.resolveId(channelPosition.channel),
        position: channelPosition.position,
        lock_permissions: channelPosition.lockPermissions,
        parent_id: channelPosition.parent !== undefined ? this.resolveId(channelPosition.parent) : undefined
      }));
      await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });
      return this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: channelPositions
      }).guild;
    }
    async fetchActiveThreads(cache = true) {
      const data = await this.rawFetchGuildActiveThreads();
      return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
    }
    rawFetchGuildActiveThreads() {
      return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));
    }
    async delete(channel, reason) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      await this.client.rest.delete(Routes.channel(id), { reason });
      this.client.actions.ChannelDelete.handle({ id });
    }
  }
  module.exports = GuildChannelManager;
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes, PermissionFlagsBits } = require_v106();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { resolveImage } = require_DataResolver();

  class GuildEmojiManager extends BaseGuildEmojiManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ attachment, name, roles, reason }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      if (roles) {
        if (!Array.isArray(roles) && !(roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        body.roles = [];
        for (const role of roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          body.roles.push(resolvedRole);
        }
      }
      const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });
      return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));
        return this._add(emoji, cache);
      }
      const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji, reason) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const roles = options.roles?.map((role) => this.guild.roles.resolveId(role));
      const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {
        body: {
          name: options.name,
          roles
        },
        reason: options.reason
      });
      const existing = this.cache.get(id);
      if (existing) {
        const clone = existing._clone();
        clone._patch(newData);
        return clone;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      emoji = this.resolve(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      if (emoji.managed) {
        throw new DiscordjsError(ErrorCodes.EmojiManaged);
      }
      const { me } = this.guild.members;
      if (!me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
        throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);
      }
      const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));
      emoji._patch(data);
      return emoji.author;
    }
  }
  module.exports = GuildEmojiManager;
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();
  var { resolveInviteCode } = require_DataResolver();

  class GuildInviteManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Invite, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.code, extras: [this.guild] });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      if (typeof options === "string") {
        const code = resolveInviteCode(options);
        if (!code)
          throw new DiscordjsError(ErrorCodes.InviteResolveCode);
        return this._fetchSingle({ code, cache: true });
      }
      if (!options.code) {
        if (options.channelId) {
          const id = this.guild.channels.resolveId(options.channelId);
          if (!id)
            throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
          return this._fetchChannelMany(id, options.cache);
        }
        if ("cache" in options)
          return this._fetchMany(options.cache);
        throw new DiscordjsError(ErrorCodes.InviteResolveCode);
      }
      return this._fetchSingle({
        ...options,
        code: resolveInviteCode(options.code)
      });
    }
    async _fetchSingle({ code, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(code);
        if (existing)
          return existing;
      }
      const invites = await this._fetchMany(cache);
      const invite = invites.get(code);
      if (!invite)
        throw new DiscordjsError(ErrorCodes.InviteNotFound);
      return invite;
    }
    async _fetchMany(cache) {
      const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async _fetchChannelMany(channelId, cache) {
      const data = await this.client.rest.get(Routes.channelInvites(channelId));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
      const id = this.guild.channels.resolveId(channel);
      if (!id)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const invite = await this.client.rest.post(Routes.channelInvites(id), {
        body: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
          target_user_id: this.client.users.resolveId(targetUser),
          target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
          target_type: targetType
        },
        reason
      });
      return new Invite(this.client, invite);
    }
    async delete(invite, reason) {
      const code = resolveInviteCode(invite);
      await this.client.rest.delete(Routes.invite(code), { reason });
    }
  }
  module.exports = GuildInviteManager;
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GatewayOpcodes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  var { GuildMember } = require_GuildMember();
  var { Role } = require_Role();
  var Events = require_Events();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var Partials = require_Partials();

  class GuildMemberManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildMember, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return this.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      return this.cache.has(userId) ? userId : null;
    }
    async add(user, options) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (!options.force) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
          return cachedUser;
      }
      const resolvedOptions = {
        access_token: options.accessToken,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf
      };
      if (options.roles) {
        if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const resolvedRoles = [];
        for (const role of options.roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        resolvedOptions.roles = resolvedRoles;
      }
      const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });
      return data instanceof ArrayBuffer ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user: users, limit, withPresences, cache, force } = options;
      const resolvedUser = this.client.users.resolveId(users ?? options);
      if (resolvedUser && !limit && !withPresences)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;
      return this._fetchMany({ ...options, users: resolvedUsers });
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany({
      limit = 0,
      withPresences: presences,
      users,
      query,
      time = 120000,
      nonce = DiscordSnowflake.generate().toString()
    } = {}) {
      if (nonce.length > 32)
        throw new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength);
      return new Promise((resolve, reject) => {
        if (!query && !users)
          query = "";
        this.guild.shard.send({
          op: GatewayOpcodes.RequestGuildMembers,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids: users,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection;
        let i = 0;
        const handler = (members, _, chunk) => {
          if (chunk.nonce !== nonce)
            return;
          timeout.refresh();
          i++;
          for (const member of members.values()) {
            fetchedMembers.set(member.id, member);
          }
          if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildMembersChunk, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.GuildMembersChunk, handler);
      });
    }
    fetchMe(options) {
      return this.fetch({ ...options, user: this.client.user.id });
    }
    async search({ query, limit, cache = true } = {}) {
      const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {
        query: makeURLSearchParams({ query, limit })
      });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async list({ after, limit, cache = true } = {}) {
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async edit(user, { reason, ...options }) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (options.channel) {
        options.channel = this.guild.channels.resolve(options.channel);
        if (!(options.channel instanceof BaseGuildVoiceChannel)) {
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        }
        options.channel_id = options.channel.id;
        options.channel = undefined;
      } else if (options.channel === null) {
        options.channel_id = null;
        options.channel = undefined;
      }
      options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
      if (options.communicationDisabledUntil !== undefined) {
        options.communication_disabled_until = options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
      }
      if (options.flags !== undefined) {
        options.flags = GuildMemberFlagsBitField.resolve(options.flags);
      }
      let endpoint;
      if (id === this.client.user.id) {
        const keys = Object.keys(options);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = Routes.guildMember(this.guild.id);
        else
          endpoint = Routes.guildMember(this.guild.id, id);
      } else {
        endpoint = Routes.guildMember(this.guild.id, id);
      }
      const d = await this.client.rest.patch(endpoint, { body: options, reason });
      const clone = this.cache.get(id)?._clone();
      clone?._patch(d);
      return clone ?? this._add(d, false);
    }
    async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
      if (typeof days !== "number")
        throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);
      const query = { days };
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "options.roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = Routes.guildPrune(this.guild.id);
      const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
      return pruned;
    }
    async kick(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
    }
    ban(user, options) {
      return this.guild.bans.create(user, options);
    }
    unban(user, reason) {
      return this.guild.bans.remove(user, reason);
    }
    bulkBan(users, options = {}) {
      return this.guild.bans.bulkCreate(users, options);
    }
    async addRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
    async removeRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
  }
  module.exports = GuildMemberManager;
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GuildScheduledEventEntityType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var { resolveImage } = require_DataResolver();
  var { _transformGuildScheduledEventRecurrenceRule } = require_Transformers();

  class GuildScheduledEventManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildScheduledEvent, iterable);
      this.guild = guild;
    }
    async create(options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata, channel_id;
      if (entityType === GuildScheduledEventEntityType.External) {
        channel_id = channel === undefined ? channel : null;
        entity_metadata = { location: entityMetadata?.location };
      } else {
        channel_id = this.guild.channels.resolveId(channel);
        if (!channel_id)
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        entity_metadata = entityMetadata === undefined ? entityMetadata : null;
      }
      const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {
        body: {
          channel_id,
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: new Date(scheduledStartTime).toISOString(),
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          entity_metadata,
          image: image && await resolveImage(image),
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async fetch(options = {}) {
      const id = this.resolveId(options.guildScheduledEvent ?? options);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {
          query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {
        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
      });
      return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this._add(rawGuildScheduledEventData, options.cache)), new Collection);
    }
    async edit(guildScheduledEvent, options) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        status,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata;
      if (entityMetadata) {
        entity_metadata = {
          location: entityMetadata.location
        };
      }
      const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
        body: {
          channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          status,
          image: image && await resolveImage(image),
          entity_metadata,
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async delete(guildScheduledEvent) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));
    }
    async fetchSubscribers(guildScheduledEvent, options = {}) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      const query = makeURLSearchParams({
        limit: options.limit,
        with_member: options.withMember,
        before: options.before,
        after: options.after
      });
      const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
        query
      });
      return data.reduce((coll, rawData) => coll.set(rawData.user.id, {
        guildScheduledEventId: rawData.guild_scheduled_event_id,
        user: this.client.users._add(rawData.user),
        member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
      }), new Collection);
    }
  }
  module.exports = GuildScheduledEventManager;
});

// node_modules/discord.js/src/structures/SoundboardSound.js
var require_SoundboardSound = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class SoundboardSound extends Base {
    constructor(client, data) {
      super(client);
      this.soundId = data.sound_id;
      this._patch(data);
    }
    _patch(data) {
      if ("available" in data) {
        this.available = data.available;
      } else {
        this.available ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("volume" in data) {
        this.volume = data.volume;
      } else {
        this.volume ??= null;
      }
      if ("emoji_id" in data) {
        this._emoji = {
          id: data.emoji_id,
          name: data.emoji_name
        };
      } else {
        this._emoji ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.soundId);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get emoji() {
      if (!this._emoji)
        return null;
      return this.guild?.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.soundboardSound(this.soundId);
    }
    async edit(options) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "edited");
      return this.guild.soundboardSounds.edit(this, options);
    }
    async delete(reason) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "deleted");
      await this.guild.soundboardSounds.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof SoundboardSound) {
        return this.soundId === other.soundId && this.available === other.available && this.name === other.name && this.volume === other.volume && this._emoji?.id === other._emoji?.id && this._emoji?.name === other._emoji?.name && this.guildId === other.guildId && this.user?.id === other.user?.id;
      }
      return this.soundId === other.sound_id && this.available === other.available && this.name === other.name && this.volume === other.volume && (this._emoji?.id ?? null) === other.emoji_id && (this._emoji?.name ?? null) === other.emoji_name && this.guildId === other.guild_id && this.user?.id === other.user?.id;
    }
  }
  exports.SoundboardSound = SoundboardSound;
});

// node_modules/discord.js/src/managers/GuildSoundboardSoundManager.js
var require_GuildSoundboardSoundManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { lazy } = require_dist();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { SoundboardSound } = require_SoundboardSound();
  var { resolveBase64, resolveFile } = require_DataResolver();
  var fileTypeMime = lazy(() => require_dist4().filetypemime);

  class GuildSoundboardSoundManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, SoundboardSound, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild], id: data.sound_id });
    }
    resolveId(soundboardSound) {
      if (soundboardSound instanceof this.holds)
        return soundboardSound.soundId;
      if (typeof soundboardSound === "string")
        return soundboardSound;
      return null;
    }
    async create({ contentType, emojiId, emojiName, file, name, reason, volume }) {
      const resolvedFile = await resolveFile(file);
      const resolvedContentType = contentType ?? resolvedFile.contentType ?? fileTypeMime()(resolvedFile.data)[0];
      const sound = resolveBase64(resolvedFile.data, resolvedContentType);
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, sound, volume };
      const soundboardSound = await this.client.rest.post(Routes.guildSoundboardSounds(this.guild.id), {
        body,
        reason
      });
      return this._add(soundboardSound);
    }
    async edit(soundboardSound, options = {}) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      const { emojiId, emojiName, name, reason, volume } = options;
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, volume };
      const data = await this.client.rest.patch(Routes.guildSoundboardSound(this.guild.id, soundId), {
        body,
        reason
      });
      const existing = this.cache.get(soundId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(soundboardSound, reason) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      await this.client.rest.delete(Routes.guildSoundboardSound(this.guild.id, soundId), { reason });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { cache, force, soundboardSound } = options;
      const resolvedSoundboardSound = this.resolveId(soundboardSound ?? options);
      if (resolvedSoundboardSound)
        return this._fetchSingle({ cache, force, soundboardSound: resolvedSoundboardSound });
      return this._fetchMany({ cache });
    }
    async _fetchSingle({ cache, force, soundboardSound } = {}) {
      if (!force) {
        const existing = this.cache.get(soundboardSound);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildSoundboardSound(this.guild.id, soundboardSound));
      return this._add(data, cache);
    }
    async _fetchMany({ cache } = {}) {
      const data = await this.client.rest.get(Routes.guildSoundboardSounds(this.guild.id));
      return data.items.reduce((coll, sound) => coll.set(sound.sound_id, this._add(sound, cache)), new Collection);
    }
  }
  exports.GuildSoundboardSoundManager = GuildSoundboardSoundManager;
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();
  var { Sticker } = require_Sticker();

  class GuildStickerManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Sticker, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ file, name, tags, description, reason } = {}) {
      const resolvedFile = await MessagePayload.resolveFile(file);
      if (!resolvedFile)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      file = { ...resolvedFile, key: "file" };
      const body = { name, tags, description: description ?? "" };
      const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {
        appendToFormData: true,
        body,
        files: [file],
        reason
      });
      return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
    }
    async edit(sticker, options = {}) {
      const stickerId = this.resolveId(sticker);
      if (!stickerId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {
        body: options,
        reason: options.reason
      });
      const existing = this.cache.get(stickerId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async delete(sticker, reason) {
      sticker = this.resolveId(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));
        return this._add(sticker, cache);
      }
      const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));
      return new Collection(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
    }
    async fetchUser(sticker) {
      sticker = this.resolve(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));
      sticker._patch(data);
      return sticker.user;
    }
  }
  module.exports = GuildStickerManager;
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS((exports, module) => {
  var { ActivityFlags } = require_v106();
  var BitField = require_BitField();

  class ActivityFlagsBitField extends BitField {
    static Flags = ActivityFlags;
  }
  module.exports = ActivityFlagsBitField;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var ActivityFlagsBitField = require_ActivityFlagsBitField();
  var { flatten } = require_Util();

  class Presence extends Base {
    constructor(client, data = {}) {
      super(client);
      this.userId = data.user.id;
      this.guild = data.guild ?? null;
      this._patch(data);
    }
    get user() {
      return this.client.users.resolve(this.userId);
    }
    get member() {
      return this.guild.members.resolve(this.userId);
    }
    _patch(data) {
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= "offline";
      }
      if ("activities" in data) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else {
        this.activities ??= [];
      }
      if ("client_status" in data) {
        this.clientStatus = data.client_status;
      } else {
        this.clientStatus ??= null;
      }
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index]));
    }
    toJSON() {
      return flatten(this);
    }
  }

  class Activity {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", { value: presence });
      this.name = data.name;
      this.type = data.type;
      this.url = data.url ?? null;
      this.details = data.details ?? null;
      this.state = data.state ?? null;
      this.applicationId = data.application_id ?? null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party ?? null;
      this.syncId = data.sync_id ?? null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.flags = new ActivityFlagsBitField(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.buttons = data.buttons ?? [];
      this.createdTimestamp = data.created_at;
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  }

  class RichPresenceAssets {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", { value: activity });
      this.largeText = assets.large_text ?? null;
      this.smallText = assets.small_text ?? null;
      this.largeImage = assets.large_image ?? null;
      this.smallImage = assets.small_image ?? null;
    }
    smallImageURL(options = {}) {
      if (!this.smallImage)
        return null;
      if (this.smallImage.includes(":")) {
        const [platform, id] = this.smallImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
    }
    largeImageURL(options = {}) {
      if (!this.largeImage)
        return null;
      if (this.largeImage.includes(":")) {
        const [platform, id] = this.largeImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          case "spotify":
            return `https://i.scdn.co/image/${id}`;
          case "youtube":
            return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
          case "twitch":
            return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
    }
  }
  exports.Presence = Presence;
  exports.Activity = Activity;
  exports.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var { Presence } = require_Presence();

  class PresenceManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Presence, iterable);
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id });
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return super.cache.get(userId) ?? null;
    }
    resolveId(presence) {
      const presenceResolvable = super.resolveId(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return this.cache.has(userId) ? userId : null;
    }
  }
  module.exports = PresenceManager;
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { DiscordAPIError } = require_dist5();
  var { RESTJSONErrorCodes, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();
  var { setPosition, resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class RoleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Role, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (!id) {
        const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));
        const roles = new Collection;
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return roles;
      }
      if (!force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      try {
        const data = await this.client.rest.get(Routes.guildRole(this.guild.id, id));
        return this._add(data, cache);
      } catch (error) {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownRole) {
          return null;
        }
        throw error;
      }
    }
    async create(options = {}) {
      let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
      color &&= resolveColor(color);
      if (permissions !== undefined)
        permissions = new PermissionsBitField(permissions);
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {
        body: {
          name,
          color,
          hoist,
          permissions,
          mentionable,
          icon,
          unicode_emoji: unicodeEmoji
        },
        reason
      });
      const { role } = this.client.actions.GuildRoleCreate.handle({
        guild_id: this.guild.id,
        role: data
      });
      if (position)
        return this.setPosition(role, position, { reason });
      return role;
    }
    async edit(role, options) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      if (typeof options.position === "number") {
        await this.setPosition(role, options.position, { reason: options.reason });
      }
      let icon = options.icon;
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const body = {
        name: options.name,
        color: options.color === undefined ? undefined : resolveColor(options.color),
        hoist: options.hoist,
        permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),
        mentionable: options.mentionable,
        icon,
        unicode_emoji: options.unicodeEmoji
      };
      const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });
      const clone = role._clone();
      clone._patch(d);
      return clone;
    }
    async delete(role, reason) {
      const id = this.resolveId(role);
      await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
    }
    async setPosition(role, position, { relative, reason } = {}) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles
      });
      return role;
    }
    async setPositions(rolePositions) {
      rolePositions = rolePositions.map((rolePosition) => ({
        id: this.resolveId(rolePosition.role),
        position: rolePosition.position
      }));
      await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });
      return this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: rolePositions
      }).guild;
    }
    comparePositions(role1, role2) {
      const resolvedRole1 = this.resolve(role1);
      const resolvedRole2 = this.resolve(role2);
      if (!resolvedRole1 || !resolvedRole2) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "Role nor a Snowflake");
      }
      const role1Position = resolvedRole1.position;
      const role2Position = resolvedRole2.position;
      if (role1Position === role2Position) {
        return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
      }
      return role1Position - role2Position;
    }
    botRoleFor(user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        return null;
      return this.cache.find((role) => role.tags?.botId === userId) ?? null;
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  }
  module.exports = RoleManager;
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { StageInstance } = require_StageInstance();

  class StageInstanceManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, StageInstance, iterable);
      this.guild = guild;
    }
    async create(channel, options) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
      const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
      const data = await this.client.rest.post(Routes.stageInstances(), {
        body: {
          channel_id: channelId,
          topic,
          privacy_level: privacyLevel,
          send_start_notification: sendStartNotification,
          guild_scheduled_event_id: guildScheduledEventId
        }
      });
      return this._add(data);
    }
    async fetch(channel, { cache = true, force = false } = {}) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (!force) {
        const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.stageInstance(channelId));
      return this._add(data, cache);
    }
    async edit(channel, options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      let { topic, privacyLevel } = options;
      const data = await this.client.rest.patch(Routes.stageInstance(channelId), {
        body: {
          topic,
          privacy_level: privacyLevel
        }
      });
      if (this.cache.has(data.id)) {
        const clone = this.cache.get(data.id)._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(channel) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      await this.client.rest.delete(Routes.stageInstance(channelId));
    }
  }
  module.exports = StageInstanceManager;
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var VoiceState = require_VoiceState();

  class VoiceStateManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, VoiceState, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
    async fetch(member, { cache = true, force = false } = {}) {
      const id = member === "@me" ? member : this.guild.members.resolveId(member);
      if (!force) {
        const existing = this.cache.get(id === "@me" ? this.client.user.id : id);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildVoiceState(this.guild.id, id));
      return this._add(data, cache);
    }
  }
  module.exports = VoiceStateManager;
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS((exports, module) => {
  var { GuildSystemChannelFlags } = require_v106();
  var BitField = require_BitField();

  class SystemChannelFlagsBitField extends BitField {
    static Flags = GuildSystemChannelFlags;
  }
  module.exports = SystemChannelFlagsBitField;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, GuildPremiumTier, Routes, GuildFeature } = require_v106();
  var AnonymousGuild = require_AnonymousGuild();
  var GuildAuditLogs = require_GuildAuditLogs();
  var { GuildOnboarding } = require_GuildOnboarding();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var WelcomeScreen = require_WelcomeScreen();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var AutoModerationRuleManager = require_AutoModerationRuleManager();
  var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  var GuildBanManager = require_GuildBanManager();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildInviteManager = require_GuildInviteManager();
  var GuildMemberManager = require_GuildMemberManager();
  var GuildScheduledEventManager = require_GuildScheduledEventManager();
  var { GuildSoundboardSoundManager } = require_GuildSoundboardSoundManager();
  var GuildStickerManager = require_GuildStickerManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var StageInstanceManager = require_StageInstanceManager();
  var VoiceStateManager = require_VoiceStateManager();
  var { resolveImage } = require_DataResolver();
  var Status = require_Status();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { discordSort, getSortableGroupTypes, resolvePartialEmoji } = require_Util();

  class Guild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data, false);
      this.commands = new GuildApplicationCommandManager(this);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.bans = new GuildBanManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.stageInstances = new StageInstanceManager(this);
      this.invites = new GuildInviteManager(this);
      this.scheduledEvents = new GuildScheduledEventManager(this);
      this.autoModerationRules = new AutoModerationRuleManager(this);
      this.soundboardSounds = new GuildSoundboardSoundManager(this);
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardId = data.shardId;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardId);
    }
    _patch(data) {
      super._patch(data);
      this.id = data.id;
      if ("name" in data)
        this.name = data.name;
      if ("icon" in data)
        this.icon = data.icon;
      if ("unavailable" in data) {
        this.available = !data.unavailable;
      } else {
        this.available ??= true;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      }
      if ("large" in data) {
        this.large = Boolean(data.large);
      }
      if ("premium_progress_bar_enabled" in data) {
        this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("afk_timeout" in data) {
        this.afkTimeout = data.afk_timeout;
      }
      if ("afk_channel_id" in data) {
        this.afkChannelId = data.afk_channel_id;
      }
      if ("system_channel_id" in data) {
        this.systemChannelId = data.system_channel_id;
      }
      if ("premium_tier" in data) {
        this.premiumTier = data.premium_tier;
      }
      if ("widget_enabled" in data) {
        this.widgetEnabled = data.widget_enabled;
      } else {
        this.widgetEnabled ??= null;
      }
      if ("widget_channel_id" in data) {
        this.widgetChannelId = data.widget_channel_id;
      } else {
        this.widgetChannelId ??= null;
      }
      if ("explicit_content_filter" in data) {
        this.explicitContentFilter = data.explicit_content_filter;
      }
      if ("mfa_level" in data) {
        this.mfaLevel = data.mfa_level;
      }
      if ("joined_at" in data) {
        this.joinedTimestamp = Date.parse(data.joined_at);
      }
      if ("default_message_notifications" in data) {
        this.defaultMessageNotifications = data.default_message_notifications;
      }
      if ("system_channel_flags" in data) {
        this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
      }
      if ("max_members" in data) {
        this.maximumMembers = data.max_members;
      } else {
        this.maximumMembers ??= null;
      }
      if ("max_presences" in data) {
        this.maximumPresences = data.max_presences;
      } else {
        this.maximumPresences ??= null;
      }
      if ("max_video_channel_users" in data) {
        this.maxVideoChannelUsers = data.max_video_channel_users;
      } else {
        this.maxVideoChannelUsers ??= null;
      }
      if ("max_stage_video_channel_users" in data) {
        this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
      } else {
        this.maxStageVideoChannelUsers ??= null;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      } else {
        this.approximateMemberCount ??= null;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else {
        this.approximatePresenceCount ??= null;
      }
      this.vanityURLUses ??= null;
      if ("rules_channel_id" in data) {
        this.rulesChannelId = data.rules_channel_id;
      }
      if ("public_updates_channel_id" in data) {
        this.publicUpdatesChannelId = data.public_updates_channel_id;
      }
      if ("preferred_locale" in data) {
        this.preferredLocale = data.preferred_locale;
      }
      if ("safety_alerts_channel_id" in data) {
        this.safetyAlertsChannelId = data.safety_alerts_channel_id;
      } else {
        this.safetyAlertsChannelId ??= null;
      }
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels._add(rawChannel, this);
        }
      }
      if (data.threads) {
        for (const rawThread of data.threads) {
          this.client.channels._add(rawThread, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles._add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members._add(guildUser);
      }
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences._add(Object.assign(presence, { guild: this }));
        }
      }
      if (data.stage_instances) {
        this.stageInstances.cache.clear();
        for (const stageInstance of data.stage_instances) {
          this.stageInstances._add(stageInstance);
        }
      }
      if (data.guild_scheduled_events) {
        this.scheduledEvents.cache.clear();
        for (const scheduledEvent of data.guild_scheduled_events) {
          this.scheduledEvents._add(scheduledEvent);
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates._add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis._add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
      if (!this.stickers) {
        this.stickers = new GuildStickerManager(this);
        if (data.stickers)
          for (const sticker of data.stickers)
            this.stickers._add(sticker);
      } else if (data.stickers) {
        this.client.actions.GuildStickersUpdate.handle({
          guild_id: this.id,
          stickers: data.stickers
        });
      }
      if ("incidents_data" in data) {
        this.incidentsData = data.incidents_data && _transformAPIIncidentsData(data.incidents_data);
      } else {
        this.incidentsData ??= null;
      }
      if (data.soundboard_sounds) {
        this.soundboardSounds.cache.clear();
        for (const soundboardSound of data.soundboard_sounds) {
          this.soundboardSounds._add(soundboardSound);
        }
      }
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "guild");
      }
      const member = await this.members.fetch({ ...options, user: this.ownerId });
      return member;
    }
    get afkChannel() {
      return this.client.channels.resolve(this.afkChannelId);
    }
    get systemChannel() {
      return this.client.channels.resolve(this.systemChannelId);
    }
    get widgetChannel() {
      return this.client.channels.resolve(this.widgetChannelId);
    }
    get rulesChannel() {
      return this.client.channels.resolve(this.rulesChannelId);
    }
    get publicUpdatesChannel() {
      return this.client.channels.resolve(this.publicUpdatesChannelId);
    }
    get safetyAlertsChannel() {
      return this.client.channels.resolve(this.safetyAlertsChannelId);
    }
    get maximumBitrate() {
      if (this.features.includes(GuildFeature.VIPRegions)) {
        return 384000;
      }
      switch (this.premiumTier) {
        case GuildPremiumTier.Tier1:
          return 128000;
        case GuildPremiumTier.Tier2:
          return 256000;
        case GuildPremiumTier.Tier3:
          return 384000;
        default:
          return 96000;
      }
    }
    async fetchIntegrations() {
      const data = await this.client.rest.get(Routes.guildIntegrations(this.id));
      return data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection);
    }
    async fetchTemplates() {
      const templates = await this.client.rest.get(Routes.guildTemplates(this.id));
      return templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection);
    }
    async fetchWelcomeScreen() {
      const data = await this.client.rest.get(Routes.guildWelcomeScreen(this.id));
      return new WelcomeScreen(this, data);
    }
    async createTemplate(name, description) {
      const data = await this.client.rest.post(Routes.guildTemplates(this.id), { body: { name, description } });
      return new GuildTemplate(this.client, data);
    }
    async fetchPreview() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      return new GuildPreview(this.client, data);
    }
    async fetchVanityData() {
      const data = await this.client.rest.get(Routes.guildVanityUrl(this.id));
      this.vanityURLCode = data.code;
      this.vanityURLUses = data.uses;
      return data;
    }
    async fetchWebhooks() {
      const apiHooks = await this.client.rest.get(Routes.guildWebhooks(this.id));
      const hooks = new Collection;
      for (const hook of apiHooks)
        hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    }
    fetchWidget() {
      return this.client.fetchGuildWidget(this.id);
    }
    async fetchWidgetSettings() {
      const data = await this.client.rest.get(Routes.guildWidgetSettings(this.id));
      this.widgetEnabled = data.enabled;
      this.widgetChannelId = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    widgetImageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
    async fetchAuditLogs({ before, after, limit, user, type } = {}) {
      const query = makeURLSearchParams({
        before: before?.id ?? before,
        after: after?.id ?? after,
        limit,
        action_type: type
      });
      if (user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
        query.set("user_id", userId);
      }
      const data = await this.client.rest.get(Routes.guildAuditLog(this.id), { query });
      return new GuildAuditLogs(this, data);
    }
    async fetchOnboarding() {
      const data = await this.client.rest.get(Routes.guildOnboarding(this.id));
      return new GuildOnboarding(this.client, data);
    }
    async edit({
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      afkChannel,
      afkTimeout,
      icon,
      owner,
      splash,
      discoverySplash,
      banner,
      systemChannel,
      systemChannelFlags,
      rulesChannel,
      publicUpdatesChannel,
      preferredLocale,
      premiumProgressBarEnabled,
      safetyAlertsChannel,
      ...options
    }) {
      const data = await this.client.rest.patch(Routes.guild(this.id), {
        body: {
          ...options,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
          afk_timeout: afkTimeout,
          icon: icon && await resolveImage(icon),
          owner_id: owner && this.client.users.resolveId(owner),
          splash: splash && await resolveImage(splash),
          discovery_splash: discoverySplash && await resolveImage(discoverySplash),
          banner: banner && await resolveImage(banner),
          system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),
          rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
          public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
          preferred_locale: preferredLocale,
          premium_progress_bar_enabled: premiumProgressBarEnabled,
          safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
        },
        reason: options.reason
      });
      return this.client.actions.GuildUpdate.handle(data).updated;
    }
    async editOnboarding(options) {
      const newData = await this.client.rest.put(Routes.guildOnboarding(this.id), {
        body: {
          prompts: options.prompts?.map((prompt) => ({
            id: prompt.id ?? DiscordSnowflake.generate().toString(),
            title: prompt.title,
            single_select: prompt.singleSelect,
            required: prompt.required,
            in_onboarding: prompt.inOnboarding,
            type: prompt.type,
            options: prompt.options.map((option) => {
              const emoji = resolvePartialEmoji(option.emoji);
              return {
                id: option.id,
                channel_ids: option.channels?.map((channel) => this.channels.resolveId(channel)),
                role_ids: option.roles?.map((role) => this.roles.resolveId(role)),
                title: option.title,
                description: option.description,
                emoji_animated: emoji?.animated,
                emoji_id: emoji?.id,
                emoji_name: emoji?.name
              };
            })
          })),
          default_channel_ids: options.defaultChannels?.map((channel) => this.channels.resolveId(channel)),
          enabled: options.enabled,
          mode: options.mode
        },
        reason: options.reason
      });
      return new GuildOnboarding(this.client, newData);
    }
    async editWelcomeScreen(options) {
      const { enabled, description, welcomeChannels } = options;
      const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
        const emoji = this.emojis.resolve(welcomeChannelData.emoji);
        return {
          emoji_id: emoji?.id,
          emoji_name: emoji?.name ?? welcomeChannelData.emoji,
          channel_id: this.channels.resolveId(welcomeChannelData.channel),
          description: welcomeChannelData.description
        };
      });
      const patchData = await this.client.rest.patch(Routes.guildWelcomeScreen(this.id), {
        body: {
          welcome_channels,
          description,
          enabled
        }
      });
      return new WelcomeScreen(this, patchData);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({ explicitContentFilter, reason });
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({ defaultMessageNotifications, reason });
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({ systemChannelFlags, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({ verificationLevel, reason });
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({ afkChannel, reason });
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({ systemChannel, reason });
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({ afkTimeout, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setOwner(owner, reason) {
      return this.edit({ owner, reason });
    }
    setSplash(splash, reason) {
      return this.edit({ splash, reason });
    }
    setDiscoverySplash(discoverySplash, reason) {
      return this.edit({ discoverySplash, reason });
    }
    setBanner(banner, reason) {
      return this.edit({ banner, reason });
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({ rulesChannel, reason });
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({ publicUpdatesChannel, reason });
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({ preferredLocale, reason });
    }
    setPremiumProgressBarEnabled(enabled = true, reason) {
      return this.edit({ premiumProgressBarEnabled: enabled, reason });
    }
    setSafetyAlertsChannel(safetyAlertsChannel, reason) {
      return this.edit({ safetyAlertsChannel, reason });
    }
    async setWidgetSettings(settings, reason) {
      await this.client.rest.patch(Routes.guildWidgetSettings(this.id), {
        body: {
          enabled: settings.enabled,
          channel_id: this.channels.resolveId(settings.channel)
        },
        reason
      });
      return this;
    }
    async setMFALevel(level, reason) {
      await this.client.rest.post(Routes.guildMFA(this.id), {
        body: {
          level
        },
        reason
      });
      return this;
    }
    async leave() {
      if (this.ownerId === this.client.user.id)
        throw new DiscordjsError(ErrorCodes.GuildOwned);
      await this.client.rest.delete(Routes.userGuild(this.id));
      return this;
    }
    async delete() {
      await this.client.rest.delete(Routes.guild(this.id));
      return this;
    }
    async disableInvites(disabled = true) {
      const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
      if (disabled)
        features.push(GuildFeature.InvitesDisabled);
      return this.edit({ features });
    }
    async setIncidentActions(incidentActions) {
      return this.client.guilds.setIncidentActions(this.id, incidentActions);
    }
    equals(guild) {
      return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    get voiceAdapterCreator() {
      return (methods) => {
        this.client.voice.adapters.set(this.id, methods);
        return {
          sendPayload: (data) => {
            if (this.shard.status !== Status.Ready)
              return false;
            this.shard.send(data);
            return true;
          },
          destroy: () => {
            this.client.voice.adapters.delete(this.id);
          }
        };
      };
    }
    _sortedRoles() {
      return discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const channelIsCategory = channel.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(channel.type);
      return discordSort(this.channels.cache.filter(({ parentId, type }) => types.includes(type) && (channelIsCategory || parentId === channel.parentId)));
    }
  }
  exports.Guild = Guild;
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();
  var PermissionsBitField = require_PermissionsBitField();

  class OAuth2Guild extends BaseGuild {
    constructor(client, data) {
      super(client, data);
      this.owner = data.owner;
      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
    }
  }
  module.exports = OAuth2Guild;
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GatewayOpcodes, Routes, RouteBases } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsError } = require_errors2();
  var ShardClientUtil = require_ShardClientUtil();
  var { Guild } = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var { GuildMember } = require_GuildMember();
  var Invite = require_Invite();
  var OAuth2Guild = require_OAuth2Guild();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();
  var PermissionsBitField = require_PermissionsBitField();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class GuildManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Guild, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveId(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolveId(guild.guild.id);
      }
      return super.resolveId(guild);
    }
    async create({
      name,
      icon = null,
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      roles = [],
      channels = [],
      afkChannelId,
      afkTimeout,
      systemChannelId,
      systemChannelFlags
    }) {
      const data = await this.client.rest.post(Routes.guilds(), {
        body: {
          name,
          icon: icon && await resolveImage(icon),
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles: roles.map(({ color, permissions, ...options }) => ({
            ...options,
            color: color && resolveColor(color),
            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()
          })),
          channels: channels.map(({
            parentId,
            userLimit,
            rtcRegion,
            videoQualityMode,
            permissionOverwrites,
            rateLimitPerUser,
            ...options
          }) => ({
            ...options,
            parent_id: parentId,
            user_limit: userLimit,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
              ...permissionOverwriteOptions,
              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),
              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()
            })),
            rate_limit_per_user: rateLimitPerUser
          })),
          afk_channel_id: afkChannelId,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelId,
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)
        }
      });
      return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.once(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildCreate, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds._add(data));
        }, 1e4).unref();
      });
    }
    async fetch(options = {}) {
      const id = this.resolveId(options) ?? this.resolveId(options.guild);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guild(id), {
          query: makeURLSearchParams({ with_counts: options.withCounts ?? true })
        });
        data2.shardId = ShardClientUtil.shardIdForGuildId(id, this.client.options.shardCount);
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });
      return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection);
    }
    async fetchSoundboardSounds({ guildIds, time = 1e4 }) {
      const shardCount = this.client.options.shardCount;
      const shardIds = new Map;
      for (const guildId of guildIds) {
        const shardId = ShardClientUtil.shardIdForGuildId(guildId, shardCount);
        const group = shardIds.get(shardId);
        if (group)
          group.push(guildId);
        else
          shardIds.set(shardId, [guildId]);
      }
      for (const [shardId, shardGuildIds] of shardIds) {
        this.client.ws.shards.get(shardId).send({
          op: GatewayOpcodes.RequestSoundboardSounds,
          d: {
            guild_ids: shardGuildIds
          }
        });
      }
      return new Promise((resolve, reject) => {
        const remainingGuildIds = new Set(guildIds);
        const fetchedSoundboardSounds = new Collection;
        const handler = (soundboardSounds, guild) => {
          timeout.refresh();
          if (!remainingGuildIds.has(guild.id))
            return;
          fetchedSoundboardSounds.set(guild.id, soundboardSounds);
          remainingGuildIds.delete(guild.id);
          if (remainingGuildIds.size === 0) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.SoundboardSounds, handler);
            this.client.decrementMaxListeners();
            resolve(fetchedSoundboardSounds);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.SoundboardSounds, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildSoundboardSoundsTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.SoundboardSounds, handler);
      });
    }
    async setIncidentActions(guild, { invitesDisabledUntil, dmsDisabledUntil }) {
      const guildId = this.resolveId(guild);
      const data = await this.client.rest.put(Routes.guildIncidentActions(guildId), {
        body: {
          invites_disabled_until: invitesDisabledUntil && new Date(invitesDisabledUntil).toISOString(),
          dms_disabled_until: dmsDisabledUntil && new Date(dmsDisabledUntil).toISOString()
        }
      });
      const parsedData = _transformAPIIncidentsData(data);
      const resolvedGuild = this.resolve(guild);
      if (resolvedGuild) {
        resolvedGuild.incidentsData = parsedData;
      }
      return parsedData;
    }
    widgetImageURL(guild, style) {
      const urlSearchParams = String(makeURLSearchParams({ style }));
      return `${RouteBases.api}${Routes.guildWidgetImage(this.resolveId(guild))}${urlSearchParams ? `?${urlSearchParams}` : ""}`;
    }
  }
  module.exports = GuildManager;
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildMember } = require_GuildMember();
  var { Message } = require_Message();
  var ThreadMember = require_ThreadMember();
  var User = require_User();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class UserManager extends CachedManager {
    constructor(client, iterable) {
      super(client, User, iterable);
    }
    dmChannel(userId) {
      return this.client.channels.cache.find((channel) => channel.type === ChannelType.DM && channel.recipientId === userId) ?? null;
    }
    async createDM(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const dmChannel = this.dmChannel(id);
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });
      return this.client.channels._add(data, null, { cache });
    }
    async deleteDM(user) {
      const id = this.resolveId(user);
      const dmChannel = this.dmChannel(id);
      if (!dmChannel)
        throw new DiscordjsError(ErrorCodes.UserNoDMChannel);
      await this.client.rest.delete(Routes.channel(dmChannel.id));
      this.client.channels._remove(dmChannel.id);
      return dmChannel;
    }
    async fetch(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.user(id));
      return this._add(data, cache);
    }
    async fetchFlags(user, options) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return (await this.fetch(user, options)).flags;
    }
    async send(user, options) {
      return (await this.createDM(user)).send(options);
    }
    resolve(user) {
      if (user instanceof GuildMember || user instanceof ThreadMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveId(user) {
      if (user instanceof ThreadMember)
        return user.id;
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveId(user);
    }
  }
  module.exports = UserManager;
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports, module) => {
  var { GatewayOpcodes, ActivityType } = require_v106();
  var { Presence } = require_Presence();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ClientPresence extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
    }
    set(presence) {
      const packet = this._parse(presence);
      this._patch(packet);
      if (presence.shardId === undefined) {
        this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      } else if (Array.isArray(presence.shardId)) {
        for (const shardId of presence.shardId) {
          this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
      } else {
        this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      }
      return this;
    }
    _parse({ status, since, afk, activities }) {
      const data = {
        activities: [],
        afk: typeof afk === "boolean" ? afk : false,
        since: typeof since === "number" && !Number.isNaN(since) ? since : null,
        status: status ?? this.status
      };
      if (activities?.length) {
        for (const [i, activity] of activities.entries()) {
          if (typeof activity.name !== "string") {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, `activities[${i}].name`, "string");
          }
          activity.type ??= ActivityType.Playing;
          if (activity.type === ActivityType.Custom && !activity.state) {
            activity.state = activity.name;
            activity.name = "Custom Status";
          }
          data.activities.push({
            type: activity.type,
            name: activity.name,
            state: activity.state,
            url: activity.url
          });
        }
      } else if (!activities && (status || afk || since) && this.activities.length) {
        data.activities.push(...this.activities.map((activity) => ({
          name: activity.name,
          state: activity.state ?? undefined,
          type: activity.type,
          url: activity.url ?? undefined
        })));
      }
      return data;
    }
  }
  module.exports = ClientPresence;
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Sticker } = require_Sticker();

  class StickerPack extends Base {
    constructor(client, pack) {
      super(client);
      this.id = pack.id;
      this.stickers = new Collection(pack.stickers.map((sticker) => [sticker.id, new Sticker(client, sticker)]));
      this.name = pack.name;
      this.skuId = pack.sku_id;
      this.coverStickerId = pack.cover_sticker_id ?? null;
      this.description = pack.description;
      this.bannerId = pack.banner_asset_id ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get coverSticker() {
      return this.coverStickerId && this.stickers.get(this.coverStickerId);
    }
    bannerURL(options = {}) {
      return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
    }
  }
  module.exports = StickerPack;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class VoiceRegion {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = VoiceRegion;
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class WidgetMember extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.status = data.status;
      this.deaf = data.deaf ?? null;
      this.mute = data.mute ?? null;
      this.selfDeaf = data.self_deaf ?? null;
      this.selfMute = data.self_mute ?? null;
      this.suppress = data.suppress ?? null;
      this.channelId = data.channel_id ?? null;
      this.avatarURL = data.avatar_url;
      this.activity = data.activity ?? null;
    }
  }
  module.exports = WidgetMember;
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var Base = require_Base();
  var WidgetMember = require_WidgetMember();

  class Widget extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("instant_invite" in data) {
        this.instantInvite = data.instant_invite;
      }
      this.channels = new Collection;
      for (const channel of data.channels) {
        this.channels.set(channel.id, channel);
      }
      this.members = new Collection;
      for (const member of data.members) {
        this.members.set(member.id, new WidgetMember(this.client, member));
      }
      if ("presence_count" in data) {
        this.presenceCount = data.presence_count;
      }
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildWidgetJSON(this.id));
      this._patch(data);
      return this;
    }
    imageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
  }
  module.exports = Widget;
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS((exports, module) => {
  var { GatewayIntentBits } = require_v106();
  var BitField = require_BitField();

  class IntentsBitField extends BitField {
    static Flags = GatewayIntentBits;
  }
  module.exports = IntentsBitField;
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS((exports, module) => {
  var { setInterval: setInterval2, clearInterval: clearInterval2 } = __require("node:timers");
  var { ThreadChannelTypes, SweeperKeys } = require_Constants();
  var Events = require_Events();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class Sweepers {
    constructor(client, options) {
      Object.defineProperty(this, "client", { value: client });
      this.options = options;
      this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
      for (const key of SweeperKeys) {
        if (!(key in options))
          continue;
        this._validateProperties(key);
        const clonedOptions = { ...this.options[key] };
        if (!("filter" in clonedOptions)) {
          switch (key) {
            case "invites":
              clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
              break;
            case "messages":
              clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
              break;
            case "threads":
              clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
          }
        }
        this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
      }
    }
    sweepApplicationCommands(filter) {
      const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
      const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;
      this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);
      return guildCommands + globalCommands;
    }
    sweepAutoModerationRules(filter) {
      return this._sweepGuildDirectProp("autoModerationRules", filter).items;
    }
    sweepBans(filter) {
      return this._sweepGuildDirectProp("bans", filter).items;
    }
    sweepEmojis(filter) {
      return this._sweepGuildDirectProp("emojis", filter).items;
    }
    sweepEntitlements(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const entitlements = this.client.application.entitlements.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${entitlements} entitlements.`);
      return entitlements;
    }
    sweepInvites(filter) {
      return this._sweepGuildDirectProp("invites", filter).items;
    }
    sweepGuildMembers(filter) {
      return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
    }
    sweepMessages(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        messages += channel.messages.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
      return messages;
    }
    sweepPresences(filter) {
      return this._sweepGuildDirectProp("presences", filter).items;
    }
    sweepReactions(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      let reactions = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        for (const message of channel.messages.cache.values()) {
          messages++;
          reactions += message.reactions.cache.sweep(filter);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);
      return reactions;
    }
    sweepStageInstances(filter) {
      return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
    }
    sweepStickers(filter) {
      return this._sweepGuildDirectProp("stickers", filter).items;
    }
    sweepThreadMembers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      let members = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!ThreadChannelTypes.includes(channel.type))
          continue;
        threads++;
        members += channel.members.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
      return members;
    }
    sweepThreads(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      for (const [key, val] of this.client.channels.cache.entries()) {
        if (!ThreadChannelTypes.includes(val.type))
          continue;
        if (filter(val, key, this.client.channels.cache)) {
          threads++;
          this.client.channels._remove(key);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);
      return threads;
    }
    sweepUsers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const users = this.client.users.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${users} users.`);
      return users;
    }
    sweepVoiceStates(filter) {
      return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
    }
    destroy() {
      for (const key of SweeperKeys) {
        if (this.intervals[key])
          clearInterval2(this.intervals[key]);
      }
    }
    static filterByLifetime({
      lifetime = 14400,
      getComparisonTimestamp = (e) => e?.createdTimestamp,
      excludeFromSweep = () => false
    } = {}) {
      if (typeof lifetime !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "lifetime", "number");
      }
      if (typeof getComparisonTimestamp !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "getComparisonTimestamp", "function");
      }
      if (typeof excludeFromSweep !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "excludeFromSweep", "function");
      }
      return () => {
        if (lifetime <= 0)
          return null;
        const lifetimeMs = lifetime * 1000;
        const now = Date.now();
        return (entry, key, coll) => {
          if (excludeFromSweep(entry, key, coll)) {
            return false;
          }
          const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
          if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
            return false;
          return now - comparisonTimestamp > lifetimeMs;
        };
      };
    }
    static archivedThreadSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (e) => e.archiveTimestamp,
        excludeFromSweep: (e) => !e.archived
      });
    }
    static expiredInviteSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (i) => i.expiresTimestamp
      });
    }
    static outdatedMessageSweepFilter(lifetime = 3600) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
      });
    }
    _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let guilds = 0;
      let items = 0;
      for (const guild of this.client.guilds.cache.values()) {
        if (!guild.available)
          continue;
        const { cache } = guild[key];
        guilds++;
        items += cache.sweep(filter);
      }
      if (emit) {
        this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
      }
      return { guilds, items };
    }
    _validateProperties(key) {
      const props = this.options[key];
      if (typeof props !== "object") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, "object", true);
      }
      if (typeof props.interval !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, "number");
      }
      if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
        if (typeof props.lifetime !== "number") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, "number");
        }
        return;
      }
      if (typeof props.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, "function");
      }
    }
    _initInterval(intervalKey, sweepKey, opts) {
      if (opts.interval <= 0 || opts.interval === Infinity)
        return;
      this.intervals[intervalKey] = setInterval2(() => {
        const sweepFn = opts.filter();
        if (sweepFn === null)
          return;
        if (typeof sweepFn !== "function")
          throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
        this[sweepKey](sweepFn);
      }, opts.interval * 1000).unref();
    }
  }
  module.exports = Sweepers;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { OAuth2Scopes, Routes } = require_v106();
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var ChannelManager = require_ChannelManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientPresence = require_ClientPresence();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var { SoundboardSound } = require_SoundboardSound();
  var { Sticker } = require_Sticker();
  var StickerPack = require_StickerPack();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Widget = require_Widget();
  var { resolveInviteCode, resolveGuildTemplateCode } = require_DataResolver();
  var Events = require_Events();
  var IntentsBitField = require_IntentsBitField();
  var Options = require_Options();
  var PermissionsBitField = require_PermissionsBitField();
  var Status = require_Status();
  var Sweepers = require_Sweepers();
  var deprecationEmittedForPremiumStickerPacks = false;

  class Client extends BaseClient {
    constructor(options) {
      super(options);
      const data = __require("node:worker_threads").workerData ?? process2.env;
      const defaults = Options.createDefault();
      if (this.options.shards === defaults.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === defaults.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = new ClientVoiceManager(this);
      this.shard = process2.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process2.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      this.sweepers = new Sweepers(this, this.options.sweepers);
      this.presence = new ClientPresence(this, this.options.presence);
      Object.defineProperty(this, "token", { writable: true });
      if (!this.token && "DISCORD_TOKEN" in process2.env) {
        this.token = process2.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.application = null;
      this.readyTimestamp = null;
    }
    get emojis() {
      const emojis = new BaseGuildEmojiManager(this);
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyAt() {
      return this.readyTimestamp && new Date(this.readyTimestamp);
    }
    get uptime() {
      return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.rest.setToken(token);
      this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
      if (this.options.presence) {
        this.options.ws.presence = this.presence._parse(this.options.presence);
      }
      this.emit(Events.Debug, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        await this.destroy();
        throw error;
      }
    }
    isReady() {
      return !this.ws.destroyed && this.ws.status === Status.Ready;
    }
    async destroy() {
      super.destroy();
      this.sweepers.destroy();
      await this.ws.destroy();
      this.token = null;
      this.rest.setToken(null);
    }
    async fetchInvite(invite, options) {
      const code = resolveInviteCode(invite);
      const query = makeURLSearchParams({
        with_counts: true,
        guild_scheduled_event_id: options?.guildScheduledEventId
      });
      const data = await this.rest.get(Routes.invite(code), { query });
      return new Invite(this, data);
    }
    async fetchGuildTemplate(template) {
      const code = resolveGuildTemplateCode(template);
      const data = await this.rest.get(Routes.template(code));
      return new GuildTemplate(this, data);
    }
    async fetchWebhook(id, token) {
      const data = await this.rest.get(Routes.webhook(id, token), { auth: token === undefined });
      return new Webhook(this, { token, ...data });
    }
    async fetchVoiceRegions() {
      const apiRegions = await this.rest.get(Routes.voiceRegions());
      const regions = new Collection;
      for (const region of apiRegions)
        regions.set(region.id, new VoiceRegion(region));
      return regions;
    }
    async fetchSticker(id) {
      const data = await this.rest.get(Routes.sticker(id));
      return new Sticker(this, data);
    }
    async fetchStickerPacks({ packId } = {}) {
      if (packId) {
        const data2 = await this.rest.get(Routes.stickerPack(packId));
        return new StickerPack(this, data2);
      }
      const data = await this.rest.get(Routes.stickerPacks());
      return new Collection(data.sticker_packs.map((stickerPack) => [stickerPack.id, new StickerPack(this, stickerPack)]));
    }
    fetchPremiumStickerPacks() {
      if (!deprecationEmittedForPremiumStickerPacks) {
        process2.emitWarning("The Client#fetchPremiumStickerPacks() method is deprecated. Use Client#fetchStickerPacks() instead.", "DeprecationWarning");
        deprecationEmittedForPremiumStickerPacks = true;
      }
      return this.fetchStickerPacks();
    }
    async fetchDefaultSoundboardSounds() {
      const data = await this.rest.get(Routes.soundboardDefaultSounds());
      return new Collection(data.map((sound) => [sound.sound_id, new SoundboardSound(this, sound)]));
    }
    async fetchGuildPreview(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildPreview(id));
      return new GuildPreview(this, data);
    }
    async fetchGuildWidget(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildWidgetJSON(id));
      return new Widget(this, data);
    }
    generateInvite(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      if (!this.application)
        throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
      const { scopes } = options;
      if (scopes === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!Array.isArray(scopes)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
      }
      if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
      }
      const validScopes = Object.values(OAuth2Scopes);
      const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
      if (invalidScope) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
      }
      const query = makeURLSearchParams({
        client_id: this.application.id,
        scope: scopes.join(" "),
        disable_guild_select: options.disableGuildSelect
      });
      if (options.permissions) {
        const permissions = PermissionsBitField.resolve(options.permissions);
        if (permissions)
          query.set("permissions", permissions.toString());
      }
      if (options.guild) {
        const guildId = this.guilds.resolveId(options.guild);
        if (!guildId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
        query.set("guild_id", guildId);
      }
      return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        actions: false,
        presence: false
      });
    }
    get _censoredToken() {
      if (!this.token)
        return null;
      return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (options.intents === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
      } else {
        options.intents = new IntentsBitField(options.intents).freeze();
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
      if (typeof options.makeCache !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
      }
      if (typeof options.sweepers !== "object" || options.sweepers === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
      }
      if (!Array.isArray(options.partials)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
      }
      if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
      }
      if (typeof options.failIfNotExists !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
      }
      if (typeof options.enforceNonce !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "enforceNonce", "a boolean");
      }
      if (typeof options.allowedMentions !== "object" && options.allowedMentions !== undefined || options.allowedMentions === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
      }
      if (typeof options.presence !== "object" || options.presence === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
      }
      if (typeof options.ws !== "object" || options.ws === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
      }
      if (typeof options.rest !== "object" || options.rest === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
      }
      if (typeof options.jsonTransformer !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
      }
    }
  }
  module.exports = Client;
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Death: "death",
    Disconnect: "disconnect",
    Error: "error",
    Message: "message",
    Ready: "ready",
    Reconnecting: "reconnecting",
    Resume: "resume",
    Spawn: "spawn"
  };
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { SHARE_ENV } = __require("node:worker_threads");
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ShardEvents = require_ShardEvents();
  var { makeError, makePlainError } = require_Util();
  var childProcess = null;
  var Worker = null;

  class Shard extends EventEmitter {
    constructor(manager, id) {
      super();
      switch (manager.mode) {
        case "process":
          childProcess = __require("node:child_process");
          break;
        case "worker":
          Worker = __require("node:worker_threads").Worker;
          break;
      }
      this.manager = manager;
      this.id = id;
      this.silent = manager.silent;
      this.args = manager.shardArgs ?? [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process2.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map;
      this._fetches = new Map;
      this._exitListener = null;
    }
    async spawn(timeout = 30000) {
      if (this.process)
        throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);
      if (this.worker)
        throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);
      this._exitListener = this._handleExit.bind(this, undefined, timeout);
      switch (this.manager.mode) {
        case "process":
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv,
            silent: this.silent
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
        case "worker":
          this.worker = new Worker(path.resolve(this.manager.file), {
            workerData: this.env,
            env: SHARE_ENV,
            execArgv: this.execArgv,
            argv: this.args
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
      }
      this._evals.clear();
      this._fetches.clear();
      const child = this.process ?? this.worker;
      this.emit(ShardEvents.Spawn, child);
      if (timeout === -1 || timeout === Infinity)
        return child;
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout2(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve(child);
        };
        const onDisconnect = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));
        };
        const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn({ delay = 500, timeout = 30000 } = {}) {
      this.kill();
      if (delay > 0)
        await sleep(delay);
      return this.spawn(timeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    async fetchClientValue(prop) {
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _fetchProp: prop }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    async eval(script2, context) {
      const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._evals.has(_eval))
        return this._evals.get(_eval);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._eval !== _eval)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _eval }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          reject(err);
        });
      });
      this._evals.set(_eval, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit(ShardEvents.Ready);
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit(ShardEvents.Disconnect);
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit(ShardEvents.Reconnecting);
          return;
        }
        if (message._resume) {
          this.ready = true;
          this.emit(ShardEvents.Resume);
          return;
        }
        if (message._sFetchProp) {
          const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sEval) {
          const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
          this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sRespawnAll) {
          const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
          this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {});
          return;
        }
      }
      this.emit(ShardEvents.Message, message);
    }
    _handleExit(respawn = this.manager.respawn, timeout) {
      this.emit(ShardEvents.Death, this.process ?? this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var fs = __require("node:fs");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { Collection } = require_dist6();
  var Shard = require_Shard();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var { fetchRecommendedShardCount } = require_Util();

  class ShardingManager extends EventEmitter {
    constructor(file, options) {
      super();
      const _options = {
        totalShards: "auto",
        mode: "process",
        respawn: true,
        silent: false,
        shardArgs: [],
        execArgv: [],
        token: process2.env.DISCORD_TOKEN,
        ...options
      };
      this.file = file;
      if (!file)
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process2.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "a file");
      this.shardList = _options.shardList ?? "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "shardList", "at least 1 id.");
        }
        if (this.shardList.some((shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = _options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (this.totalShards < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        }
        if (!Number.isInteger(this.totalShards)) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      this.mode = _options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
      }
      this.respawn = _options.respawn;
      this.silent = _options.silent;
      this.shardArgs = _options.shardArgs;
      this.execArgv = _options.execArgv;
      this.token = _options.token?.replace(/^Bot\s*/i, "") ?? null;
      this.shards = new Collection;
      process2.env.SHARDING_MANAGER = true;
      process2.env.SHARDING_MANAGER_MODE = this.mode;
      process2.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {
      if (amount === "auto") {
        amount = await fetchRecommendedShardCount(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardId) => shardId >= amount)) {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "bigger than the highest shardId in the shardList option.");
      }
      for (const shardId of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardId);
        promises.push(shard.spawn(timeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(sleep(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    async broadcastEval(script2, options = {}) {
      if (typeof script2 !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast);
      }
      return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    async _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        throw new DiscordjsError(ErrorCodes.ShardingNoShards);
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        throw new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard);
      }
      if (this.shards.size !== this.shardList.length) {
        throw new DiscordjsError(ErrorCodes.ShardingInProcess);
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn({ delay: respawnDelay, timeout })];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(sleep(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  }
  module.exports = ShardingManager;
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var {
    blockQuote,
    bold,
    channelMention,
    codeBlock,
    formatEmoji,
    hideLinkEmbed,
    hyperlink,
    inlineCode,
    italic,
    quote,
    roleMention,
    spoiler,
    strikethrough,
    time,
    TimestampStyles,
    underscore,
    userMention
  } = require_dist7();

  class Formatters extends null {
    static blockQuote = deprecate(blockQuote, "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead.");
    static bold = deprecate(bold, "Formatters.bold() is deprecated. Import this method directly from discord.js instead.");
    static channelMention = deprecate(channelMention, "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead.");
    static codeBlock = deprecate(codeBlock, "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead.");
    static formatEmoji = deprecate(formatEmoji, "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead.");
    static hideLinkEmbed = deprecate(hideLinkEmbed, "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead.");
    static hyperlink = deprecate(hyperlink, "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead.");
    static inlineCode = deprecate(inlineCode, "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead.");
    static italic = deprecate(italic, "Formatters.italic() is deprecated. Import this method directly from discord.js instead.");
    static quote = deprecate(quote, "Formatters.quote() is deprecated. Import this method directly from discord.js instead.");
    static roleMention = deprecate(roleMention, "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead.");
    static spoiler = deprecate(spoiler, "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead.");
    static strikethrough = deprecate(strikethrough, "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead.");
    static time = deprecate(time, "Formatters.time() is deprecated. Import this method directly from discord.js instead.");
    static TimestampStyles = TimestampStyles;
    static underscore = deprecate(underscore, "Formatters.underscore() is deprecated. Import this method directly from discord.js instead.");
    static userMention = deprecate(userMention, "Formatters.userMention() is deprecated. Import this method directly from discord.js instead.");
  }
  module.exports = Formatters;
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS((exports, module) => {
  var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolveColor } = require_Util();

  class EmbedBuilder extends BuildersEmbed {
    constructor(data) {
      super(toSnakeCase(data));
    }
    setColor(color) {
      return super.setColor(color && resolveColor(color));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
    get length() {
      return embedLength(this.data);
    }
  }
  module.exports = EmbedBuilder;
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS((exports, module) => {
  var { basename, flatten } = require_Util();

  class AttachmentBuilder {
    constructor(attachment, data = {}) {
      this.attachment = attachment;
      this.name = data.name;
      this.description = data.description;
    }
    setDescription(description) {
      this.description = description;
      return this;
    }
    setFile(attachment) {
      this.attachment = attachment;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    setSpoiler(spoiler = true) {
      if (spoiler === this.spoiler)
        return this;
      if (!spoiler) {
        while (this.spoiler) {
          this.name = this.name.slice("SPOILER_".length);
        }
        return this;
      }
      this.name = `SPOILER_${this.name}`;
      return this;
    }
    get spoiler() {
      return basename(this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
    static from(other) {
      return new AttachmentBuilder(other.attachment, {
        name: other.name,
        description: other.description
      });
    }
  }
  module.exports = AttachmentBuilder;
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS((exports, module) => {
  var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ModalBuilder extends BuildersModal {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => component instanceof ComponentBuilder ? component : toSnakeCase(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ModalBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var deprecationEmitted = false;

  class SelectMenuBuilder2 extends StringSelectMenuBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuBuilder2;
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var deprecationEmitted = false;

  class SelectMenuComponent extends StringSelectMenuComponent {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuComponent;
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var deprecationEmitted = false;

  class SelectMenuInteraction extends StringSelectMenuInteraction {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS((exports, module) => {
  var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuOptionBuilder extends BuildersSelectMenuOption {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = StringSelectMenuOptionBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  var deprecationEmitted = false;

  class SelectMenuOptionBuilder2 extends StringSelectMenuOptionBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuOptionBuilder2;
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS((exports) => {
  var { polyfillDispose } = require_dist();
  var { __exportStar } = require_tslib();
  polyfillDispose();
  exports.BaseClient = require_BaseClient();
  exports.Client = require_Client();
  exports.Shard = require_Shard();
  exports.ShardClientUtil = require_ShardClientUtil();
  exports.ShardingManager = require_ShardingManager();
  exports.WebhookClient = require_WebhookClient();
  exports.DiscordjsError = require_DJSError().DiscordjsError;
  exports.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
  exports.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
  exports.DiscordjsErrorCodes = require_ErrorCodes();
  exports.ActivityFlagsBitField = require_ActivityFlagsBitField();
  exports.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  exports.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  exports.BaseManager = require_BaseManager();
  exports.BitField = require_BitField();
  exports.ChannelFlagsBitField = require_ChannelFlagsBitField();
  exports.Collection = require_dist6().Collection;
  exports.Constants = require_Constants();
  exports.Colors = require_Colors();
  exports.Events = require_Events();
  exports.Formatters = require_Formatters();
  exports.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
  exports.IntentsBitField = require_IntentsBitField();
  exports.LimitedCollection = require_LimitedCollection();
  exports.MessageFlagsBitField = require_MessageFlagsBitField();
  exports.Options = require_Options();
  exports.Partials = require_Partials();
  exports.PermissionsBitField = require_PermissionsBitField();
  exports.RoleFlagsBitField = require_RoleFlagsBitField();
  exports.ShardEvents = require_ShardEvents();
  exports.SKUFlagsBitField = require_SKUFlagsBitField().SKUFlagsBitField;
  exports.Status = require_Status();
  exports.SnowflakeUtil = require_cjs().DiscordSnowflake;
  exports.Sweepers = require_Sweepers();
  exports.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  exports.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  exports.UserFlagsBitField = require_UserFlagsBitField();
  __exportStar(require_Util(), exports);
  exports.WebSocketShardEvents = require_WebSocketShardEvents();
  exports.version = require_package().version;
  exports.ApplicationCommandManager = require_ApplicationCommandManager();
  exports.ApplicationEmojiManager = require_ApplicationEmojiManager();
  exports.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  exports.AutoModerationRuleManager = require_AutoModerationRuleManager();
  exports.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  exports.CachedManager = require_CachedManager();
  exports.ChannelManager = require_ChannelManager();
  exports.ClientVoiceManager = require_ClientVoiceManager();
  exports.DataManager = require_DataManager();
  exports.DMMessageManager = require_DMMessageManager();
  exports.EntitlementManager = require_EntitlementManager().EntitlementManager;
  exports.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  exports.GuildBanManager = require_GuildBanManager();
  exports.GuildChannelManager = require_GuildChannelManager();
  exports.GuildEmojiManager = require_GuildEmojiManager();
  exports.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  exports.GuildForumThreadManager = require_GuildForumThreadManager();
  exports.GuildInviteManager = require_GuildInviteManager();
  exports.GuildManager = require_GuildManager();
  exports.GuildMemberManager = require_GuildMemberManager();
  exports.GuildMemberRoleManager = require_GuildMemberRoleManager();
  exports.GuildMessageManager = require_GuildMessageManager();
  exports.GuildScheduledEventManager = require_GuildScheduledEventManager();
  exports.GuildSoundboardSoundManager = require_GuildSoundboardSoundManager().GuildSoundboardSoundManager;
  exports.GuildStickerManager = require_GuildStickerManager();
  exports.GuildTextThreadManager = require_GuildTextThreadManager();
  exports.MessageManager = require_MessageManager();
  exports.PermissionOverwriteManager = require_PermissionOverwriteManager();
  exports.PresenceManager = require_PresenceManager();
  exports.ReactionManager = require_ReactionManager();
  exports.ReactionUserManager = require_ReactionUserManager();
  exports.RoleManager = require_RoleManager();
  exports.StageInstanceManager = require_StageInstanceManager();
  exports.SubscriptionManager = require_SubscriptionManager().SubscriptionManager;
  exports.ThreadManager = require_ThreadManager();
  exports.ThreadMemberManager = require_ThreadMemberManager();
  exports.UserManager = require_UserManager();
  exports.VoiceStateManager = require_VoiceStateManager();
  exports.WebSocketManager = require_WebSocketManager();
  exports.WebSocketShard = require_WebSocketShard();
  exports.ActionRow = require_ActionRow();
  exports.ActionRowBuilder = require_ActionRowBuilder();
  exports.Activity = require_Presence().Activity;
  exports.AnonymousGuild = require_AnonymousGuild();
  exports.Application = require_Application();
  exports.ApplicationCommand = require_ApplicationCommand();
  exports.ApplicationEmoji = require_ApplicationEmoji();
  exports.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
  exports.AutocompleteInteraction = require_AutocompleteInteraction();
  exports.AutoModerationActionExecution = require_AutoModerationActionExecution();
  exports.AutoModerationRule = require_AutoModerationRule();
  exports.Base = require_Base();
  exports.BaseGuild = require_BaseGuild();
  exports.BaseGuildEmoji = require_BaseGuildEmoji();
  exports.BaseGuildTextChannel = require_BaseGuildTextChannel();
  exports.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  exports.ButtonBuilder = require_ButtonBuilder();
  exports.ButtonComponent = require_ButtonComponent();
  exports.ButtonInteraction = require_ButtonInteraction();
  exports.CategoryChannel = require_CategoryChannel();
  exports.BaseChannel = require_BaseChannel().BaseChannel;
  exports.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  exports.ClientApplication = require_ClientApplication();
  exports.ClientPresence = require_ClientPresence();
  exports.ClientUser = require_ClientUser();
  exports.CommandInteraction = require_CommandInteraction();
  exports.Collector = require_Collector();
  exports.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  exports.Component = require_Component();
  exports.ContainerComponent = require_ContainerComponent();
  exports.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
  exports.DMChannel = require_DMChannel();
  exports.Embed = require_Embed();
  exports.EmbedBuilder = require_EmbedBuilder();
  exports.Emoji = require_Emoji().Emoji;
  exports.Entitlement = require_Entitlement().Entitlement;
  exports.FileComponent = require_FileComponent();
  exports.ForumChannel = require_ForumChannel();
  exports.Guild = require_Guild().Guild;
  exports.GuildAuditLogs = require_GuildAuditLogs();
  exports.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  exports.GuildBan = require_GuildBan();
  exports.GuildChannel = require_GuildChannel();
  exports.GuildEmoji = require_GuildEmoji();
  exports.GuildMember = require_GuildMember().GuildMember;
  exports.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
  exports.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
  exports.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
  exports.GuildPreview = require_GuildPreview();
  exports.GuildPreviewEmoji = require_GuildPreviewEmoji();
  exports.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
  exports.GuildTemplate = require_GuildTemplate();
  exports.Integration = require_Integration();
  exports.IntegrationApplication = require_IntegrationApplication();
  exports.InteractionCallback = require_InteractionCallback();
  exports.InteractionCallbackResource = require_InteractionCallbackResource();
  exports.InteractionCallbackResponse = require_InteractionCallbackResponse();
  exports.BaseInteraction = require_BaseInteraction();
  exports.InteractionCollector = require_InteractionCollector();
  exports.InteractionResponse = require_InteractionResponse();
  exports.InteractionWebhook = require_InteractionWebhook();
  exports.Invite = require_Invite();
  exports.InviteStageInstance = require_InviteStageInstance();
  exports.InviteGuild = require_InviteGuild();
  exports.Message = require_Message().Message;
  exports.Attachment = require_Attachment();
  exports.AttachmentBuilder = require_AttachmentBuilder();
  exports.ModalBuilder = require_ModalBuilder();
  exports.MediaChannel = require_MediaChannel();
  exports.MediaGalleryComponent = require_MediaGalleryComponent();
  exports.MediaGalleryItem = require_MediaGalleryItem();
  exports.MessageCollector = require_MessageCollector();
  exports.MessageComponentInteraction = require_MessageComponentInteraction();
  exports.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  exports.MessageMentions = require_MessageMentions();
  exports.MessagePayload = require_MessagePayload();
  exports.MessageReaction = require_MessageReaction();
  exports.ModalSubmitInteraction = require_ModalSubmitInteraction();
  exports.ModalSubmitFields = require_ModalSubmitFields();
  exports.NewsChannel = require_NewsChannel();
  exports.OAuth2Guild = require_OAuth2Guild();
  exports.PartialGroupDMChannel = require_PartialGroupDMChannel();
  exports.PermissionOverwrites = require_PermissionOverwrites();
  exports.Poll = require_Poll().Poll;
  exports.PollAnswer = require_PollAnswer().PollAnswer;
  exports.PrimaryEntryPointCommandInteraction = require_PrimaryEntryPointCommandInteraction();
  exports.Presence = require_Presence().Presence;
  exports.ReactionCollector = require_ReactionCollector();
  exports.ReactionEmoji = require_ReactionEmoji();
  exports.RichPresenceAssets = require_Presence().RichPresenceAssets;
  exports.Role = require_Role().Role;
  exports.SectionComponent = require_SectionComponent();
  exports.SelectMenuBuilder = require_SelectMenuBuilder();
  exports.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  exports.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  exports.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  exports.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  exports.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  exports.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
  exports.SelectMenuComponent = require_SelectMenuComponent();
  exports.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  exports.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  exports.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  exports.StringSelectMenuComponent = require_StringSelectMenuComponent();
  exports.UserSelectMenuComponent = require_UserSelectMenuComponent();
  exports.SelectMenuInteraction = require_SelectMenuInteraction();
  exports.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  exports.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  exports.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  exports.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
  exports.SeparatorComponent = require_SeparatorComponent();
  exports.SKU = require_SKU().SKU;
  exports.SoundboardSound = require_SoundboardSound().SoundboardSound;
  exports.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  exports.StageChannel = require_StageChannel();
  exports.StageInstance = require_StageInstance().StageInstance;
  exports.Subscription = require_Subscription().Subscription;
  exports.Sticker = require_Sticker().Sticker;
  exports.StickerPack = require_StickerPack();
  exports.Team = require_Team();
  exports.TeamMember = require_TeamMember();
  exports.TextChannel = require_TextChannel();
  exports.TextDisplayComponent = require_TextDisplayComponent();
  exports.TextInputBuilder = require_TextInputBuilder();
  exports.TextInputComponent = require_TextInputComponent();
  exports.ThreadChannel = require_ThreadChannel();
  exports.ThreadMember = require_ThreadMember();
  exports.ThreadOnlyChannel = require_ThreadOnlyChannel();
  exports.ThumbnailComponent = require_ThumbnailComponent();
  exports.Typing = require_Typing();
  exports.UnfurledMediaItem = require_UnfurledMediaItem();
  exports.User = require_User();
  exports.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  exports.VoiceChannelEffect = require_VoiceChannelEffect();
  exports.VoiceChannel = require_VoiceChannel();
  exports.VoiceRegion = require_VoiceRegion();
  exports.VoiceState = require_VoiceState();
  exports.Webhook = require_Webhook();
  exports.Widget = require_Widget();
  exports.WidgetMember = require_WidgetMember();
  exports.WelcomeChannel = require_WelcomeChannel();
  exports.WelcomeScreen = require_WelcomeScreen();
  __exportStar(require_v106(), exports);
  __exportStar(require_dist8(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist5(), exports);
  __exportStar(require_dist(), exports);
  __exportStar(require_dist10(), exports);
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports, module) => {
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {}
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (;i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var conversions = {};
  module.exports = conversions;
  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function evenRound(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  }
  function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  }
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0;i < keys.length; ++i) {
      Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  function normalize(str) {
    return str.split("\x00").map(function(s) {
      return s.normalize("NFC");
    }).join("\x00");
  }
  function findStatus(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  function countSymbols(string) {
    return string.replace(regexAstralSymbols, "_").length;
  }
  function mapChars(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i = 0;i < len; ++i) {
      var codePoint = domain_name.codePointAt(i);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  }
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  function validateLabel(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i = 0;i < len; ++i) {
      var status = findStatus(label.codePointAt(i));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  }
  function processing(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i = 0;i < labels.length; ++i) {
      try {
        var validation = validateLabel(labels[i]);
        labels[i] = validation.label;
        result.error = result.error || validation.error;
      } catch (e) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  }
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l) {
      try {
        return punycode.toASCII(l);
      } catch (e) {
        result.error = true;
        return l;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i = 0;i < labels.length; ++i) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  }
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    return "%" + hex;
  }
  function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i = 0;i < buf.length; ++i) {
      str += percentEncode(buf[i]);
    }
    return str;
  }
  function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i = 0;i < input.length; ++i) {
      if (input[i] !== 37) {
        output.push(input[i]);
      } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
        i += 2;
      } else {
        output.push(input[i]);
      }
    }
    return new Buffer(output).toString();
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  }
  function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i = 0;i < decoded.length; ++i) {
      output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
  }
  function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  }
  function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  }
  function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i = 0;i < buffer.length; ++i) {
        if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
          this.url.query += percentEncode(buffer[i]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string of url.path) {
        output += "/" + string;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  }
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0;i < decoded.length; ++i) {
      url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0;i < decoded.length; ++i) {
      url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var conversions = require_lib();
  var utils = require_utils2();
  var Impl = require_URL_impl();
  var impl = utils.implSymbol;
  function URL2(url) {
    if (!this || this[impl] || !(this instanceof URL2)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 2; ++i) {
      args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
      args[1] = conversions["USVString"](args[1]);
    }
    module.exports.setup(this, args);
  }
  URL2.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 0; ++i) {
      args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
  };
  Object.defineProperty(URL2.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL2.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL2.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj) {
      return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj = Object.create(URL2.prototype);
      this.setup(obj, constructorArgs, privateData);
      return obj;
    },
    setup(obj, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj;
      obj[impl] = new Impl.implementation(constructorArgs, privateData);
      obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL2,
    expose: {
      Window: { URL: URL2 },
      Worker: { URL: URL2 }
    }
  };
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {};
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{throw new Error("Cannot require module "+"encoding");})().convert;
  } catch (e) {}
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return;
  }
  var MAP = Symbol("map");

  class Headers2 {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers2) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders2(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders2(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== undefined ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
  Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers2.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  function getHeaders2(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index } = _INTERNAL;
      const values = getHeaders2(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers2;
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response2 {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers2(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response2(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response2.prototype);
  Object.defineProperties(Response2.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  var isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
  };
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          destroyStream(request.body, error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response2(body, response_options);
              resolve(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  }
  function destroyStream(stream, err) {
    if (stream.destroy) {
      stream.destroy(err);
    } else {
      stream.emit("error", err);
      stream.end();
    }
  }
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.Promise = global.Promise;
  module.exports = exports = fetch2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers2;
  exports.Request = Request;
  exports.Response = Response2;
  exports.FetchError = FetchError;
  exports.AbortError = AbortError;
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/gaxios/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "gaxios",
    version: "6.7.1",
    description: "A simple common HTTP client specifically for Google APIs and services.",
    main: "build/src/index.js",
    types: "build/src/index.d.ts",
    files: [
      "build/src"
    ],
    scripts: {
      lint: "gts check",
      test: "c8 mocha build/test",
      "presystem-test": "npm run compile",
      "system-test": "mocha build/system-test --timeout 80000",
      compile: "tsc -p .",
      fix: "gts fix",
      prepare: "npm run compile",
      pretest: "npm run compile",
      webpack: "webpack",
      "prebrowser-test": "npm run compile",
      "browser-test": "node build/browser-test/browser-test-runner.js",
      docs: "compodoc src/",
      "docs-test": "linkinator docs",
      "predocs-test": "npm run docs",
      "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
      prelint: "cd samples; npm link ../; npm install",
      clean: "gts clean",
      precompile: "gts clean"
    },
    repository: "googleapis/gaxios",
    keywords: [
      "google"
    ],
    engines: {
      node: ">=14"
    },
    author: "Google, LLC",
    license: "Apache-2.0",
    devDependencies: {
      "@babel/plugin-proposal-private-methods": "^7.18.6",
      "@compodoc/compodoc": "1.1.19",
      "@types/cors": "^2.8.6",
      "@types/express": "^4.16.1",
      "@types/extend": "^3.0.1",
      "@types/mocha": "^9.0.0",
      "@types/multiparty": "0.0.36",
      "@types/mv": "^2.1.0",
      "@types/ncp": "^2.0.1",
      "@types/node": "^20.0.0",
      "@types/node-fetch": "^2.5.7",
      "@types/sinon": "^17.0.0",
      "@types/tmp": "0.2.6",
      "@types/uuid": "^10.0.0",
      "abort-controller": "^3.0.0",
      assert: "^2.0.0",
      browserify: "^17.0.0",
      c8: "^8.0.0",
      cheerio: "1.0.0-rc.10",
      cors: "^2.8.5",
      execa: "^5.0.0",
      express: "^4.16.4",
      "form-data": "^4.0.0",
      gts: "^5.0.0",
      "is-docker": "^2.0.0",
      karma: "^6.0.0",
      "karma-chrome-launcher": "^3.0.0",
      "karma-coverage": "^2.0.0",
      "karma-firefox-launcher": "^2.0.0",
      "karma-mocha": "^2.0.0",
      "karma-remap-coverage": "^0.1.5",
      "karma-sourcemap-loader": "^0.4.0",
      "karma-webpack": "5.0.0",
      linkinator: "^3.0.0",
      mocha: "^8.0.0",
      multiparty: "^4.2.1",
      mv: "^2.1.1",
      ncp: "^2.0.0",
      nock: "^13.0.0",
      "null-loader": "^4.0.0",
      puppeteer: "^19.0.0",
      sinon: "^18.0.0",
      "stream-browserify": "^3.0.0",
      tmp: "0.2.3",
      "ts-loader": "^8.0.0",
      typescript: "^5.1.6",
      webpack: "^5.35.0",
      "webpack-cli": "^4.0.0"
    },
    dependencies: {
      extend: "^3.0.2",
      "https-proxy-agent": "^7.0.1",
      "is-stream": "^2.0.0",
      "node-fetch": "^2.6.9",
      uuid: "^9.0.1"
    }
  };
});

// node_modules/gaxios/build/src/util.js
var require_util10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pkg = undefined;
  exports.pkg = require_package2();
});

// node_modules/gaxios/build/src/common.js
var require_common4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = undefined;
  exports.defaultErrorRedactor = defaultErrorRedactor;
  var url_1 = __require("url");
  var util_1 = require_util10();
  var extend_1 = __importDefault(require_extend());
  exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${util_1.pkg.name}-gaxios-error`);

  class GaxiosError extends Error {
    static [(_a = exports.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](instance) {
      if (instance && typeof instance === "object" && exports.GAXIOS_ERROR_SYMBOL in instance && instance[exports.GAXIOS_ERROR_SYMBOL] === util_1.pkg.version) {
        return true;
      }
      return Function.prototype[Symbol.hasInstance].call(GaxiosError, instance);
    }
    constructor(message, config, response, error) {
      var _b;
      super(message);
      this.config = config;
      this.response = response;
      this.error = error;
      this[_a] = util_1.pkg.version;
      this.config = (0, extend_1.default)(true, {}, config);
      if (this.response) {
        this.response.config = (0, extend_1.default)(true, {}, this.response.config);
      }
      if (this.response) {
        try {
          this.response.data = translateData(this.config.responseType, (_b = this.response) === null || _b === undefined ? undefined : _b.data);
        } catch (_c) {}
        this.status = this.response.status;
      }
      if (error && "code" in error && error.code) {
        this.code = error.code;
      }
      if (config.errorRedactor) {
        config.errorRedactor({
          config: this.config,
          response: this.response
        });
      }
    }
  }
  exports.GaxiosError = GaxiosError;
  function translateData(responseType, data) {
    switch (responseType) {
      case "stream":
        return data;
      case "json":
        return JSON.parse(JSON.stringify(data));
      case "arraybuffer":
        return JSON.parse(Buffer.from(data).toString("utf8"));
      case "blob":
        return JSON.parse(data.text());
      default:
        return data;
    }
  }
  function defaultErrorRedactor(data) {
    const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
    function redactHeaders(headers) {
      if (!headers)
        return;
      for (const key of Object.keys(headers)) {
        if (/^authentication$/i.test(key)) {
          headers[key] = REDACT;
        }
        if (/^authorization$/i.test(key)) {
          headers[key] = REDACT;
        }
        if (/secret/i.test(key)) {
          headers[key] = REDACT;
        }
      }
    }
    function redactString(obj, key) {
      if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
        const text = obj[key];
        if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) {
          obj[key] = REDACT;
        }
      }
    }
    function redactObject(obj) {
      if (typeof obj === "object" && obj !== null) {
        if ("grant_type" in obj) {
          obj["grant_type"] = REDACT;
        }
        if ("assertion" in obj) {
          obj["assertion"] = REDACT;
        }
        if ("client_secret" in obj) {
          obj["client_secret"] = REDACT;
        }
      }
    }
    if (data.config) {
      redactHeaders(data.config.headers);
      redactString(data.config, "data");
      redactObject(data.config.data);
      redactString(data.config, "body");
      redactObject(data.config.body);
      try {
        const url = new url_1.URL("", data.config.url);
        if (url.searchParams.has("token")) {
          url.searchParams.set("token", REDACT);
        }
        if (url.searchParams.has("client_secret")) {
          url.searchParams.set("client_secret", REDACT);
        }
        data.config.url = url.toString();
      } catch (_b) {}
    }
    if (data.response) {
      defaultErrorRedactor({ config: data.response.config });
      redactHeaders(data.response.headers);
      redactString(data.response, "data");
      redactObject(data.response.data);
    }
    return data;
  }
});

// node_modules/gaxios/build/src/retry.js
var require_retry2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRetryConfig = getRetryConfig;
  async function getRetryConfig(err) {
    let config = getConfig(err);
    if (!err || !err.config || !config && !err.config.retry) {
      return { shouldRetry: false };
    }
    config = config || {};
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;
    config.httpMethodsToRetry = config.httpMethodsToRetry || [
      "GET",
      "HEAD",
      "PUT",
      "OPTIONS",
      "DELETE"
    ];
    config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries;
    config.retryDelayMultiplier = config.retryDelayMultiplier ? config.retryDelayMultiplier : 2;
    config.timeOfFirstRequest = config.timeOfFirstRequest ? config.timeOfFirstRequest : Date.now();
    config.totalTimeout = config.totalTimeout ? config.totalTimeout : Number.MAX_SAFE_INTEGER;
    config.maxRetryDelay = config.maxRetryDelay ? config.maxRetryDelay : Number.MAX_SAFE_INTEGER;
    const retryRanges = [
      [100, 199],
      [408, 408],
      [429, 429],
      [500, 599]
    ];
    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;
    err.config.retryConfig = config;
    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
    if (!await shouldRetryFn(err)) {
      return { shouldRetry: false, config: err.config };
    }
    const delay = getNextRetryDelay(config);
    err.config.retryConfig.currentRetryAttempt += 1;
    const backoff = config.retryBackoff ? config.retryBackoff(err, delay) : new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
    if (config.onRetryAttempt) {
      config.onRetryAttempt(err);
    }
    await backoff;
    return { shouldRetry: true, config: err.config };
  }
  function shouldRetryRequest(err) {
    var _a;
    const config = getConfig(err);
    if (err.name === "AbortError" || ((_a = err.error) === null || _a === undefined ? undefined : _a.name) === "AbortError") {
      return false;
    }
    if (!config || config.retry === 0) {
      return false;
    }
    if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
      return false;
    }
    if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
      return false;
    }
    if (err.response && err.response.status) {
      let isInRange = false;
      for (const [min, max] of config.statusCodesToRetry) {
        const status = err.response.status;
        if (status >= min && status <= max) {
          isInRange = true;
          break;
        }
      }
      if (!isInRange) {
        return false;
      }
    }
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    if (config.currentRetryAttempt >= config.retry) {
      return false;
    }
    return true;
  }
  function getConfig(err) {
    if (err && err.config && err.config.retryConfig) {
      return err.config.retryConfig;
    }
    return;
  }
  function getNextRetryDelay(config) {
    var _a;
    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== undefined ? _a : 100;
    const calculatedDelay = retryDelay + (Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) / 2 * 1000;
    const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
    return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
  }
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// node_modules/gaxios/build/src/interceptor.js
var require_interceptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GaxiosInterceptorManager = undefined;

  class GaxiosInterceptorManager extends Set {
  }
  exports.GaxiosInterceptorManager = GaxiosInterceptorManager;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common5 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common5()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common5()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist12 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar(__require("net"));
  var http = __importStar(__require("http"));
  var https_1 = __require("https");
  __exportStar(require_helpers(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options) {
      const secureEndpoint = this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http.Agent) {
          try {
            return socket.addRequest(req, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src2());
  var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`);
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist13 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src2());
  var agent_base_1 = require_dist12();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug = (0, debug_1.default)("https-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _Gaxios_instances;
  var _a;
  var _Gaxios_urlMayUseProxy;
  var _Gaxios_applyRequestInterceptors;
  var _Gaxios_applyResponseInterceptors;
  var _Gaxios_prepareRequest;
  var _Gaxios_proxyAgent;
  var _Gaxios_getProxyAgent;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Gaxios = undefined;
  var extend_1 = __importDefault(require_extend());
  var https_1 = __require("https");
  var node_fetch_1 = __importDefault(require_lib2());
  var querystring_1 = __importDefault(__require("querystring"));
  var is_stream_1 = __importDefault(require_is_stream());
  var url_1 = __require("url");
  var common_1 = require_common4();
  var retry_1 = require_retry2();
  var stream_1 = __require("stream");
  var uuid_1 = require_dist11();
  var interceptor_1 = require_interceptor();
  var fetch2 = hasFetch() ? window.fetch : node_fetch_1.default;
  function hasWindow() {
    return typeof window !== "undefined" && !!window;
  }
  function hasFetch() {
    return hasWindow() && !!window.fetch;
  }
  function hasBuffer() {
    return typeof Buffer !== "undefined";
  }
  function hasHeader(options, header) {
    return !!getHeader(options, header);
  }
  function getHeader(options, header) {
    header = header.toLowerCase();
    for (const key of Object.keys((options === null || options === undefined ? undefined : options.headers) || {})) {
      if (header === key.toLowerCase()) {
        return options.headers[key];
      }
    }
    return;
  }

  class Gaxios {
    constructor(defaults) {
      _Gaxios_instances.add(this);
      this.agentCache = new Map;
      this.defaults = defaults || {};
      this.interceptors = {
        request: new interceptor_1.GaxiosInterceptorManager,
        response: new interceptor_1.GaxiosInterceptorManager
      };
    }
    async request(opts = {}) {
      opts = await __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_prepareRequest).call(this, opts);
      opts = await __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_applyRequestInterceptors).call(this, opts);
      return __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_applyResponseInterceptors).call(this, this._request(opts));
    }
    async _defaultAdapter(opts) {
      const fetchImpl = opts.fetchImplementation || fetch2;
      const res = await fetchImpl(opts.url, opts);
      const data = await this.getResponseData(opts, res);
      return this.translateResponse(opts, res, data);
    }
    async _request(opts = {}) {
      var _b;
      try {
        let translatedResponse;
        if (opts.adapter) {
          translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
        } else {
          translatedResponse = await this._defaultAdapter(opts);
        }
        if (!opts.validateStatus(translatedResponse.status)) {
          if (opts.responseType === "stream") {
            let response = "";
            await new Promise((resolve) => {
              (translatedResponse === null || translatedResponse === undefined ? undefined : translatedResponse.data).on("data", (chunk) => {
                response += chunk;
              });
              (translatedResponse === null || translatedResponse === undefined ? undefined : translatedResponse.data).on("end", resolve);
            });
            translatedResponse.data = response;
          }
          throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
        }
        return translatedResponse;
      } catch (e) {
        const err = e instanceof common_1.GaxiosError ? e : new common_1.GaxiosError(e.message, opts, undefined, e);
        const { shouldRetry, config } = await (0, retry_1.getRetryConfig)(err);
        if (shouldRetry && config) {
          err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;
          opts.retryConfig = (_b = err.config) === null || _b === undefined ? undefined : _b.retryConfig;
          return this._request(opts);
        }
        throw err;
      }
    }
    async getResponseData(opts, res) {
      switch (opts.responseType) {
        case "stream":
          return res.body;
        case "json": {
          let data = await res.text();
          try {
            data = JSON.parse(data);
          } catch (_b) {}
          return data;
        }
        case "arraybuffer":
          return res.arrayBuffer();
        case "blob":
          return res.blob();
        case "text":
          return res.text();
        default:
          return this.getResponseDataFromContentType(res);
      }
    }
    validateStatus(status) {
      return status >= 200 && status < 300;
    }
    paramsSerializer(params) {
      return querystring_1.default.stringify(params);
    }
    translateResponse(opts, res, data) {
      const headers = {};
      res.headers.forEach((value, key) => {
        headers[key] = value;
      });
      return {
        config: opts,
        data,
        headers,
        status: res.status,
        statusText: res.statusText,
        request: {
          responseURL: res.url
        }
      };
    }
    async getResponseDataFromContentType(response) {
      let contentType = response.headers.get("Content-Type");
      if (contentType === null) {
        return response.text();
      }
      contentType = contentType.toLowerCase();
      if (contentType.includes("application/json")) {
        let data = await response.text();
        try {
          data = JSON.parse(data);
        } catch (_b) {}
        return data;
      } else if (contentType.match(/^text\//)) {
        return response.text();
      } else {
        return response.blob();
      }
    }
    async* getMultipartRequest(multipartOptions, boundary) {
      const finale = `--${boundary}--`;
      for (const currentPart of multipartOptions) {
        const partContentType = currentPart.headers["Content-Type"] || "application/octet-stream";
        const preamble = `--${boundary}\r
Content-Type: ${partContentType}\r
\r
`;
        yield preamble;
        if (typeof currentPart.content === "string") {
          yield currentPart.content;
        } else {
          yield* currentPart.content;
        }
        yield `\r
`;
      }
      yield finale;
    }
  }
  exports.Gaxios = Gaxios;
  _a = Gaxios, _Gaxios_instances = new WeakSet, _Gaxios_urlMayUseProxy = function _Gaxios_urlMayUseProxy(url, noProxy = []) {
    var _b, _c;
    const candidate = new url_1.URL(url);
    const noProxyList = [...noProxy];
    const noProxyEnvList = ((_c = (_b = process.env.NO_PROXY) !== null && _b !== undefined ? _b : process.env.no_proxy) === null || _c === undefined ? undefined : _c.split(",")) || [];
    for (const rule of noProxyEnvList) {
      noProxyList.push(rule.trim());
    }
    for (const rule of noProxyList) {
      if (rule instanceof RegExp) {
        if (rule.test(candidate.toString())) {
          return false;
        }
      } else if (rule instanceof url_1.URL) {
        if (rule.origin === candidate.origin) {
          return false;
        }
      } else if (rule.startsWith("*.") || rule.startsWith(".")) {
        const cleanedRule = rule.replace(/^\*\./, ".");
        if (candidate.hostname.endsWith(cleanedRule)) {
          return false;
        }
      } else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) {
        return false;
      }
    }
    return true;
  }, _Gaxios_applyRequestInterceptors = async function _Gaxios_applyRequestInterceptors(options) {
    let promiseChain = Promise.resolve(options);
    for (const interceptor of this.interceptors.request.values()) {
      if (interceptor) {
        promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
      }
    }
    return promiseChain;
  }, _Gaxios_applyResponseInterceptors = async function _Gaxios_applyResponseInterceptors(response) {
    let promiseChain = Promise.resolve(response);
    for (const interceptor of this.interceptors.response.values()) {
      if (interceptor) {
        promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
      }
    }
    return promiseChain;
  }, _Gaxios_prepareRequest = async function _Gaxios_prepareRequest(options) {
    var _b, _c, _d, _e;
    const opts = (0, extend_1.default)(true, {}, this.defaults, options);
    if (!opts.url) {
      throw new Error("URL is required.");
    }
    const baseUrl = opts.baseUrl || opts.baseURL;
    if (baseUrl) {
      opts.url = baseUrl.toString() + opts.url;
    }
    opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
    if (opts.params && Object.keys(opts.params).length > 0) {
      let additionalQueryParams = opts.paramsSerializer(opts.params);
      if (additionalQueryParams.startsWith("?")) {
        additionalQueryParams = additionalQueryParams.slice(1);
      }
      const prefix = opts.url.toString().includes("?") ? "&" : "?";
      opts.url = opts.url + prefix + additionalQueryParams;
    }
    if (typeof options.maxContentLength === "number") {
      opts.size = options.maxContentLength;
    }
    if (typeof options.maxRedirects === "number") {
      opts.follow = options.maxRedirects;
    }
    opts.headers = opts.headers || {};
    if (opts.multipart === undefined && opts.data) {
      const isFormData = typeof FormData === "undefined" ? false : (opts === null || opts === undefined ? undefined : opts.data) instanceof FormData;
      if (is_stream_1.default.readable(opts.data)) {
        opts.body = opts.data;
      } else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
        opts.body = opts.data;
        if (!hasHeader(opts, "Content-Type")) {
          opts.headers["Content-Type"] = "application/json";
        }
      } else if (typeof opts.data === "object") {
        if (!isFormData) {
          if (getHeader(opts, "content-type") === "application/x-www-form-urlencoded") {
            opts.body = opts.paramsSerializer(opts.data);
          } else {
            if (!hasHeader(opts, "Content-Type")) {
              opts.headers["Content-Type"] = "application/json";
            }
            opts.body = JSON.stringify(opts.data);
          }
        }
      } else {
        opts.body = opts.data;
      }
    } else if (opts.multipart && opts.multipart.length > 0) {
      const boundary = (0, uuid_1.v4)();
      opts.headers["Content-Type"] = `multipart/related; boundary=${boundary}`;
      const bodyStream = new stream_1.PassThrough;
      opts.body = bodyStream;
      (0, stream_1.pipeline)(this.getMultipartRequest(opts.multipart, boundary), bodyStream, () => {});
    }
    opts.validateStatus = opts.validateStatus || this.validateStatus;
    opts.responseType = opts.responseType || "unknown";
    if (!opts.headers["Accept"] && opts.responseType === "json") {
      opts.headers["Accept"] = "application/json";
    }
    opts.method = opts.method || "GET";
    const proxy = opts.proxy || ((_b = process === null || process === undefined ? undefined : process.env) === null || _b === undefined ? undefined : _b.HTTPS_PROXY) || ((_c = process === null || process === undefined ? undefined : process.env) === null || _c === undefined ? undefined : _c.https_proxy) || ((_d = process === null || process === undefined ? undefined : process.env) === null || _d === undefined ? undefined : _d.HTTP_PROXY) || ((_e = process === null || process === undefined ? undefined : process.env) === null || _e === undefined ? undefined : _e.http_proxy);
    const urlMayUseProxy = __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_urlMayUseProxy).call(this, opts.url, opts.noProxy);
    if (opts.agent) {} else if (proxy && urlMayUseProxy) {
      const HttpsProxyAgent = await __classPrivateFieldGet(_a, _a, "m", _Gaxios_getProxyAgent).call(_a);
      if (this.agentCache.has(proxy)) {
        opts.agent = this.agentCache.get(proxy);
      } else {
        opts.agent = new HttpsProxyAgent(proxy, {
          cert: opts.cert,
          key: opts.key
        });
        this.agentCache.set(proxy, opts.agent);
      }
    } else if (opts.cert && opts.key) {
      if (this.agentCache.has(opts.key)) {
        opts.agent = this.agentCache.get(opts.key);
      } else {
        opts.agent = new https_1.Agent({
          cert: opts.cert,
          key: opts.key
        });
        this.agentCache.set(opts.key, opts.agent);
      }
    }
    if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) {
      opts.errorRedactor = common_1.defaultErrorRedactor;
    }
    return opts;
  }, _Gaxios_getProxyAgent = async function _Gaxios_getProxyAgent() {
    __classPrivateFieldSet(this, _a, __classPrivateFieldGet(this, _a, "f", _Gaxios_proxyAgent) || (await Promise.resolve().then(() => __importStar(require_dist13()))).HttpsProxyAgent, "f", _Gaxios_proxyAgent);
    return __classPrivateFieldGet(this, _a, "f", _Gaxios_proxyAgent);
  };
  _Gaxios_proxyAgent = { value: undefined };
});

// node_modules/gaxios/build/src/index.js
var require_src3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.instance = exports.Gaxios = exports.GaxiosError = undefined;
  exports.request = request;
  var gaxios_1 = require_gaxios();
  Object.defineProperty(exports, "Gaxios", { enumerable: true, get: function() {
    return gaxios_1.Gaxios;
  } });
  var common_1 = require_common4();
  Object.defineProperty(exports, "GaxiosError", { enumerable: true, get: function() {
    return common_1.GaxiosError;
  } });
  __exportStar(require_interceptor(), exports);
  exports.instance = new gaxios_1.Gaxios;
  async function request(opts) {
    return exports.instance.request(opts);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS((exports, module) => {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 100000000000000, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1000, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 10000000000, 100000000000, 1000000000000, 10000000000000], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber2(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber2))
          return new BigNumber2(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v;i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber2(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length;i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0;str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length;str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE;i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (;i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber2.clone = clone;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0;i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (;i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9000000000000000) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 100000000000000);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (;i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9000000000000000) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 100000000000000);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (;i < k; ) {
              v = random53bitInt();
              if (v < 9000000000000000)
                c[i++] = v % 100000000000000;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (;c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1;c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0];v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (;i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (;i < len; ) {
            for (arrL = arr.length;arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0;j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber2(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (;xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut;++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length;!xc[--k]; )
              ;
            for (i = 0, str = "";i <= k; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice();i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0;i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (;aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (;!a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
          }
          q = new BigNumber2(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0;yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (;remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc[0];s >= 10; s /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber2(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (;len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne + (id === 2 && e > ne);
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += ".";i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (;i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber2(args[0]);
        for (;i < args.length; i++) {
          y = new BigNumber2(args[i]);
          if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (;!c[--j]; c.pop())
          ;
        for (j = c[0];j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber2(s, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0];k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (;xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1;k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (;; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0];j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1;j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length;xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber2(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare(this, new BigNumber2(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (;v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber2(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber2(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber2(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 240000000 : x.c[0] < 80000000000000 || nIsBig && x.c[0] <= 99999750000000))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber2(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber2(ONE);
        for (;; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c)
              break;
            if (k) {
              if (y.c.length > k)
                y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y;
        if (nIsNeg)
          y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber2(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a;b--; t.push(0))
            ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0;b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (;b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (;j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j;i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (;xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber2(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber2(x);
        }
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1)
          y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = [];i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL;--i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k;j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber2(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (;a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t = yc;
          yc = xc;
          xc = t;
          b = a;
        }
        for (a = 0;b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (;v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0];v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber2(n);
        } else {
          r = new BigNumber2(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3)
            s = 0;
          for (;; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (;i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber2(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber2(x);
        d = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber2(s);
        n0.c[0] = 0;
        for (;; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z, i = 1, j = a.length, r = a[0] + "";
      for (;i < j; ) {
        s = a[i++] + "";
        z = LOG_BASE - s.length;
        for (;z--; s = "0" + s)
          ;
        r += s;
      }
      for (j = r.length;r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0;i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + ".";++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len;--e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) {
      define(function() {
        return BigNumber;
      });
    } else if (typeof module != "undefined" && module.exports) {
      module.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(exports);
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  var BigNumber = require_bignumber();
  var JSON2 = exports;
  (function() {
    function f(n) {
      return n < 10 ? "0" + n : n;
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
      "\b": "\\b",
      "\t": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': "\\\"",
      "\\": "\\\\"
    }, rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          if (isBigNumber) {
            return value;
          } else {
            return quote(value);
          }
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0;i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? `[
` + gap + partial.join(`,
` + gap) + `
` + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0;i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k = rep[i];
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            Object.keys(value).forEach(function(k2) {
              var v2 = str(k2, value);
              if (v2) {
                partial.push(quote(k2) + (gap ? ": " : ":") + v2);
              }
            });
          }
          v = partial.length === 0 ? "{}" : gap ? `{
` + gap + partial.join(`,
` + gap) + `
` + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
      }
    }
    if (typeof JSON2.stringify !== "function") {
      JSON2.stringify = function(value, replacer, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
          for (i = 0;i < space; i += 1) {
            indent += " ";
          }
        } else if (typeof space === "string") {
          indent = space;
        }
        rep = replacer;
        if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
          throw new Error("JSON.stringify");
        }
        return str("", { "": value });
      };
    }
  })();
});

// node_modules/json-bigint/lib/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var BigNumber = null;
  var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
  var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
  var json_parse = function(options) {
    var _options = {
      strict: false,
      storeAsString: false,
      alwaysParseAsBig: false,
      useNativeBigInt: false,
      protoAction: "error",
      constructorAction: "error"
    };
    if (options !== undefined && options !== null) {
      if (options.strict === true) {
        _options.strict = true;
      }
      if (options.storeAsString === true) {
        _options.storeAsString = true;
      }
      _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
      _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
      if (typeof options.constructorAction !== "undefined") {
        if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
          _options.constructorAction = options.constructorAction;
        } else {
          throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
        }
      }
      if (typeof options.protoAction !== "undefined") {
        if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
          _options.protoAction = options.protoAction;
        } else {
          throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
        }
      }
    }
    var at, ch, escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "\t"
    }, text, error = function(m) {
      throw {
        name: "SyntaxError",
        message: m,
        at,
        text
      };
    }, next = function(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }, number = function() {
      var number2, string2 = "";
      if (ch === "-") {
        string2 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        string2 += ch;
        next();
      }
      if (ch === ".") {
        string2 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          string2 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        string2 += ch;
        next();
        if (ch === "-" || ch === "+") {
          string2 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
      }
      number2 = +string2;
      if (!isFinite(number2)) {
        error("Bad number");
      } else {
        if (BigNumber == null)
          BigNumber = require_bignumber();
        if (string2.length > 15)
          return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
        else
          return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
      }
    }, string = function() {
      var hex, i, string2 = "", uffff;
      if (ch === '"') {
        var startAt = at;
        while (next()) {
          if (ch === '"') {
            if (at - 1 > startAt)
              string2 += text.substring(startAt, at - 1);
            next();
            return string2;
          }
          if (ch === "\\") {
            if (at - 1 > startAt)
              string2 += text.substring(startAt, at - 1);
            next();
            if (ch === "u") {
              uffff = 0;
              for (i = 0;i < 4; i += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string2 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string2 += escapee[ch];
            } else {
              break;
            }
            startAt = at;
          }
        }
      }
      error("Bad string");
    }, white = function() {
      while (ch && ch <= " ") {
        next();
      }
    }, word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
      }
      error("Unexpected '" + ch + "'");
    }, value, array = function() {
      var array2 = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return array2;
        }
        while (ch) {
          array2.push(value());
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }, object = function() {
      var key, object2 = Object.create(null);
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
            error('Duplicate key "' + key + '"');
          }
          if (suspectProtoRx.test(key) === true) {
            if (_options.protoAction === "error") {
              error("Object contains forbidden prototype property");
            } else if (_options.protoAction === "ignore") {
              value();
            } else {
              object2[key] = value();
            }
          } else if (suspectConstructorRx.test(key) === true) {
            if (_options.constructorAction === "error") {
              error("Object contains forbidden constructor property");
            } else if (_options.constructorAction === "ignore") {
              value();
            } else {
              object2[key] = value();
            }
          } else {
            object2[key] = value();
          }
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    };
    return function(source, reviver) {
      var result;
      text = source + "";
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k, v, value2 = holder[key];
        if (value2 && typeof value2 === "object") {
          Object.keys(value2).forEach(function(k2) {
            v = walk(value2, k2);
            if (v !== undefined) {
              value2[k2] = v;
            } else {
              delete value2[k2];
            }
          });
        }
        return reviver.call(holder, key, value2);
      }({ "": result }, "") : result;
    };
  };
  module.exports = json_parse;
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS((exports, module) => {
  var json_stringify = require_stringify2().stringify;
  var json_parse = require_parse3();
  module.exports = function(options) {
    return {
      parse: json_parse(options),
      stringify: json_stringify
    };
  };
  module.exports.parse = json_parse();
  module.exports.stringify = json_stringify;
});

// node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GCE_LINUX_BIOS_PATHS = undefined;
  exports.isGoogleCloudServerless = isGoogleCloudServerless;
  exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
  exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
  exports.isGoogleComputeEngine = isGoogleComputeEngine;
  exports.detectGCPResidency = detectGCPResidency;
  var fs_1 = __require("fs");
  var os_1 = __require("os");
  exports.GCE_LINUX_BIOS_PATHS = {
    BIOS_DATE: "/sys/class/dmi/id/bios_date",
    BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
  };
  var GCE_MAC_ADDRESS_REGEX = /^42:01/;
  function isGoogleCloudServerless() {
    const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
    return !!isGFEnvironment;
  }
  function isGoogleComputeEngineLinux() {
    if ((0, os_1.platform)() !== "linux")
      return false;
    try {
      (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
      const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
      return /Google/.test(biosVendor);
    } catch (_a) {
      return false;
    }
  }
  function isGoogleComputeEngineMACAddress() {
    const interfaces = (0, os_1.networkInterfaces)();
    for (const item of Object.values(interfaces)) {
      if (!item)
        continue;
      for (const { mac } of item) {
        if (GCE_MAC_ADDRESS_REGEX.test(mac)) {
          return true;
        }
      }
    }
    return false;
  }
  function isGoogleComputeEngine() {
    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
  }
  function detectGCPResidency() {
    return isGoogleCloudServerless() || isGoogleComputeEngine();
  }
});

// node_modules/google-logging-utils/build/src/colours.js
var require_colours = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Colours = undefined;

  class Colours {
    static isEnabled(stream) {
      return stream.isTTY && (typeof stream.getColorDepth === "function" ? stream.getColorDepth() > 2 : true);
    }
    static refresh() {
      Colours.enabled = Colours.isEnabled(process.stderr);
      if (!this.enabled) {
        Colours.reset = "";
        Colours.bright = "";
        Colours.dim = "";
        Colours.red = "";
        Colours.green = "";
        Colours.yellow = "";
        Colours.blue = "";
        Colours.magenta = "";
        Colours.cyan = "";
        Colours.white = "";
        Colours.grey = "";
      } else {
        Colours.reset = "\x1B[0m";
        Colours.bright = "\x1B[1m";
        Colours.dim = "\x1B[2m";
        Colours.red = "\x1B[31m";
        Colours.green = "\x1B[32m";
        Colours.yellow = "\x1B[33m";
        Colours.blue = "\x1B[34m";
        Colours.magenta = "\x1B[35m";
        Colours.cyan = "\x1B[36m";
        Colours.white = "\x1B[37m";
        Colours.grey = "\x1B[90m";
      }
    }
  }
  exports.Colours = Colours;
  Colours.enabled = false;
  Colours.reset = "";
  Colours.bright = "";
  Colours.dim = "";
  Colours.red = "";
  Colours.green = "";
  Colours.yellow = "";
  Colours.blue = "";
  Colours.magenta = "";
  Colours.cyan = "";
  Colours.white = "";
  Colours.grey = "";
  Colours.refresh();
});

// node_modules/google-logging-utils/build/src/logging-utils.js
var require_logging_utils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.env = exports.DebugLogBackendBase = exports.placeholder = exports.AdhocDebugLogger = exports.LogSeverity = undefined;
  exports.getNodeBackend = getNodeBackend;
  exports.getDebugBackend = getDebugBackend;
  exports.getStructuredBackend = getStructuredBackend;
  exports.setBackend = setBackend;
  exports.log = log;
  var node_events_1 = __require("node:events");
  var process2 = __importStar(__require("node:process"));
  var util = __importStar(__require("node:util"));
  var colours_1 = require_colours();
  var LogSeverity;
  (function(LogSeverity2) {
    LogSeverity2["DEFAULT"] = "DEFAULT";
    LogSeverity2["DEBUG"] = "DEBUG";
    LogSeverity2["INFO"] = "INFO";
    LogSeverity2["WARNING"] = "WARNING";
    LogSeverity2["ERROR"] = "ERROR";
  })(LogSeverity || (exports.LogSeverity = LogSeverity = {}));

  class AdhocDebugLogger extends node_events_1.EventEmitter {
    constructor(namespace, upstream) {
      super();
      this.namespace = namespace;
      this.upstream = upstream;
      this.func = Object.assign(this.invoke.bind(this), {
        instance: this,
        on: (event, listener) => this.on(event, listener)
      });
      this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);
      this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);
      this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);
      this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);
      this.func.sublog = (namespace2) => log(namespace2, this.func);
    }
    invoke(fields, ...args) {
      if (this.upstream) {
        this.upstream(fields, ...args);
      }
      this.emit("log", fields, args);
    }
    invokeSeverity(severity, ...args) {
      this.invoke({ severity }, ...args);
    }
  }
  exports.AdhocDebugLogger = AdhocDebugLogger;
  exports.placeholder = new AdhocDebugLogger("", () => {}).func;

  class DebugLogBackendBase {
    constructor() {
      var _a;
      this.cached = new Map;
      this.filters = [];
      this.filtersSet = false;
      let nodeFlag = (_a = process2.env[exports.env.nodeEnables]) !== null && _a !== undefined ? _a : "*";
      if (nodeFlag === "all") {
        nodeFlag = "*";
      }
      this.filters = nodeFlag.split(",");
    }
    log(namespace, fields, ...args) {
      try {
        if (!this.filtersSet) {
          this.setFilters();
          this.filtersSet = true;
        }
        let logger = this.cached.get(namespace);
        if (!logger) {
          logger = this.makeLogger(namespace);
          this.cached.set(namespace, logger);
        }
        logger(fields, ...args);
      } catch (e) {
        console.error(e);
      }
    }
  }
  exports.DebugLogBackendBase = DebugLogBackendBase;

  class NodeBackend extends DebugLogBackendBase {
    constructor() {
      super(...arguments);
      this.enabledRegexp = /.*/g;
    }
    isEnabled(namespace) {
      return this.enabledRegexp.test(namespace);
    }
    makeLogger(namespace) {
      if (!this.enabledRegexp.test(namespace)) {
        return () => {};
      }
      return (fields, ...args) => {
        var _a;
        const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;
        const pid = `${colours_1.Colours.yellow}${process2.pid}${colours_1.Colours.reset}`;
        let level;
        switch (fields.severity) {
          case LogSeverity.ERROR:
            level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;
            break;
          case LogSeverity.INFO:
            level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;
            break;
          case LogSeverity.WARNING:
            level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;
            break;
          default:
            level = (_a = fields.severity) !== null && _a !== undefined ? _a : LogSeverity.DEFAULT;
            break;
        }
        const msg = util.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);
        const filteredFields = Object.assign({}, fields);
        delete filteredFields.severity;
        const fieldsJson = Object.getOwnPropertyNames(filteredFields).length ? JSON.stringify(filteredFields) : "";
        const fieldsColour = fieldsJson ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}` : "";
        console.error("%s [%s|%s] %s%s", pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : "");
      };
    }
    setFilters() {
      const totalFilters = this.filters.join(",");
      const regexp = totalFilters.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
      this.enabledRegexp = new RegExp(`^${regexp}$`, "i");
    }
  }
  function getNodeBackend() {
    return new NodeBackend;
  }

  class DebugBackend extends DebugLogBackendBase {
    constructor(pkg) {
      super();
      this.debugPkg = pkg;
    }
    makeLogger(namespace) {
      const debugLogger = this.debugPkg(namespace);
      return (fields, ...args) => {
        debugLogger(args[0], ...args.slice(1));
      };
    }
    setFilters() {
      var _a;
      const existingFilters = (_a = process2.env["NODE_DEBUG"]) !== null && _a !== undefined ? _a : "";
      process2.env["NODE_DEBUG"] = `${existingFilters}${existingFilters ? "," : ""}${this.filters.join(",")}`;
    }
  }
  function getDebugBackend(debugPkg) {
    return new DebugBackend(debugPkg);
  }

  class StructuredBackend extends DebugLogBackendBase {
    constructor(upstream) {
      var _a;
      super();
      this.upstream = (_a = upstream) !== null && _a !== undefined ? _a : new NodeBackend;
    }
    makeLogger(namespace) {
      const debugLogger = this.upstream.makeLogger(namespace);
      return (fields, ...args) => {
        var _a;
        const severity = (_a = fields.severity) !== null && _a !== undefined ? _a : LogSeverity.INFO;
        const json = Object.assign({
          severity,
          message: util.format(...args)
        }, fields);
        const jsonString = JSON.stringify(json);
        debugLogger(fields, jsonString);
      };
    }
    setFilters() {
      this.upstream.setFilters();
    }
  }
  function getStructuredBackend(upstream) {
    return new StructuredBackend(upstream);
  }
  exports.env = {
    nodeEnables: "GOOGLE_SDK_NODE_LOGGING"
  };
  var loggerCache = new Map;
  var cachedBackend = undefined;
  function setBackend(backend) {
    cachedBackend = backend;
    loggerCache.clear();
  }
  function log(namespace, parent) {
    const enablesFlag = process2.env[exports.env.nodeEnables];
    if (!enablesFlag) {
      return exports.placeholder;
    }
    if (!namespace) {
      return exports.placeholder;
    }
    if (parent) {
      namespace = `${parent.instance.namespace}:${namespace}`;
    }
    const existing = loggerCache.get(namespace);
    if (existing) {
      return existing.func;
    }
    if (cachedBackend === null) {
      return exports.placeholder;
    } else if (cachedBackend === undefined) {
      cachedBackend = getNodeBackend();
    }
    const logger = (() => {
      let previousBackend = undefined;
      const newLogger = new AdhocDebugLogger(namespace, (fields, ...args) => {
        if (previousBackend !== cachedBackend) {
          if (cachedBackend === null) {
            return;
          } else if (cachedBackend === undefined) {
            cachedBackend = getNodeBackend();
          }
          previousBackend = cachedBackend;
        }
        cachedBackend === null || cachedBackend === undefined || cachedBackend.log(namespace, fields, ...args);
      });
      return newLogger;
    })();
    loggerCache.set(namespace, logger);
    return logger.func;
  }
});

// node_modules/google-logging-utils/build/src/index.js
var require_src4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_logging_utils(), exports);
});

// node_modules/gcp-metadata/build/src/index.js
var require_src5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = undefined;
  exports.instance = instance;
  exports.project = project;
  exports.universe = universe;
  exports.bulk = bulk;
  exports.isAvailable = isAvailable;
  exports.resetIsAvailableCache = resetIsAvailableCache;
  exports.getGCPResidency = getGCPResidency;
  exports.setGCPResidency = setGCPResidency;
  exports.requestTimeout = requestTimeout;
  var gaxios_1 = require_src3();
  var jsonBigint = require_json_bigint();
  var gcp_residency_1 = require_gcp_residency();
  var logger = require_src4();
  exports.BASE_PATH = "/computeMetadata/v1";
  exports.HOST_ADDRESS = "http://169.254.169.254";
  exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
  exports.HEADER_NAME = "Metadata-Flavor";
  exports.HEADER_VALUE = "Google";
  exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
  var log = logger.log("gcp metadata");
  exports.METADATA_SERVER_DETECTION = Object.freeze({
    "assume-present": "don't try to ping the metadata server, but assume it's present",
    none: "don't try to ping the metadata server, but don't try to use it either",
    "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
    "ping-only": "skip the BIOS probe, and go straight to pinging"
  });
  function getBaseUrl(baseUrl) {
    if (!baseUrl) {
      baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
    }
    if (!/^https?:\/\//.test(baseUrl)) {
      baseUrl = `http://${baseUrl}`;
    }
    return new URL(exports.BASE_PATH, baseUrl).href;
  }
  function validate(options) {
    Object.keys(options).forEach((key) => {
      switch (key) {
        case "params":
        case "property":
        case "headers":
          break;
        case "qs":
          throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
        default:
          throw new Error(`'${key}' is not a valid configuration option.`);
      }
    });
  }
  async function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {
    let metadataKey = "";
    let params = {};
    let headers = {};
    if (typeof type === "object") {
      const metadataAccessor2 = type;
      metadataKey = metadataAccessor2.metadataKey;
      params = metadataAccessor2.params || params;
      headers = metadataAccessor2.headers || headers;
      noResponseRetries = metadataAccessor2.noResponseRetries || noResponseRetries;
      fastFail = metadataAccessor2.fastFail || fastFail;
    } else {
      metadataKey = type;
    }
    if (typeof options === "string") {
      metadataKey += `/${options}`;
    } else {
      validate(options);
      if (options.property) {
        metadataKey += `/${options.property}`;
      }
      headers = options.headers || headers;
      params = options.params || params;
    }
    const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
    const req = {
      url: `${getBaseUrl()}/${metadataKey}`,
      headers: { ...exports.HEADERS, ...headers },
      retryConfig: { noResponseRetries },
      params,
      responseType: "text",
      timeout: requestTimeout()
    };
    log.info("instance request %j", req);
    const res = await requestMethod(req);
    log.info("instance metadata is %s", res.data);
    if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {
      throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${res.headers[exports.HEADER_NAME.toLowerCase()] ? `'${res.headers[exports.HEADER_NAME.toLowerCase()]}'` : "no header"}`);
    }
    if (typeof res.data === "string") {
      try {
        return jsonBigint.parse(res.data);
      } catch (_a) {}
    }
    return res.data;
  }
  async function fastFailMetadataRequest(options) {
    var _a;
    const secondaryOptions = {
      ...options,
      url: (_a = options.url) === null || _a === undefined ? undefined : _a.toString().replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))
    };
    let responded = false;
    const r1 = (0, gaxios_1.request)(options).then((res) => {
      responded = true;
      return res;
    }).catch((err) => {
      if (responded) {
        return r2;
      } else {
        responded = true;
        throw err;
      }
    });
    const r2 = (0, gaxios_1.request)(secondaryOptions).then((res) => {
      responded = true;
      return res;
    }).catch((err) => {
      if (responded) {
        return r1;
      } else {
        responded = true;
        throw err;
      }
    });
    return Promise.race([r1, r2]);
  }
  function instance(options) {
    return metadataAccessor("instance", options);
  }
  function project(options) {
    return metadataAccessor("project", options);
  }
  function universe(options) {
    return metadataAccessor("universe", options);
  }
  async function bulk(properties) {
    const r = {};
    await Promise.all(properties.map((item) => {
      return (async () => {
        const res = await metadataAccessor(item);
        const key = item.metadataKey;
        r[key] = res;
      })();
    }));
    return r;
  }
  function detectGCPAvailableRetries() {
    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
  }
  var cachedIsAvailableResponse;
  async function isAvailable() {
    if (process.env.METADATA_SERVER_DETECTION) {
      const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
      if (!(value in exports.METADATA_SERVER_DETECTION)) {
        throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
      }
      switch (value) {
        case "assume-present":
          return true;
        case "none":
          return false;
        case "bios-only":
          return getGCPResidency();
        case "ping-only":
      }
    }
    try {
      if (cachedIsAvailableResponse === undefined) {
        cachedIsAvailableResponse = metadataAccessor("instance", undefined, detectGCPAvailableRetries(), !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));
      }
      await cachedIsAvailableResponse;
      return true;
    } catch (e) {
      const err = e;
      if (process.env.DEBUG_AUTH) {
        console.info(err);
      }
      if (err.type === "request-timeout") {
        return false;
      }
      if (err.response && err.response.status === 404) {
        return false;
      } else {
        if (!(err.response && err.response.status === 404) && (!err.code || ![
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "ENETUNREACH",
          "ENOENT",
          "ENOTFOUND",
          "ECONNREFUSED"
        ].includes(err.code))) {
          let code = "UNKNOWN";
          if (err.code)
            code = err.code;
          process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
        }
        return false;
      }
    }
  }
  function resetIsAvailableCache() {
    cachedIsAvailableResponse = undefined;
  }
  exports.gcpResidencyCache = null;
  function getGCPResidency() {
    if (exports.gcpResidencyCache === null) {
      setGCPResidency();
    }
    return exports.gcpResidencyCache;
  }
  function setGCPResidency(value = null) {
    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
  }
  function requestTimeout() {
    return getGCPResidency() ? 0 : 3000;
  }
  __exportStar(require_gcp_residency(), exports);
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports) => {
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length;i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup[45] = 62;
  revLookup[95] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0;i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start;i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
});

// node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserCrypto = undefined;
  var base64js = require_base64_js();
  var crypto_1 = require_crypto3();

  class BrowserCrypto {
    constructor() {
      if (typeof window === "undefined" || window.crypto === undefined || window.crypto.subtle === undefined) {
        throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
      }
    }
    async sha256DigestBase64(str) {
      const inputBuffer = new TextEncoder().encode(str);
      const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
      return base64js.fromByteArray(new Uint8Array(outputBuffer));
    }
    randomBytesBase64(count) {
      const array = new Uint8Array(count);
      window.crypto.getRandomValues(array);
      return base64js.fromByteArray(array);
    }
    static padBase64(base64) {
      while (base64.length % 4 !== 0) {
        base64 += "=";
      }
      return base64;
    }
    async verify(pubkey, data, signature) {
      const algo = {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
      const dataArray = new TextEncoder().encode(data);
      const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));
      const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
      const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
      return result;
    }
    async sign(privateKey, data) {
      const algo = {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
      const dataArray = new TextEncoder().encode(data);
      const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
      const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
      return base64js.fromByteArray(new Uint8Array(result));
    }
    decodeBase64StringUtf8(base64) {
      const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));
      const result = new TextDecoder().decode(uint8array);
      return result;
    }
    encodeBase64StringUtf8(text) {
      const uint8array = new TextEncoder().encode(text);
      const result = base64js.fromByteArray(uint8array);
      return result;
    }
    async sha256DigestHex(str) {
      const inputBuffer = new TextEncoder().encode(str);
      const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
      return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);
    }
    async signWithHmacSha256(key, msg) {
      const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
      const enc = new TextEncoder;
      const cryptoKey = await window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      }, false, ["sign"]);
      return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
    }
  }
  exports.BrowserCrypto = BrowserCrypto;
});

// node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeCrypto = undefined;
  var crypto2 = __require("crypto");

  class NodeCrypto {
    async sha256DigestBase64(str) {
      return crypto2.createHash("sha256").update(str).digest("base64");
    }
    randomBytesBase64(count) {
      return crypto2.randomBytes(count).toString("base64");
    }
    async verify(pubkey, data, signature) {
      const verifier = crypto2.createVerify("RSA-SHA256");
      verifier.update(data);
      verifier.end();
      return verifier.verify(pubkey, signature, "base64");
    }
    async sign(privateKey, data) {
      const signer = crypto2.createSign("RSA-SHA256");
      signer.update(data);
      signer.end();
      return signer.sign(privateKey, "base64");
    }
    decodeBase64StringUtf8(base64) {
      return Buffer.from(base64, "base64").toString("utf-8");
    }
    encodeBase64StringUtf8(text) {
      return Buffer.from(text, "utf-8").toString("base64");
    }
    async sha256DigestHex(str) {
      return crypto2.createHash("sha256").update(str).digest("hex");
    }
    async signWithHmacSha256(key, msg) {
      const cryptoKey = typeof key === "string" ? key : toBuffer(key);
      return toArrayBuffer(crypto2.createHmac("sha256", cryptoKey).update(msg).digest());
    }
  }
  exports.NodeCrypto = NodeCrypto;
  function toArrayBuffer(buffer) {
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  function toBuffer(arrayBuffer) {
    return Buffer.from(arrayBuffer);
  }
});

// node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCrypto = createCrypto;
  exports.hasBrowserCrypto = hasBrowserCrypto;
  exports.fromArrayBufferToHex = fromArrayBufferToHex;
  var crypto_1 = require_crypto();
  var crypto_2 = require_crypto2();
  function createCrypto() {
    if (hasBrowserCrypto()) {
      return new crypto_1.BrowserCrypto;
    }
    return new crypto_2.NodeCrypto;
  }
  function hasBrowserCrypto() {
    return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
  }
  function fromArrayBufferToHex(arrayBuffer) {
    const byteArray = Array.from(new Uint8Array(arrayBuffer));
    return byteArray.map((byte) => {
      return byte.toString(16).padStart(2, "0");
    }).join("");
  }
});

// node_modules/google-auth-library/build/src/options.js
var require_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = validate;
  function validate(options) {
    const vpairs = [
      { invalid: "uri", expected: "url" },
      { invalid: "json", expected: "data" },
      { invalid: "qs", expected: "params" }
    ];
    for (const pair of vpairs) {
      if (options[pair.invalid]) {
        const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
        throw new Error(e);
      }
    }
  }
});

// node_modules/google-auth-library/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "google-auth-library",
    version: "9.15.1",
    author: "Google Inc.",
    description: "Google APIs Authentication Client Library for Node.js",
    engines: {
      node: ">=14"
    },
    main: "./build/src/index.js",
    types: "./build/src/index.d.ts",
    repository: "googleapis/google-auth-library-nodejs.git",
    keywords: [
      "google",
      "api",
      "google apis",
      "client",
      "client library"
    ],
    dependencies: {
      "base64-js": "^1.3.0",
      "ecdsa-sig-formatter": "^1.0.11",
      gaxios: "^6.1.1",
      "gcp-metadata": "^6.1.0",
      gtoken: "^7.0.0",
      jws: "^4.0.0"
    },
    devDependencies: {
      "@types/base64-js": "^1.2.5",
      "@types/chai": "^4.1.7",
      "@types/jws": "^3.1.0",
      "@types/mocha": "^9.0.0",
      "@types/mv": "^2.1.0",
      "@types/ncp": "^2.0.1",
      "@types/node": "^20.4.2",
      "@types/sinon": "^17.0.0",
      "assert-rejects": "^1.0.0",
      c8: "^8.0.0",
      chai: "^4.2.0",
      cheerio: "1.0.0-rc.12",
      codecov: "^3.0.2",
      "engine.io": "6.6.2",
      gts: "^5.0.0",
      "is-docker": "^2.0.0",
      jsdoc: "^4.0.0",
      "jsdoc-fresh": "^3.0.0",
      "jsdoc-region-tag": "^3.0.0",
      karma: "^6.0.0",
      "karma-chrome-launcher": "^3.0.0",
      "karma-coverage": "^2.0.0",
      "karma-firefox-launcher": "^2.0.0",
      "karma-mocha": "^2.0.0",
      "karma-sourcemap-loader": "^0.4.0",
      "karma-webpack": "5.0.0",
      keypair: "^1.0.4",
      linkinator: "^4.0.0",
      mocha: "^9.2.2",
      mv: "^2.1.1",
      ncp: "^2.0.0",
      nock: "^13.0.0",
      "null-loader": "^4.0.0",
      pdfmake: "0.2.12",
      puppeteer: "^21.0.0",
      sinon: "^18.0.0",
      "ts-loader": "^8.0.0",
      typescript: "^5.1.6",
      webpack: "^5.21.2",
      "webpack-cli": "^4.0.0"
    },
    files: [
      "build/src",
      "!build/src/**/*.map"
    ],
    scripts: {
      test: "c8 mocha build/test",
      clean: "gts clean",
      prepare: "npm run compile",
      lint: "gts check",
      compile: "tsc -p .",
      fix: "gts fix",
      pretest: "npm run compile -- --sourceMap",
      docs: "jsdoc -c .jsdoc.json",
      "samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
      "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
      "system-test": "mocha build/system-test --timeout 60000",
      "presystem-test": "npm run compile -- --sourceMap",
      webpack: "webpack",
      "browser-test": "karma start",
      "docs-test": "linkinator docs",
      "predocs-test": "npm run docs",
      prelint: "cd samples; npm link ../; npm install",
      precompile: "gts clean"
    },
    license: "Apache-2.0"
  };
});

// node_modules/google-auth-library/build/src/transporters.js
var require_transporters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultTransporter = undefined;
  var gaxios_1 = require_src3();
  var options_1 = require_options();
  var pkg = require_package3();
  var PRODUCT_NAME = "google-api-nodejs-client";

  class DefaultTransporter {
    constructor() {
      this.instance = new gaxios_1.Gaxios;
    }
    configure(opts = {}) {
      opts.headers = opts.headers || {};
      if (typeof window === "undefined") {
        const uaValue = opts.headers["User-Agent"];
        if (!uaValue) {
          opts.headers["User-Agent"] = DefaultTransporter.USER_AGENT;
        } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {
          opts.headers["User-Agent"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;
        }
        if (!opts.headers["x-goog-api-client"]) {
          const nodeVersion = process.version.replace(/^v/, "");
          opts.headers["x-goog-api-client"] = `gl-node/${nodeVersion}`;
        }
      }
      return opts;
    }
    request(opts) {
      opts = this.configure(opts);
      (0, options_1.validate)(opts);
      return this.instance.request(opts).catch((e) => {
        throw this.processError(e);
      });
    }
    get defaults() {
      return this.instance.defaults;
    }
    set defaults(opts) {
      this.instance.defaults = opts;
    }
    processError(e) {
      const res = e.response;
      const err = e;
      const body = res ? res.data : null;
      if (res && body && body.error && res.status !== 200) {
        if (typeof body.error === "string") {
          err.message = body.error;
          err.status = res.status;
        } else if (Array.isArray(body.error.errors)) {
          err.message = body.error.errors.map((err2) => err2.message).join(`
`);
          err.code = body.error.code;
          err.errors = body.error.errors;
        } else {
          err.message = body.error.message;
          err.code = body.error.code;
        }
      } else if (res && res.status >= 400) {
        err.message = body;
        err.status = res.status;
      }
      return err;
    }
  }
  exports.DefaultTransporter = DefaultTransporter;
  DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/google-auth-library/build/src/util.js
var require_util11 = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _LRUCache_instances;
  var _LRUCache_cache;
  var _LRUCache_moveToEnd;
  var _LRUCache_evict;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LRUCache = undefined;
  exports.snakeToCamel = snakeToCamel;
  exports.originalOrCamelOptions = originalOrCamelOptions;
  function snakeToCamel(str) {
    return str.replace(/([_][^_])/g, (match) => match.slice(1).toUpperCase());
  }
  function originalOrCamelOptions(obj) {
    function get(key) {
      var _a;
      const o = obj || {};
      return (_a = o[key]) !== null && _a !== undefined ? _a : o[snakeToCamel(key)];
    }
    return { get };
  }

  class LRUCache {
    constructor(options) {
      _LRUCache_instances.add(this);
      _LRUCache_cache.set(this, new Map);
      this.capacity = options.capacity;
      this.maxAge = options.maxAge;
    }
    set(key, value) {
      __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, value);
      __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
    }
    get(key) {
      const item = __classPrivateFieldGet(this, _LRUCache_cache, "f").get(key);
      if (!item)
        return;
      __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, item.value);
      __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
      return item.value;
    }
  }
  exports.LRUCache = LRUCache;
  _LRUCache_cache = new WeakMap, _LRUCache_instances = new WeakSet, _LRUCache_moveToEnd = function _LRUCache_moveToEnd(key, value) {
    __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(key);
    __classPrivateFieldGet(this, _LRUCache_cache, "f").set(key, {
      value,
      lastAccessed: Date.now()
    });
  }, _LRUCache_evict = function _LRUCache_evict() {
    const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
    let oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, "f").entries().next();
    while (!oldestItem.done && (__classPrivateFieldGet(this, _LRUCache_cache, "f").size > this.capacity || oldestItem.value[1].lastAccessed < cutoffDate)) {
      __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(oldestItem.value[0]);
      oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, "f").entries().next();
    }
  };
});

// node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = undefined;
  var events_1 = __require("events");
  var gaxios_1 = require_src3();
  var transporters_1 = require_transporters();
  var util_1 = require_util11();
  exports.DEFAULT_UNIVERSE = "googleapis.com";
  exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;

  class AuthClient extends events_1.EventEmitter {
    constructor(opts = {}) {
      var _a, _b, _c, _d, _e;
      super();
      this.credentials = {};
      this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
      this.forceRefreshOnFailure = false;
      this.universeDomain = exports.DEFAULT_UNIVERSE;
      const options = (0, util_1.originalOrCamelOptions)(opts);
      this.apiKey = opts.apiKey;
      this.projectId = (_a = options.get("project_id")) !== null && _a !== undefined ? _a : null;
      this.quotaProjectId = options.get("quota_project_id");
      this.credentials = (_b = options.get("credentials")) !== null && _b !== undefined ? _b : {};
      this.universeDomain = (_c = options.get("universe_domain")) !== null && _c !== undefined ? _c : exports.DEFAULT_UNIVERSE;
      this.transporter = (_d = opts.transporter) !== null && _d !== undefined ? _d : new transporters_1.DefaultTransporter;
      if (opts.transporterOptions) {
        this.transporter.defaults = opts.transporterOptions;
      }
      if (opts.eagerRefreshThresholdMillis) {
        this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
      }
      this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) !== null && _e !== undefined ? _e : false;
    }
    get gaxios() {
      if (this.transporter instanceof gaxios_1.Gaxios) {
        return this.transporter;
      } else if (this.transporter instanceof transporters_1.DefaultTransporter) {
        return this.transporter.instance;
      } else if ("instance" in this.transporter && this.transporter.instance instanceof gaxios_1.Gaxios) {
        return this.transporter.instance;
      }
      return null;
    }
    setCredentials(credentials) {
      this.credentials = credentials;
    }
    addSharedMetadataHeaders(headers) {
      if (!headers["x-goog-user-project"] && this.quotaProjectId) {
        headers["x-goog-user-project"] = this.quotaProjectId;
      }
      return headers;
    }
    static get RETRY_CONFIG() {
      return {
        retry: true,
        retryConfig: {
          httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
        }
      };
    }
  }
  exports.AuthClient = AuthClient;
});

// node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LoginTicket = undefined;

  class LoginTicket {
    constructor(env, pay) {
      this.envelope = env;
      this.payload = pay;
    }
    getEnvelope() {
      return this.envelope;
    }
    getPayload() {
      return this.payload;
    }
    getUserId() {
      const payload = this.getPayload();
      if (payload && payload.sub) {
        return payload.sub;
      }
      return null;
    }
    getAttributes() {
      return { envelope: this.getEnvelope(), payload: this.getPayload() };
    }
  }
  exports.LoginTicket = LoginTicket;
});

// node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = undefined;
  var gaxios_1 = require_src3();
  var querystring = __require("querystring");
  var stream = __require("stream");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var crypto_1 = require_crypto3();
  var authclient_1 = require_authclient();
  var loginticket_1 = require_loginticket();
  var CodeChallengeMethod;
  (function(CodeChallengeMethod2) {
    CodeChallengeMethod2["Plain"] = "plain";
    CodeChallengeMethod2["S256"] = "S256";
  })(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));
  var CertificateFormat;
  (function(CertificateFormat2) {
    CertificateFormat2["PEM"] = "PEM";
    CertificateFormat2["JWK"] = "JWK";
  })(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));
  var ClientAuthentication;
  (function(ClientAuthentication2) {
    ClientAuthentication2["ClientSecretPost"] = "ClientSecretPost";
    ClientAuthentication2["ClientSecretBasic"] = "ClientSecretBasic";
    ClientAuthentication2["None"] = "None";
  })(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));

  class OAuth2Client extends authclient_1.AuthClient {
    constructor(optionsOrClientId, clientSecret, redirectUri) {
      const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : { clientId: optionsOrClientId, clientSecret, redirectUri };
      super(opts);
      this.certificateCache = {};
      this.certificateExpiry = null;
      this.certificateCacheFormat = CertificateFormat.PEM;
      this.refreshTokenPromises = new Map;
      this._clientId = opts.clientId;
      this._clientSecret = opts.clientSecret;
      this.redirectUri = opts.redirectUri;
      this.endpoints = {
        tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
        oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
        oauth2TokenUrl: "https://oauth2.googleapis.com/token",
        oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
        oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
        oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
        oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
        ...opts.endpoints
      };
      this.clientAuthentication = opts.clientAuthentication || ClientAuthentication.ClientSecretPost;
      this.issuers = opts.issuers || [
        "accounts.google.com",
        "https://accounts.google.com",
        this.universeDomain
      ];
    }
    generateAuthUrl(opts = {}) {
      if (opts.code_challenge_method && !opts.code_challenge) {
        throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
      }
      opts.response_type = opts.response_type || "code";
      opts.client_id = opts.client_id || this._clientId;
      opts.redirect_uri = opts.redirect_uri || this.redirectUri;
      if (Array.isArray(opts.scope)) {
        opts.scope = opts.scope.join(" ");
      }
      const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();
      return rootUrl + "?" + querystring.stringify(opts);
    }
    generateCodeVerifier() {
      throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
    }
    async generateCodeVerifierAsync() {
      const crypto2 = (0, crypto_1.createCrypto)();
      const randomString = crypto2.randomBytesBase64(96);
      const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
      const unencodedCodeChallenge = await crypto2.sha256DigestBase64(codeVerifier);
      const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
      return { codeVerifier, codeChallenge };
    }
    getToken(codeOrOptions, callback) {
      const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
      if (callback) {
        this.getTokenAsync(options).then((r) => callback(null, r.tokens, r.res), (e) => callback(e, null, e.response));
      } else {
        return this.getTokenAsync(options);
      }
    }
    async getTokenAsync(options) {
      const url = this.endpoints.oauth2TokenUrl.toString();
      const headers = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      const values = {
        client_id: options.client_id || this._clientId,
        code_verifier: options.codeVerifier,
        code: options.code,
        grant_type: "authorization_code",
        redirect_uri: options.redirect_uri || this.redirectUri
      };
      if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
        const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
        headers["Authorization"] = `Basic ${basic.toString("base64")}`;
      }
      if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {
        values.client_secret = this._clientSecret;
      }
      const res = await this.transporter.request({
        ...OAuth2Client.RETRY_CONFIG,
        method: "POST",
        url,
        data: querystring.stringify(values),
        headers
      });
      const tokens = res.data;
      if (res.data && res.data.expires_in) {
        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return { tokens, res };
    }
    async refreshToken(refreshToken) {
      if (!refreshToken) {
        return this.refreshTokenNoCache(refreshToken);
      }
      if (this.refreshTokenPromises.has(refreshToken)) {
        return this.refreshTokenPromises.get(refreshToken);
      }
      const p = this.refreshTokenNoCache(refreshToken).then((r) => {
        this.refreshTokenPromises.delete(refreshToken);
        return r;
      }, (e) => {
        this.refreshTokenPromises.delete(refreshToken);
        throw e;
      });
      this.refreshTokenPromises.set(refreshToken, p);
      return p;
    }
    async refreshTokenNoCache(refreshToken) {
      var _a;
      if (!refreshToken) {
        throw new Error("No refresh token is set.");
      }
      const url = this.endpoints.oauth2TokenUrl.toString();
      const data = {
        refresh_token: refreshToken,
        client_id: this._clientId,
        client_secret: this._clientSecret,
        grant_type: "refresh_token"
      };
      let res;
      try {
        res = await this.transporter.request({
          ...OAuth2Client.RETRY_CONFIG,
          method: "POST",
          url,
          data: querystring.stringify(data),
          headers: { "Content-Type": "application/x-www-form-urlencoded" }
        });
      } catch (e) {
        if (e instanceof gaxios_1.GaxiosError && e.message === "invalid_grant" && ((_a = e.response) === null || _a === undefined ? undefined : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {
          e.message = JSON.stringify(e.response.data);
        }
        throw e;
      }
      const tokens = res.data;
      if (res.data && res.data.expires_in) {
        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return { tokens, res };
    }
    refreshAccessToken(callback) {
      if (callback) {
        this.refreshAccessTokenAsync().then((r) => callback(null, r.credentials, r.res), callback);
      } else {
        return this.refreshAccessTokenAsync();
      }
    }
    async refreshAccessTokenAsync() {
      const r = await this.refreshToken(this.credentials.refresh_token);
      const tokens = r.tokens;
      tokens.refresh_token = this.credentials.refresh_token;
      this.credentials = tokens;
      return { credentials: this.credentials, res: r.res };
    }
    getAccessToken(callback) {
      if (callback) {
        this.getAccessTokenAsync().then((r) => callback(null, r.token, r.res), callback);
      } else {
        return this.getAccessTokenAsync();
      }
    }
    async getAccessTokenAsync() {
      const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
      if (shouldRefresh) {
        if (!this.credentials.refresh_token) {
          if (this.refreshHandler) {
            const refreshedAccessToken = await this.processAndValidateRefreshHandler();
            if (refreshedAccessToken === null || refreshedAccessToken === undefined ? undefined : refreshedAccessToken.access_token) {
              this.setCredentials(refreshedAccessToken);
              return { token: this.credentials.access_token };
            }
          } else {
            throw new Error("No refresh token or refresh handler callback is set.");
          }
        }
        const r = await this.refreshAccessTokenAsync();
        if (!r.credentials || r.credentials && !r.credentials.access_token) {
          throw new Error("Could not refresh access token.");
        }
        return { token: r.credentials.access_token, res: r.res };
      } else {
        return { token: this.credentials.access_token };
      }
    }
    async getRequestHeaders(url) {
      const headers = (await this.getRequestMetadataAsync(url)).headers;
      return headers;
    }
    async getRequestMetadataAsync(url) {
      const thisCreds = this.credentials;
      if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {
        throw new Error("No access, refresh token, API key or refresh handler callback is set.");
      }
      if (thisCreds.access_token && !this.isTokenExpiring()) {
        thisCreds.token_type = thisCreds.token_type || "Bearer";
        const headers2 = {
          Authorization: thisCreds.token_type + " " + thisCreds.access_token
        };
        return { headers: this.addSharedMetadataHeaders(headers2) };
      }
      if (this.refreshHandler) {
        const refreshedAccessToken = await this.processAndValidateRefreshHandler();
        if (refreshedAccessToken === null || refreshedAccessToken === undefined ? undefined : refreshedAccessToken.access_token) {
          this.setCredentials(refreshedAccessToken);
          const headers2 = {
            Authorization: "Bearer " + this.credentials.access_token
          };
          return { headers: this.addSharedMetadataHeaders(headers2) };
        }
      }
      if (this.apiKey) {
        return { headers: { "X-Goog-Api-Key": this.apiKey } };
      }
      let r = null;
      let tokens = null;
      try {
        r = await this.refreshToken(thisCreds.refresh_token);
        tokens = r.tokens;
      } catch (err) {
        const e = err;
        if (e.response && (e.response.status === 403 || e.response.status === 404)) {
          e.message = `Could not refresh access token: ${e.message}`;
        }
        throw e;
      }
      const credentials = this.credentials;
      credentials.token_type = credentials.token_type || "Bearer";
      tokens.refresh_token = credentials.refresh_token;
      this.credentials = tokens;
      const headers = {
        Authorization: credentials.token_type + " " + tokens.access_token
      };
      return { headers: this.addSharedMetadataHeaders(headers), res: r.res };
    }
    static getRevokeTokenUrl(token) {
      return new OAuth2Client().getRevokeTokenURL(token).toString();
    }
    getRevokeTokenURL(token) {
      const url = new URL(this.endpoints.oauth2RevokeUrl);
      url.searchParams.append("token", token);
      return url;
    }
    revokeToken(token, callback) {
      const opts = {
        ...OAuth2Client.RETRY_CONFIG,
        url: this.getRevokeTokenURL(token).toString(),
        method: "POST"
      };
      if (callback) {
        this.transporter.request(opts).then((r) => callback(null, r), callback);
      } else {
        return this.transporter.request(opts);
      }
    }
    revokeCredentials(callback) {
      if (callback) {
        this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
      } else {
        return this.revokeCredentialsAsync();
      }
    }
    async revokeCredentialsAsync() {
      const token = this.credentials.access_token;
      this.credentials = {};
      if (token) {
        return this.revokeToken(token);
      } else {
        throw new Error("No access token to revoke.");
      }
    }
    request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then((r) => callback(null, r), (e) => {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    async requestAsync(opts, reAuthRetried = false) {
      let r2;
      try {
        const r = await this.getRequestMetadataAsync(opts.url);
        opts.headers = opts.headers || {};
        if (r.headers && r.headers["x-goog-user-project"]) {
          opts.headers["x-goog-user-project"] = r.headers["x-goog-user-project"];
        }
        if (r.headers && r.headers.Authorization) {
          opts.headers.Authorization = r.headers.Authorization;
        }
        if (this.apiKey) {
          opts.headers["X-Goog-Api-Key"] = this.apiKey;
        }
        r2 = await this.transporter.request(opts);
      } catch (e) {
        const res = e.response;
        if (res) {
          const statusCode = res.status;
          const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
          const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
          const isReadableStream = res.config.data instanceof stream.Readable;
          const isAuthErr = statusCode === 401 || statusCode === 403;
          if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
            await this.refreshAccessTokenAsync();
            return this.requestAsync(opts, true);
          } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
            const refreshedAccessToken = await this.processAndValidateRefreshHandler();
            if (refreshedAccessToken === null || refreshedAccessToken === undefined ? undefined : refreshedAccessToken.access_token) {
              this.setCredentials(refreshedAccessToken);
            }
            return this.requestAsync(opts, true);
          }
        }
        throw e;
      }
      return r2;
    }
    verifyIdToken(options, callback) {
      if (callback && typeof callback !== "function") {
        throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
      }
      if (callback) {
        this.verifyIdTokenAsync(options).then((r) => callback(null, r), callback);
      } else {
        return this.verifyIdTokenAsync(options);
      }
    }
    async verifyIdTokenAsync(options) {
      if (!options.idToken) {
        throw new Error("The verifyIdToken method requires an ID Token");
      }
      const response = await this.getFederatedSignonCertsAsync();
      const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
      return login;
    }
    async getTokenInfo(accessToken) {
      const { data } = await this.transporter.request({
        ...OAuth2Client.RETRY_CONFIG,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${accessToken}`
        },
        url: this.endpoints.tokenInfoUrl.toString()
      });
      const info = Object.assign({
        expiry_date: new Date().getTime() + data.expires_in * 1000,
        scopes: data.scope.split(" ")
      }, data);
      delete info.expires_in;
      delete info.scope;
      return info;
    }
    getFederatedSignonCerts(callback) {
      if (callback) {
        this.getFederatedSignonCertsAsync().then((r) => callback(null, r.certs, r.res), callback);
      } else {
        return this.getFederatedSignonCertsAsync();
      }
    }
    async getFederatedSignonCertsAsync() {
      const nowTime = new Date().getTime();
      const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
      if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {
        return { certs: this.certificateCache, format };
      }
      let res;
      let url;
      switch (format) {
        case CertificateFormat.PEM:
          url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
          break;
        case CertificateFormat.JWK:
          url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
          break;
        default:
          throw new Error(`Unsupported certificate format ${format}`);
      }
      try {
        res = await this.transporter.request({
          ...OAuth2Client.RETRY_CONFIG,
          url
        });
      } catch (e) {
        if (e instanceof Error) {
          e.message = `Failed to retrieve verification certificates: ${e.message}`;
        }
        throw e;
      }
      const cacheControl = res ? res.headers["cache-control"] : undefined;
      let cacheAge = -1;
      if (cacheControl) {
        const pattern = new RegExp("max-age=([0-9]*)");
        const regexResult = pattern.exec(cacheControl);
        if (regexResult && regexResult.length === 2) {
          cacheAge = Number(regexResult[1]) * 1000;
        }
      }
      let certificates = {};
      switch (format) {
        case CertificateFormat.PEM:
          certificates = res.data;
          break;
        case CertificateFormat.JWK:
          for (const key of res.data.keys) {
            certificates[key.kid] = key;
          }
          break;
        default:
          throw new Error(`Unsupported certificate format ${format}`);
      }
      const now = new Date;
      this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
      this.certificateCache = certificates;
      this.certificateCacheFormat = format;
      return { certs: certificates, format, res };
    }
    getIapPublicKeys(callback) {
      if (callback) {
        this.getIapPublicKeysAsync().then((r) => callback(null, r.pubkeys, r.res), callback);
      } else {
        return this.getIapPublicKeysAsync();
      }
    }
    async getIapPublicKeysAsync() {
      let res;
      const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
      try {
        res = await this.transporter.request({
          ...OAuth2Client.RETRY_CONFIG,
          url
        });
      } catch (e) {
        if (e instanceof Error) {
          e.message = `Failed to retrieve verification certificates: ${e.message}`;
        }
        throw e;
      }
      return { pubkeys: res.data, res };
    }
    verifySignedJwtWithCerts() {
      throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
    }
    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
      const crypto2 = (0, crypto_1.createCrypto)();
      if (!maxExpiry) {
        maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
      }
      const segments = jwt.split(".");
      if (segments.length !== 3) {
        throw new Error("Wrong number of segments in token: " + jwt);
      }
      const signed = segments[0] + "." + segments[1];
      let signature = segments[2];
      let envelope;
      let payload;
      try {
        envelope = JSON.parse(crypto2.decodeBase64StringUtf8(segments[0]));
      } catch (err) {
        if (err instanceof Error) {
          err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
        }
        throw err;
      }
      if (!envelope) {
        throw new Error("Can't parse token envelope: " + segments[0]);
      }
      try {
        payload = JSON.parse(crypto2.decodeBase64StringUtf8(segments[1]));
      } catch (err) {
        if (err instanceof Error) {
          err.message = `Can't parse token payload '${segments[0]}`;
        }
        throw err;
      }
      if (!payload) {
        throw new Error("Can't parse token payload: " + segments[1]);
      }
      if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
        throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
      }
      const cert = certs[envelope.kid];
      if (envelope.alg === "ES256") {
        signature = formatEcdsa.joseToDer(signature, "ES256").toString("base64");
      }
      const verified = await crypto2.verify(cert, signed, signature);
      if (!verified) {
        throw new Error("Invalid token signature: " + jwt);
      }
      if (!payload.iat) {
        throw new Error("No issue time in token: " + JSON.stringify(payload));
      }
      if (!payload.exp) {
        throw new Error("No expiration time in token: " + JSON.stringify(payload));
      }
      const iat = Number(payload.iat);
      if (isNaN(iat))
        throw new Error("iat field using invalid format");
      const exp = Number(payload.exp);
      if (isNaN(exp))
        throw new Error("exp field using invalid format");
      const now = new Date().getTime() / 1000;
      if (exp >= now + maxExpiry) {
        throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
      }
      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
      if (now < earliest) {
        throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
      }
      if (now > latest) {
        throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
      }
      if (issuers && issuers.indexOf(payload.iss) < 0) {
        throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
      }
      if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
        const aud = payload.aud;
        let audVerified = false;
        if (requiredAudience.constructor === Array) {
          audVerified = requiredAudience.indexOf(aud) > -1;
        } else {
          audVerified = aud === requiredAudience;
        }
        if (!audVerified) {
          throw new Error("Wrong recipient, payload audience != requiredAudience");
        }
      }
      return new loginticket_1.LoginTicket(envelope, payload);
    }
    async processAndValidateRefreshHandler() {
      if (this.refreshHandler) {
        const accessTokenResponse = await this.refreshHandler();
        if (!accessTokenResponse.access_token) {
          throw new Error("No access token is returned by the refreshHandler callback.");
        }
        return accessTokenResponse;
      }
      return;
    }
    isTokenExpiring() {
      const expiryDate = this.credentials.expiry_date;
      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;
    }
  }
  exports.OAuth2Client = OAuth2Client;
  OAuth2Client.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
  OAuth2Client.CLOCK_SKEW_SECS_ = 300;
  OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
});

// node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Compute = undefined;
  var gaxios_1 = require_src3();
  var gcpMetadata = require_src5();
  var oauth2client_1 = require_oauth2client();

  class Compute extends oauth2client_1.OAuth2Client {
    constructor(options = {}) {
      super(options);
      this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" };
      this.serviceAccountEmail = options.serviceAccountEmail || "default";
      this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
    }
    async refreshTokenNoCache(refreshToken) {
      const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
      let data;
      try {
        const instanceOptions = {
          property: tokenPath
        };
        if (this.scopes.length > 0) {
          instanceOptions.params = {
            scopes: this.scopes.join(",")
          };
        }
        data = await gcpMetadata.instance(instanceOptions);
      } catch (e) {
        if (e instanceof gaxios_1.GaxiosError) {
          e.message = `Could not refresh access token: ${e.message}`;
          this.wrapError(e);
        }
        throw e;
      }
      const tokens = data;
      if (data && data.expires_in) {
        tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return { tokens, res: null };
    }
    async fetchIdToken(targetAudience) {
      const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` + `?format=full&audience=${targetAudience}`;
      let idToken;
      try {
        const instanceOptions = {
          property: idTokenPath
        };
        idToken = await gcpMetadata.instance(instanceOptions);
      } catch (e) {
        if (e instanceof Error) {
          e.message = `Could not fetch ID token: ${e.message}`;
        }
        throw e;
      }
      return idToken;
    }
    wrapError(e) {
      const res = e.response;
      if (res && res.status) {
        e.status = res.status;
        if (res.status === 403) {
          e.message = "A Forbidden error was returned while attempting to retrieve an access " + "token for the Compute Engine built-in service account. This may be because the Compute " + "Engine instance does not have the correct permission scopes specified: " + e.message;
        } else if (res.status === 404) {
          e.message = "A Not Found error was returned while attempting to retrieve an access" + "token for the Compute Engine built-in service account. This may be because the Compute " + "Engine instance does not have any permission scopes specified: " + e.message;
        }
      }
    }
  }
  exports.Compute = Compute;
});

// node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IdTokenClient = undefined;
  var oauth2client_1 = require_oauth2client();

  class IdTokenClient extends oauth2client_1.OAuth2Client {
    constructor(options) {
      super(options);
      this.targetAudience = options.targetAudience;
      this.idTokenProvider = options.idTokenProvider;
    }
    async getRequestMetadataAsync(url) {
      if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
        const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
        this.credentials = {
          id_token: idToken,
          expiry_date: this.getIdTokenExpiryDate(idToken)
        };
      }
      const headers = {
        Authorization: "Bearer " + this.credentials.id_token
      };
      return { headers };
    }
    getIdTokenExpiryDate(idToken) {
      const payloadB64 = idToken.split(".")[1];
      if (payloadB64) {
        const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
        return payload.exp * 1000;
      }
    }
  }
  exports.IdTokenClient = IdTokenClient;
});

// node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GCPEnv = undefined;
  exports.clear = clear;
  exports.getEnv = getEnv;
  var gcpMetadata = require_src5();
  var GCPEnv;
  (function(GCPEnv2) {
    GCPEnv2["APP_ENGINE"] = "APP_ENGINE";
    GCPEnv2["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
    GCPEnv2["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
    GCPEnv2["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
    GCPEnv2["CLOUD_RUN"] = "CLOUD_RUN";
    GCPEnv2["NONE"] = "NONE";
  })(GCPEnv || (exports.GCPEnv = GCPEnv = {}));
  var envPromise;
  function clear() {
    envPromise = undefined;
  }
  async function getEnv() {
    if (envPromise) {
      return envPromise;
    }
    envPromise = getEnvMemoized();
    return envPromise;
  }
  async function getEnvMemoized() {
    let env = GCPEnv.NONE;
    if (isAppEngine()) {
      env = GCPEnv.APP_ENGINE;
    } else if (isCloudFunction()) {
      env = GCPEnv.CLOUD_FUNCTIONS;
    } else if (await isComputeEngine()) {
      if (await isKubernetesEngine()) {
        env = GCPEnv.KUBERNETES_ENGINE;
      } else if (isCloudRun()) {
        env = GCPEnv.CLOUD_RUN;
      } else {
        env = GCPEnv.COMPUTE_ENGINE;
      }
    } else {
      env = GCPEnv.NONE;
    }
    return env;
  }
  function isAppEngine() {
    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
  }
  function isCloudFunction() {
    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
  }
  function isCloudRun() {
    return !!process.env.K_CONFIGURATION;
  }
  async function isKubernetesEngine() {
    try {
      await gcpMetadata.instance("attributes/cluster-name");
      return true;
    } catch (e) {
      return false;
    }
  }
  async function isComputeEngine() {
    return gcpMetadata.isAvailable();
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = __require("stream");
  var util = __require("util");
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var SlowBuffer = __require("buffer").SlowBuffer;
  module.exports = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0;i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = __require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = __require("util");
  var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0;i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  var bufferEqual;
  var timingSafeEqual = "timingSafeEqual" in crypto2 ? function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return crypto2.timingSafeEqual(a, b);
  } : function timingSafeEqual(a, b) {
    if (!bufferEqual) {
      bufferEqual = require_buffer_equal_constant_time();
    }
    return bufferEqual(a, b);
  };
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  function base64url(string, encoding) {
    return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/gtoken/build/src/index.js
var require_src6 = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _GoogleToken_instances;
  var _GoogleToken_inFlightRequest;
  var _GoogleToken_getTokenAsync;
  var _GoogleToken_getTokenAsyncInner;
  var _GoogleToken_ensureEmail;
  var _GoogleToken_revokeTokenAsync;
  var _GoogleToken_configure;
  var _GoogleToken_requestToken;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GoogleToken = undefined;
  var fs = __require("fs");
  var gaxios_1 = require_src3();
  var jws = require_jws();
  var path = __require("path");
  var util_1 = __require("util");
  var readFile = fs.readFile ? (0, util_1.promisify)(fs.readFile) : async () => {
    throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
  };
  var GOOGLE_TOKEN_URL = "https://www.googleapis.com/oauth2/v4/token";
  var GOOGLE_REVOKE_TOKEN_URL = "https://accounts.google.com/o/oauth2/revoke?token=";

  class ErrorWithCode extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  }

  class GoogleToken {
    get accessToken() {
      return this.rawToken ? this.rawToken.access_token : undefined;
    }
    get idToken() {
      return this.rawToken ? this.rawToken.id_token : undefined;
    }
    get tokenType() {
      return this.rawToken ? this.rawToken.token_type : undefined;
    }
    get refreshToken() {
      return this.rawToken ? this.rawToken.refresh_token : undefined;
    }
    constructor(options) {
      _GoogleToken_instances.add(this);
      this.transporter = {
        request: (opts) => (0, gaxios_1.request)(opts)
      };
      _GoogleToken_inFlightRequest.set(this, undefined);
      __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, options);
    }
    hasExpired() {
      const now = new Date().getTime();
      if (this.rawToken && this.expiresAt) {
        return now >= this.expiresAt;
      } else {
        return true;
      }
    }
    isTokenExpiring() {
      var _a;
      const now = new Date().getTime();
      const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== undefined ? _a : 0;
      if (this.rawToken && this.expiresAt) {
        return this.expiresAt <= now + eagerRefreshThresholdMillis;
      } else {
        return true;
      }
    }
    getToken(callback, opts = {}) {
      if (typeof callback === "object") {
        opts = callback;
        callback = undefined;
      }
      opts = Object.assign({
        forceRefresh: false
      }, opts);
      if (callback) {
        const cb = callback;
        __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts).then((t) => cb(null, t), callback);
        return;
      }
      return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts);
    }
    async getCredentials(keyFile) {
      const ext = path.extname(keyFile);
      switch (ext) {
        case ".json": {
          const key = await readFile(keyFile, "utf8");
          const body = JSON.parse(key);
          const privateKey = body.private_key;
          const clientEmail = body.client_email;
          if (!privateKey || !clientEmail) {
            throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
          }
          return { privateKey, clientEmail };
        }
        case ".der":
        case ".crt":
        case ".pem": {
          const privateKey = await readFile(keyFile, "utf8");
          return { privateKey };
        }
        case ".p12":
        case ".pfx": {
          throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. " + "Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
        }
        default:
          throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. " + "Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
      }
    }
    revokeToken(callback) {
      if (callback) {
        __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this).then(() => callback(), callback);
        return;
      }
      return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this);
    }
  }
  exports.GoogleToken = GoogleToken;
  _GoogleToken_inFlightRequest = new WeakMap, _GoogleToken_instances = new WeakSet, _GoogleToken_getTokenAsync = async function _GoogleToken_getTokenAsync(opts) {
    if (__classPrivateFieldGet(this, _GoogleToken_inFlightRequest, "f") && !opts.forceRefresh) {
      return __classPrivateFieldGet(this, _GoogleToken_inFlightRequest, "f");
    }
    try {
      return await __classPrivateFieldSet(this, _GoogleToken_inFlightRequest, __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsyncInner).call(this, opts), "f");
    } finally {
      __classPrivateFieldSet(this, _GoogleToken_inFlightRequest, undefined, "f");
    }
  }, _GoogleToken_getTokenAsyncInner = async function _GoogleToken_getTokenAsyncInner(opts) {
    if (this.isTokenExpiring() === false && opts.forceRefresh === false) {
      return Promise.resolve(this.rawToken);
    }
    if (!this.key && !this.keyFile) {
      throw new Error("No key or keyFile set.");
    }
    if (!this.key && this.keyFile) {
      const creds = await this.getCredentials(this.keyFile);
      this.key = creds.privateKey;
      this.iss = creds.clientEmail || this.iss;
      if (!creds.clientEmail) {
        __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_ensureEmail).call(this);
      }
    }
    return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_requestToken).call(this);
  }, _GoogleToken_ensureEmail = function _GoogleToken_ensureEmail() {
    if (!this.iss) {
      throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
    }
  }, _GoogleToken_revokeTokenAsync = async function _GoogleToken_revokeTokenAsync() {
    if (!this.accessToken) {
      throw new Error("No token to revoke.");
    }
    const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
    await this.transporter.request({
      url,
      retry: true
    });
    __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, {
      email: this.iss,
      sub: this.sub,
      key: this.key,
      keyFile: this.keyFile,
      scope: this.scope,
      additionalClaims: this.additionalClaims
    });
  }, _GoogleToken_configure = function _GoogleToken_configure(options = {}) {
    this.keyFile = options.keyFile;
    this.key = options.key;
    this.rawToken = undefined;
    this.iss = options.email || options.iss;
    this.sub = options.sub;
    this.additionalClaims = options.additionalClaims;
    if (typeof options.scope === "object") {
      this.scope = options.scope.join(" ");
    } else {
      this.scope = options.scope;
    }
    this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
    if (options.transporter) {
      this.transporter = options.transporter;
    }
  }, _GoogleToken_requestToken = async function _GoogleToken_requestToken() {
    var _a, _b;
    const iat = Math.floor(new Date().getTime() / 1000);
    const additionalClaims = this.additionalClaims || {};
    const payload = Object.assign({
      iss: this.iss,
      scope: this.scope,
      aud: GOOGLE_TOKEN_URL,
      exp: iat + 3600,
      iat,
      sub: this.sub
    }, additionalClaims);
    const signedJWT = jws.sign({
      header: { alg: "RS256" },
      payload,
      secret: this.key
    });
    try {
      const r = await this.transporter.request({
        method: "POST",
        url: GOOGLE_TOKEN_URL,
        data: {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: signedJWT
        },
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        responseType: "json",
        retryConfig: {
          httpMethodsToRetry: ["POST"]
        }
      });
      this.rawToken = r.data;
      this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;
      return this.rawToken;
    } catch (e) {
      this.rawToken = undefined;
      this.tokenExpires = undefined;
      const body = e.response && ((_a = e.response) === null || _a === undefined ? undefined : _a.data) ? (_b = e.response) === null || _b === undefined ? undefined : _b.data : {};
      if (body.error) {
        const desc = body.error_description ? `: ${body.error_description}` : "";
        e.message = `${body.error}${desc}`;
      }
      throw e;
    }
  };
});

// node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JWTAccess = undefined;
  var jws = require_jws();
  var util_1 = require_util11();
  var DEFAULT_HEADER = {
    alg: "RS256",
    typ: "JWT"
  };

  class JWTAccess {
    constructor(email, key, keyId, eagerRefreshThresholdMillis) {
      this.cache = new util_1.LRUCache({
        capacity: 500,
        maxAge: 60 * 60 * 1000
      });
      this.email = email;
      this.key = key;
      this.keyId = keyId;
      this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== undefined ? eagerRefreshThresholdMillis : 5 * 60 * 1000;
    }
    getCachedKey(url, scopes) {
      let cacheKey = url;
      if (scopes && Array.isArray(scopes) && scopes.length) {
        cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
      } else if (typeof scopes === "string") {
        cacheKey = url ? `${url}_${scopes}` : scopes;
      }
      if (!cacheKey) {
        throw Error("Scopes or url must be provided");
      }
      return cacheKey;
    }
    getRequestHeaders(url, additionalClaims, scopes) {
      const key = this.getCachedKey(url, scopes);
      const cachedToken = this.cache.get(key);
      const now = Date.now();
      if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {
        return cachedToken.headers;
      }
      const iat = Math.floor(Date.now() / 1000);
      const exp = JWTAccess.getExpirationTime(iat);
      let defaultClaims;
      if (Array.isArray(scopes)) {
        scopes = scopes.join(" ");
      }
      if (scopes) {
        defaultClaims = {
          iss: this.email,
          sub: this.email,
          scope: scopes,
          exp,
          iat
        };
      } else {
        defaultClaims = {
          iss: this.email,
          sub: this.email,
          aud: url,
          exp,
          iat
        };
      }
      if (additionalClaims) {
        for (const claim in defaultClaims) {
          if (additionalClaims[claim]) {
            throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
          }
        }
      }
      const header = this.keyId ? { ...DEFAULT_HEADER, kid: this.keyId } : DEFAULT_HEADER;
      const payload = Object.assign(defaultClaims, additionalClaims);
      const signedJWT = jws.sign({ header, payload, secret: this.key });
      const headers = { Authorization: `Bearer ${signedJWT}` };
      this.cache.set(key, {
        expiration: exp * 1000,
        headers
      });
      return headers;
    }
    static getExpirationTime(iat) {
      const exp = iat + 3600;
      return exp;
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the service account auth settings.");
      }
      if (!json.client_email) {
        throw new Error("The incoming JSON object does not contain a client_email field");
      }
      if (!json.private_key) {
        throw new Error("The incoming JSON object does not contain a private_key field");
      }
      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          reject(new Error("Must pass in a stream containing the service account auth settings."));
        }
        let s = "";
        inputStream.setEncoding("utf8").on("data", (chunk) => s += chunk).on("error", reject).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            resolve();
          } catch (err) {
            reject(err);
          }
        });
      });
    }
  }
  exports.JWTAccess = JWTAccess;
});

// node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JWT = undefined;
  var gtoken_1 = require_src6();
  var jwtaccess_1 = require_jwtaccess();
  var oauth2client_1 = require_oauth2client();
  var authclient_1 = require_authclient();

  class JWT extends oauth2client_1.OAuth2Client {
    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
      const opts = optionsOrEmail && typeof optionsOrEmail === "object" ? optionsOrEmail : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };
      super(opts);
      this.email = opts.email;
      this.keyFile = opts.keyFile;
      this.key = opts.key;
      this.keyId = opts.keyId;
      this.scopes = opts.scopes;
      this.subject = opts.subject;
      this.additionalClaims = opts.additionalClaims;
      this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
    }
    createScoped(scopes) {
      const jwt = new JWT(this);
      jwt.scopes = scopes;
      return jwt;
    }
    async getRequestMetadataAsync(url) {
      url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
      const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
      if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {
        throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);
      }
      if (!this.apiKey && useSelfSignedJWT) {
        if (this.additionalClaims && this.additionalClaims.target_audience) {
          const { tokens } = await this.refreshToken();
          return {
            headers: this.addSharedMetadataHeaders({
              Authorization: `Bearer ${tokens.id_token}`
            })
          };
        } else {
          if (!this.access) {
            this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
          }
          let scopes;
          if (this.hasUserScopes()) {
            scopes = this.scopes;
          } else if (!url) {
            scopes = this.defaultScopes;
          }
          const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
          const headers = await this.access.getRequestHeaders(url !== null && url !== undefined ? url : undefined, this.additionalClaims, useScopes ? scopes : undefined);
          return { headers: this.addSharedMetadataHeaders(headers) };
        }
      } else if (this.hasAnyScopes() || this.apiKey) {
        return super.getRequestMetadataAsync(url);
      } else {
        return { headers: {} };
      }
    }
    async fetchIdToken(targetAudience) {
      const gtoken = new gtoken_1.GoogleToken({
        iss: this.email,
        sub: this.subject,
        scope: this.scopes || this.defaultScopes,
        keyFile: this.keyFile,
        key: this.key,
        additionalClaims: { target_audience: targetAudience },
        transporter: this.transporter
      });
      await gtoken.getToken({
        forceRefresh: true
      });
      if (!gtoken.idToken) {
        throw new Error("Unknown error: Failed to fetch ID token");
      }
      return gtoken.idToken;
    }
    hasUserScopes() {
      if (!this.scopes) {
        return false;
      }
      return this.scopes.length > 0;
    }
    hasAnyScopes() {
      if (this.scopes && this.scopes.length > 0)
        return true;
      if (this.defaultScopes && this.defaultScopes.length > 0)
        return true;
      return false;
    }
    authorize(callback) {
      if (callback) {
        this.authorizeAsync().then((r) => callback(null, r), callback);
      } else {
        return this.authorizeAsync();
      }
    }
    async authorizeAsync() {
      const result = await this.refreshToken();
      if (!result) {
        throw new Error("No result returned");
      }
      this.credentials = result.tokens;
      this.credentials.refresh_token = "jwt-placeholder";
      this.key = this.gtoken.key;
      this.email = this.gtoken.iss;
      return result.tokens;
    }
    async refreshTokenNoCache(refreshToken) {
      const gtoken = this.createGToken();
      const token = await gtoken.getToken({
        forceRefresh: this.isTokenExpiring()
      });
      const tokens = {
        access_token: token.access_token,
        token_type: "Bearer",
        expiry_date: gtoken.expiresAt,
        id_token: gtoken.idToken
      };
      this.emit("tokens", tokens);
      return { res: null, tokens };
    }
    createGToken() {
      if (!this.gtoken) {
        this.gtoken = new gtoken_1.GoogleToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes || this.defaultScopes,
          keyFile: this.keyFile,
          key: this.key,
          additionalClaims: this.additionalClaims,
          transporter: this.transporter
        });
      }
      return this.gtoken;
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the service account auth settings.");
      }
      if (!json.client_email) {
        throw new Error("The incoming JSON object does not contain a client_email field");
      }
      if (!json.private_key) {
        throw new Error("The incoming JSON object does not contain a private_key field");
      }
      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
      this.quotaProjectId = json.quota_project_id;
      this.universeDomain = json.universe_domain || this.universeDomain;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          throw new Error("Must pass in a stream containing the service account auth settings.");
        }
        let s = "";
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            resolve();
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    fromAPIKey(apiKey) {
      if (typeof apiKey !== "string") {
        throw new Error("Must provide an API Key string.");
      }
      this.apiKey = apiKey;
    }
    async getCredentials() {
      if (this.key) {
        return { private_key: this.key, client_email: this.email };
      } else if (this.keyFile) {
        const gtoken = this.createGToken();
        const creds = await gtoken.getCredentials(this.keyFile);
        return { private_key: creds.privateKey, client_email: creds.clientEmail };
      }
      throw new Error("A key or a keyFile must be provided to getCredentials.");
    }
  }
  exports.JWT = JWT;
});

// node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = undefined;
  var oauth2client_1 = require_oauth2client();
  var querystring_1 = __require("querystring");
  exports.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";

  class UserRefreshClient extends oauth2client_1.OAuth2Client {
    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
      const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
        clientId: optionsOrClientId,
        clientSecret,
        refreshToken,
        eagerRefreshThresholdMillis,
        forceRefreshOnFailure
      };
      super(opts);
      this._refreshToken = opts.refreshToken;
      this.credentials.refresh_token = opts.refreshToken;
    }
    async refreshTokenNoCache(refreshToken) {
      return super.refreshTokenNoCache(this._refreshToken);
    }
    async fetchIdToken(targetAudience) {
      const res = await this.transporter.request({
        ...UserRefreshClient.RETRY_CONFIG,
        url: this.endpoints.oauth2TokenUrl,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        method: "POST",
        data: (0, querystring_1.stringify)({
          client_id: this._clientId,
          client_secret: this._clientSecret,
          grant_type: "refresh_token",
          refresh_token: this._refreshToken,
          target_audience: targetAudience
        })
      });
      return res.data.id_token;
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the user refresh token");
      }
      if (json.type !== "authorized_user") {
        throw new Error('The incoming JSON object does not have the "authorized_user" type');
      }
      if (!json.client_id) {
        throw new Error("The incoming JSON object does not contain a client_id field");
      }
      if (!json.client_secret) {
        throw new Error("The incoming JSON object does not contain a client_secret field");
      }
      if (!json.refresh_token) {
        throw new Error("The incoming JSON object does not contain a refresh_token field");
      }
      this._clientId = json.client_id;
      this._clientSecret = json.client_secret;
      this._refreshToken = json.refresh_token;
      this.credentials.refresh_token = json.refresh_token;
      this.quotaProjectId = json.quota_project_id;
      this.universeDomain = json.universe_domain || this.universeDomain;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    async fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          return reject(new Error("Must pass in a stream containing the user refresh token."));
        }
        let s = "";
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            return resolve();
          } catch (err) {
            return reject(err);
          }
        });
      });
    }
    static fromJSON(json) {
      const client = new UserRefreshClient;
      client.fromJSON(json);
      return client;
    }
  }
  exports.UserRefreshClient = UserRefreshClient;
});

// node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = undefined;
  var oauth2client_1 = require_oauth2client();
  var gaxios_1 = require_src3();
  var util_1 = require_util11();
  exports.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";

  class Impersonated extends oauth2client_1.OAuth2Client {
    constructor(options = {}) {
      var _a, _b, _c, _d, _e, _f;
      super(options);
      this.credentials = {
        expiry_date: 1,
        refresh_token: "impersonated-placeholder"
      };
      this.sourceClient = (_a = options.sourceClient) !== null && _a !== undefined ? _a : new oauth2client_1.OAuth2Client;
      this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== undefined ? _b : "";
      this.delegates = (_c = options.delegates) !== null && _c !== undefined ? _c : [];
      this.targetScopes = (_d = options.targetScopes) !== null && _d !== undefined ? _d : [];
      this.lifetime = (_e = options.lifetime) !== null && _e !== undefined ? _e : 3600;
      const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get("universe_domain");
      if (!usingExplicitUniverseDomain) {
        this.universeDomain = this.sourceClient.universeDomain;
      } else if (this.sourceClient.universeDomain !== this.universeDomain) {
        throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
      }
      this.endpoint = (_f = options.endpoint) !== null && _f !== undefined ? _f : `https://iamcredentials.${this.universeDomain}`;
    }
    async sign(blobToSign) {
      await this.sourceClient.getAccessToken();
      const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
      const u = `${this.endpoint}/v1/${name}:signBlob`;
      const body = {
        delegates: this.delegates,
        payload: Buffer.from(blobToSign).toString("base64")
      };
      const res = await this.sourceClient.request({
        ...Impersonated.RETRY_CONFIG,
        url: u,
        data: body,
        method: "POST"
      });
      return res.data;
    }
    getTargetPrincipal() {
      return this.targetPrincipal;
    }
    async refreshToken() {
      var _a, _b, _c, _d, _e, _f;
      try {
        await this.sourceClient.getAccessToken();
        const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
        const u = `${this.endpoint}/v1/${name}:generateAccessToken`;
        const body = {
          delegates: this.delegates,
          scope: this.targetScopes,
          lifetime: this.lifetime + "s"
        };
        const res = await this.sourceClient.request({
          ...Impersonated.RETRY_CONFIG,
          url: u,
          data: body,
          method: "POST"
        });
        const tokenResponse = res.data;
        this.credentials.access_token = tokenResponse.accessToken;
        this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
        return {
          tokens: this.credentials,
          res
        };
      } catch (error) {
        if (!(error instanceof Error))
          throw error;
        let status = 0;
        let message = "";
        if (error instanceof gaxios_1.GaxiosError) {
          status = (_c = (_b = (_a = error === null || error === undefined ? undefined : error.response) === null || _a === undefined ? undefined : _a.data) === null || _b === undefined ? undefined : _b.error) === null || _c === undefined ? undefined : _c.status;
          message = (_f = (_e = (_d = error === null || error === undefined ? undefined : error.response) === null || _d === undefined ? undefined : _d.data) === null || _e === undefined ? undefined : _e.error) === null || _f === undefined ? undefined : _f.message;
        }
        if (status && message) {
          error.message = `${status}: unable to impersonate: ${message}`;
          throw error;
        } else {
          error.message = `unable to impersonate: ${error}`;
          throw error;
        }
      }
    }
    async fetchIdToken(targetAudience, options) {
      var _a, _b;
      await this.sourceClient.getAccessToken();
      const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
      const u = `${this.endpoint}/v1/${name}:generateIdToken`;
      const body = {
        delegates: this.delegates,
        audience: targetAudience,
        includeEmail: (_a = options === null || options === undefined ? undefined : options.includeEmail) !== null && _a !== undefined ? _a : true,
        useEmailAzp: (_b = options === null || options === undefined ? undefined : options.includeEmail) !== null && _b !== undefined ? _b : true
      };
      const res = await this.sourceClient.request({
        ...Impersonated.RETRY_CONFIG,
        url: u,
        data: body,
        method: "POST"
      });
      return res.data.token;
    }
  }
  exports.Impersonated = Impersonated;
});

// node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuthClientAuthHandler = undefined;
  exports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
  var querystring = __require("querystring");
  var crypto_1 = require_crypto3();
  var METHODS_SUPPORTING_REQUEST_BODY = ["PUT", "POST", "PATCH"];

  class OAuthClientAuthHandler {
    constructor(clientAuthentication) {
      this.clientAuthentication = clientAuthentication;
      this.crypto = (0, crypto_1.createCrypto)();
    }
    applyClientAuthenticationOptions(opts, bearerToken) {
      this.injectAuthenticatedHeaders(opts, bearerToken);
      if (!bearerToken) {
        this.injectAuthenticatedRequestBody(opts);
      }
    }
    injectAuthenticatedHeaders(opts, bearerToken) {
      var _a;
      if (bearerToken) {
        opts.headers = opts.headers || {};
        Object.assign(opts.headers, {
          Authorization: `Bearer ${bearerToken}}`
        });
      } else if (((_a = this.clientAuthentication) === null || _a === undefined ? undefined : _a.confidentialClientType) === "basic") {
        opts.headers = opts.headers || {};
        const clientId = this.clientAuthentication.clientId;
        const clientSecret = this.clientAuthentication.clientSecret || "";
        const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
        Object.assign(opts.headers, {
          Authorization: `Basic ${base64EncodedCreds}`
        });
      }
    }
    injectAuthenticatedRequestBody(opts) {
      var _a;
      if (((_a = this.clientAuthentication) === null || _a === undefined ? undefined : _a.confidentialClientType) === "request-body") {
        const method = (opts.method || "GET").toUpperCase();
        if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {
          let contentType;
          const headers = opts.headers || {};
          for (const key in headers) {
            if (key.toLowerCase() === "content-type" && headers[key]) {
              contentType = headers[key].toLowerCase();
              break;
            }
          }
          if (contentType === "application/x-www-form-urlencoded") {
            opts.data = opts.data || "";
            const data = querystring.parse(opts.data);
            Object.assign(data, {
              client_id: this.clientAuthentication.clientId,
              client_secret: this.clientAuthentication.clientSecret || ""
            });
            opts.data = querystring.stringify(data);
          } else if (contentType === "application/json") {
            opts.data = opts.data || {};
            Object.assign(opts.data, {
              client_id: this.clientAuthentication.clientId,
              client_secret: this.clientAuthentication.clientSecret || ""
            });
          } else {
            throw new Error(`${contentType} content-types are not supported with ` + `${this.clientAuthentication.confidentialClientType} ` + "client authentication");
          }
        } else {
          throw new Error(`${method} HTTP method does not support ` + `${this.clientAuthentication.confidentialClientType} ` + "client authentication");
        }
      }
    }
    static get RETRY_CONFIG() {
      return {
        retry: true,
        retryConfig: {
          httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
        }
      };
    }
  }
  exports.OAuthClientAuthHandler = OAuthClientAuthHandler;
  function getErrorFromOAuthErrorResponse(resp, err) {
    const errorCode = resp.error;
    const errorDescription = resp.error_description;
    const errorUri = resp.error_uri;
    let message = `Error code ${errorCode}`;
    if (typeof errorDescription !== "undefined") {
      message += `: ${errorDescription}`;
    }
    if (typeof errorUri !== "undefined") {
      message += ` - ${errorUri}`;
    }
    const newError = new Error(message);
    if (err) {
      const keys = Object.keys(err);
      if (err.stack) {
        keys.push("stack");
      }
      keys.forEach((key) => {
        if (key !== "message") {
          Object.defineProperty(newError, key, {
            value: err[key],
            writable: false,
            enumerable: true
          });
        }
      });
    }
    return newError;
  }
});

// node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StsCredentials = undefined;
  var gaxios_1 = require_src3();
  var querystring = __require("querystring");
  var transporters_1 = require_transporters();
  var oauth2common_1 = require_oauth2common();

  class StsCredentials extends oauth2common_1.OAuthClientAuthHandler {
    constructor(tokenExchangeEndpoint, clientAuthentication) {
      super(clientAuthentication);
      this.tokenExchangeEndpoint = tokenExchangeEndpoint;
      this.transporter = new transporters_1.DefaultTransporter;
    }
    async exchangeToken(stsCredentialsOptions, additionalHeaders, options) {
      var _a, _b, _c;
      const values = {
        grant_type: stsCredentialsOptions.grantType,
        resource: stsCredentialsOptions.resource,
        audience: stsCredentialsOptions.audience,
        scope: (_a = stsCredentialsOptions.scope) === null || _a === undefined ? undefined : _a.join(" "),
        requested_token_type: stsCredentialsOptions.requestedTokenType,
        subject_token: stsCredentialsOptions.subjectToken,
        subject_token_type: stsCredentialsOptions.subjectTokenType,
        actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === undefined ? undefined : _b.actorToken,
        actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === undefined ? undefined : _c.actorTokenType,
        options: options && JSON.stringify(options)
      };
      Object.keys(values).forEach((key) => {
        if (typeof values[key] === "undefined") {
          delete values[key];
        }
      });
      const headers = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      Object.assign(headers, additionalHeaders || {});
      const opts = {
        ...StsCredentials.RETRY_CONFIG,
        url: this.tokenExchangeEndpoint.toString(),
        method: "POST",
        headers,
        data: querystring.stringify(values),
        responseType: "json"
      };
      this.applyClientAuthenticationOptions(opts);
      try {
        const response = await this.transporter.request(opts);
        const stsSuccessfulResponse = response.data;
        stsSuccessfulResponse.res = response;
        return stsSuccessfulResponse;
      } catch (error) {
        if (error instanceof gaxios_1.GaxiosError && error.response) {
          throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, error);
        }
        throw error;
      }
    }
  }
  exports.StsCredentials = StsCredentials;
});

// node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _BaseExternalAccountClient_instances;
  var _BaseExternalAccountClient_pendingAccessToken;
  var _BaseExternalAccountClient_internalRefreshAccessTokenAsync;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = undefined;
  var stream = __require("stream");
  var authclient_1 = require_authclient();
  var sts = require_stscredentials();
  var util_1 = require_util11();
  var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
  var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
  var DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
  var DEFAULT_TOKEN_LIFESPAN = 3600;
  exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;
  exports.EXTERNAL_ACCOUNT_TYPE = "external_account";
  exports.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
  var WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
  var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/token";
  var pkg = require_package3();
  var authclient_2 = require_authclient();
  Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
    return authclient_2.DEFAULT_UNIVERSE;
  } });

  class BaseExternalAccountClient extends authclient_1.AuthClient {
    constructor(options, additionalOptions) {
      var _a;
      super({ ...options, ...additionalOptions });
      _BaseExternalAccountClient_instances.add(this);
      _BaseExternalAccountClient_pendingAccessToken.set(this, null);
      const opts = (0, util_1.originalOrCamelOptions)(options);
      const type = opts.get("type");
      if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) {
        throw new Error(`Expected "${exports.EXTERNAL_ACCOUNT_TYPE}" type but ` + `received "${options.type}"`);
      }
      const clientId = opts.get("client_id");
      const clientSecret = opts.get("client_secret");
      const tokenUrl = (_a = opts.get("token_url")) !== null && _a !== undefined ? _a : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain);
      const subjectTokenType = opts.get("subject_token_type");
      const workforcePoolUserProject = opts.get("workforce_pool_user_project");
      const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
      const serviceAccountImpersonation = opts.get("service_account_impersonation");
      const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
      this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
      if (clientId) {
        this.clientAuth = {
          confidentialClientType: "basic",
          clientId,
          clientSecret
        };
      }
      this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);
      this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
      this.cachedAccessToken = null;
      this.audience = opts.get("audience");
      this.subjectTokenType = subjectTokenType;
      this.workforcePoolUserProject = workforcePoolUserProject;
      const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
      if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {
        throw new Error("workforcePoolUserProject should not be set for non-workforce pool " + "credentials.");
      }
      this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
      this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
      if (this.serviceAccountImpersonationLifetime) {
        this.configLifetimeRequested = true;
      } else {
        this.configLifetimeRequested = false;
        this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
      }
      this.projectNumber = this.getProjectNumber(this.audience);
      this.supplierContext = {
        audience: this.audience,
        subjectTokenType: this.subjectTokenType,
        transporter: this.transporter
      };
    }
    getServiceAccountEmail() {
      var _a;
      if (this.serviceAccountImpersonationUrl) {
        if (this.serviceAccountImpersonationUrl.length > 256) {
          throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
        }
        const re = /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/;
        const result = re.exec(this.serviceAccountImpersonationUrl);
        return ((_a = result === null || result === undefined ? undefined : result.groups) === null || _a === undefined ? undefined : _a.email) || null;
      }
      return null;
    }
    setCredentials(credentials) {
      super.setCredentials(credentials);
      this.cachedAccessToken = credentials;
    }
    async getAccessToken() {
      if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
        await this.refreshAccessTokenAsync();
      }
      return {
        token: this.cachedAccessToken.access_token,
        res: this.cachedAccessToken.res
      };
    }
    async getRequestHeaders() {
      const accessTokenResponse = await this.getAccessToken();
      const headers = {
        Authorization: `Bearer ${accessTokenResponse.token}`
      };
      return this.addSharedMetadataHeaders(headers);
    }
    request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then((r) => callback(null, r), (e) => {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    async getProjectId() {
      const projectNumber = this.projectNumber || this.workforcePoolUserProject;
      if (this.projectId) {
        return this.projectId;
      } else if (projectNumber) {
        const headers = await this.getRequestHeaders();
        const response = await this.transporter.request({
          ...BaseExternalAccountClient.RETRY_CONFIG,
          headers,
          url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,
          responseType: "json"
        });
        this.projectId = response.data.projectId;
        return this.projectId;
      }
      return null;
    }
    async requestAsync(opts, reAuthRetried = false) {
      let response;
      try {
        const requestHeaders = await this.getRequestHeaders();
        opts.headers = opts.headers || {};
        if (requestHeaders && requestHeaders["x-goog-user-project"]) {
          opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
        }
        if (requestHeaders && requestHeaders.Authorization) {
          opts.headers.Authorization = requestHeaders.Authorization;
        }
        response = await this.transporter.request(opts);
      } catch (e) {
        const res = e.response;
        if (res) {
          const statusCode = res.status;
          const isReadableStream = res.config.data instanceof stream.Readable;
          const isAuthErr = statusCode === 401 || statusCode === 403;
          if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
            await this.refreshAccessTokenAsync();
            return await this.requestAsync(opts, true);
          }
        }
        throw e;
      }
      return response;
    }
    async refreshAccessTokenAsync() {
      __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, "f") || __classPrivateFieldGet(this, _BaseExternalAccountClient_instances, "m", _BaseExternalAccountClient_internalRefreshAccessTokenAsync).call(this), "f");
      try {
        return await __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, "f");
      } finally {
        __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, null, "f");
      }
    }
    getProjectNumber(audience) {
      const match = audience.match(/\/projects\/([^/]+)/);
      if (!match) {
        return null;
      }
      return match[1];
    }
    async getImpersonatedAccessToken(token) {
      const opts = {
        ...BaseExternalAccountClient.RETRY_CONFIG,
        url: this.serviceAccountImpersonationUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`
        },
        data: {
          scope: this.getScopesArray(),
          lifetime: this.serviceAccountImpersonationLifetime + "s"
        },
        responseType: "json"
      };
      const response = await this.transporter.request(opts);
      const successResponse = response.data;
      return {
        access_token: successResponse.accessToken,
        expiry_date: new Date(successResponse.expireTime).getTime(),
        res: response
      };
    }
    isExpired(accessToken) {
      const now = new Date().getTime();
      return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
    getScopesArray() {
      if (typeof this.scopes === "string") {
        return [this.scopes];
      }
      return this.scopes || [DEFAULT_OAUTH_SCOPE];
    }
    getMetricsHeaderValue() {
      const nodeVersion = process.version.replace(/^v/, "");
      const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;
      const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
      return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
    }
  }
  exports.BaseExternalAccountClient = BaseExternalAccountClient;
  _BaseExternalAccountClient_pendingAccessToken = new WeakMap, _BaseExternalAccountClient_instances = new WeakSet, _BaseExternalAccountClient_internalRefreshAccessTokenAsync = async function _BaseExternalAccountClient_internalRefreshAccessTokenAsync() {
    const subjectToken = await this.retrieveSubjectToken();
    const stsCredentialsOptions = {
      grantType: STS_GRANT_TYPE,
      audience: this.audience,
      requestedTokenType: STS_REQUEST_TOKEN_TYPE,
      subjectToken,
      subjectTokenType: this.subjectTokenType,
      scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
    };
    const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : undefined;
    const additionalHeaders = {
      "x-goog-api-client": this.getMetricsHeaderValue()
    };
    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
    if (this.serviceAccountImpersonationUrl) {
      this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);
    } else if (stsResponse.expires_in) {
      this.cachedAccessToken = {
        access_token: stsResponse.access_token,
        expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,
        res: stsResponse.res
      };
    } else {
      this.cachedAccessToken = {
        access_token: stsResponse.access_token,
        res: stsResponse.res
      };
    }
    this.credentials = {};
    Object.assign(this.credentials, this.cachedAccessToken);
    delete this.credentials.res;
    this.emit("tokens", {
      refresh_token: null,
      expiry_date: this.cachedAccessToken.expiry_date,
      access_token: this.cachedAccessToken.access_token,
      token_type: "Bearer",
      id_token: null
    });
    return this.cachedAccessToken;
  };
});

// node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = __commonJS((exports) => {
  var _a;
  var _b;
  var _c;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FileSubjectTokenSupplier = undefined;
  var util_1 = __require("util");
  var fs = __require("fs");
  var readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== undefined ? _a : () => {});
  var realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== undefined ? _b : () => {});
  var lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== undefined ? _c : () => {});

  class FileSubjectTokenSupplier {
    constructor(opts) {
      this.filePath = opts.filePath;
      this.formatType = opts.formatType;
      this.subjectTokenFieldName = opts.subjectTokenFieldName;
    }
    async getSubjectToken(context) {
      let parsedFilePath = this.filePath;
      try {
        parsedFilePath = await realpath(parsedFilePath);
        if (!(await lstat(parsedFilePath)).isFile()) {
          throw new Error;
        }
      } catch (err) {
        if (err instanceof Error) {
          err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
        }
        throw err;
      }
      let subjectToken;
      const rawText = await readFile(parsedFilePath, { encoding: "utf8" });
      if (this.formatType === "text") {
        subjectToken = rawText;
      } else if (this.formatType === "json" && this.subjectTokenFieldName) {
        const json = JSON.parse(rawText);
        subjectToken = json[this.subjectTokenFieldName];
      }
      if (!subjectToken) {
        throw new Error("Unable to parse the subject_token from the credential_source file");
      }
      return subjectToken;
    }
  }
  exports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
});

// node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UrlSubjectTokenSupplier = undefined;

  class UrlSubjectTokenSupplier {
    constructor(opts) {
      this.url = opts.url;
      this.formatType = opts.formatType;
      this.subjectTokenFieldName = opts.subjectTokenFieldName;
      this.headers = opts.headers;
      this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
    }
    async getSubjectToken(context) {
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.url,
        method: "GET",
        headers: this.headers,
        responseType: this.formatType
      };
      let subjectToken;
      if (this.formatType === "text") {
        const response = await context.transporter.request(opts);
        subjectToken = response.data;
      } else if (this.formatType === "json" && this.subjectTokenFieldName) {
        const response = await context.transporter.request(opts);
        subjectToken = response.data[this.subjectTokenFieldName];
      }
      if (!subjectToken) {
        throw new Error("Unable to parse the subject_token from the credential_source URL");
      }
      return subjectToken;
    }
  }
  exports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
});

// node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IdentityPoolClient = undefined;
  var baseexternalclient_1 = require_baseexternalclient();
  var util_1 = require_util11();
  var filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
  var urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();

  class IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {
    constructor(options, additionalOptions) {
      super(options, additionalOptions);
      const opts = (0, util_1.originalOrCamelOptions)(options);
      const credentialSource = opts.get("credential_source");
      const subjectTokenSupplier = opts.get("subject_token_supplier");
      if (!credentialSource && !subjectTokenSupplier) {
        throw new Error("A credential source or subject token supplier must be specified.");
      }
      if (credentialSource && subjectTokenSupplier) {
        throw new Error("Only one of credential source or subject token supplier can be specified.");
      }
      if (subjectTokenSupplier) {
        this.subjectTokenSupplier = subjectTokenSupplier;
        this.credentialSourceType = "programmatic";
      } else {
        const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
        const formatOpts = (0, util_1.originalOrCamelOptions)(credentialSourceOpts.get("format"));
        const formatType = formatOpts.get("type") || "text";
        const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
        if (formatType !== "json" && formatType !== "text") {
          throw new Error(`Invalid credential_source format "${formatType}"`);
        }
        if (formatType === "json" && !formatSubjectTokenFieldName) {
          throw new Error("Missing subject_token_field_name for JSON credential_source format");
        }
        const file = credentialSourceOpts.get("file");
        const url = credentialSourceOpts.get("url");
        const headers = credentialSourceOpts.get("headers");
        if (file && url) {
          throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
        } else if (file && !url) {
          this.credentialSourceType = "file";
          this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
            filePath: file,
            formatType,
            subjectTokenFieldName: formatSubjectTokenFieldName
          });
        } else if (!file && url) {
          this.credentialSourceType = "url";
          this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
            url,
            formatType,
            subjectTokenFieldName: formatSubjectTokenFieldName,
            headers,
            additionalGaxiosOptions: IdentityPoolClient.RETRY_CONFIG
          });
        } else {
          throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
        }
      }
    }
    async retrieveSubjectToken() {
      return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
    }
  }
  exports.IdentityPoolClient = IdentityPoolClient;
});

// node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsRequestSigner = undefined;
  var crypto_1 = require_crypto3();
  var AWS_ALGORITHM = "AWS4-HMAC-SHA256";
  var AWS_REQUEST_TYPE = "aws4_request";

  class AwsRequestSigner {
    constructor(getCredentials, region) {
      this.getCredentials = getCredentials;
      this.region = region;
      this.crypto = (0, crypto_1.createCrypto)();
    }
    async getRequestOptions(amzOptions) {
      if (!amzOptions.url) {
        throw new Error('"url" is required in "amzOptions"');
      }
      const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
      const url = amzOptions.url;
      const method = amzOptions.method || "GET";
      const requestPayload = amzOptions.body || requestPayloadData;
      const additionalAmzHeaders = amzOptions.headers;
      const awsSecurityCredentials = await this.getCredentials();
      const uri = new URL(url);
      const headerMap = await generateAuthenticationHeaderMap({
        crypto: this.crypto,
        host: uri.host,
        canonicalUri: uri.pathname,
        canonicalQuerystring: uri.search.substr(1),
        method,
        region: this.region,
        securityCredentials: awsSecurityCredentials,
        requestPayload,
        additionalAmzHeaders
      });
      const headers = Object.assign(headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {}, {
        Authorization: headerMap.authorizationHeader,
        host: uri.host
      }, additionalAmzHeaders || {});
      if (awsSecurityCredentials.token) {
        Object.assign(headers, {
          "x-amz-security-token": awsSecurityCredentials.token
        });
      }
      const awsSignedReq = {
        url,
        method,
        headers
      };
      if (typeof requestPayload !== "undefined") {
        awsSignedReq.body = requestPayload;
      }
      return awsSignedReq;
    }
  }
  exports.AwsRequestSigner = AwsRequestSigner;
  async function sign(crypto2, key, msg) {
    return await crypto2.signWithHmacSha256(key, msg);
  }
  async function getSigningKey(crypto2, key, dateStamp, region, serviceName) {
    const kDate = await sign(crypto2, `AWS4${key}`, dateStamp);
    const kRegion = await sign(crypto2, kDate, region);
    const kService = await sign(crypto2, kRegion, serviceName);
    const kSigning = await sign(crypto2, kService, "aws4_request");
    return kSigning;
  }
  async function generateAuthenticationHeaderMap(options) {
    const additionalAmzHeaders = options.additionalAmzHeaders || {};
    const requestPayload = options.requestPayload || "";
    const serviceName = options.host.split(".")[0];
    const now = new Date;
    const amzDate = now.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
    const dateStamp = now.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
    const reformattedAdditionalAmzHeaders = {};
    Object.keys(additionalAmzHeaders).forEach((key) => {
      reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];
    });
    if (options.securityCredentials.token) {
      reformattedAdditionalAmzHeaders["x-amz-security-token"] = options.securityCredentials.token;
    }
    const amzHeaders = Object.assign({
      host: options.host
    }, reformattedAdditionalAmzHeaders.date ? {} : { "x-amz-date": amzDate }, reformattedAdditionalAmzHeaders);
    let canonicalHeaders = "";
    const signedHeadersList = Object.keys(amzHeaders).sort();
    signedHeadersList.forEach((key) => {
      canonicalHeaders += `${key}:${amzHeaders[key]}
`;
    });
    const signedHeaders = signedHeadersList.join(";");
    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);
    const canonicalRequest = `${options.method}
` + `${options.canonicalUri}
` + `${options.canonicalQuerystring}
` + `${canonicalHeaders}
` + `${signedHeaders}
` + `${payloadHash}`;
    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
    const stringToSign = `${AWS_ALGORITHM}
` + `${amzDate}
` + `${credentialScope}
` + await options.crypto.sha256DigestHex(canonicalRequest);
    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
    const signature = await sign(options.crypto, signingKey, stringToSign);
    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` + `${credentialScope}, SignedHeaders=${signedHeaders}, ` + `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;
    return {
      amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,
      authorizationHeader,
      canonicalQuerystring: options.canonicalQuerystring
    };
  }
});

// node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _DefaultAwsSecurityCredentialsSupplier_instances;
  var _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken;
  var _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName;
  var _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials;
  var _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get;
  var _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultAwsSecurityCredentialsSupplier = undefined;

  class DefaultAwsSecurityCredentialsSupplier {
    constructor(opts) {
      _DefaultAwsSecurityCredentialsSupplier_instances.add(this);
      this.regionUrl = opts.regionUrl;
      this.securityCredentialsUrl = opts.securityCredentialsUrl;
      this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
      this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
    }
    async getAwsRegion(context) {
      if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get)) {
        return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get);
      }
      const metadataHeaders = {};
      if (!__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get) && this.imdsV2SessionTokenUrl) {
        metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
      }
      if (!this.regionUrl) {
        throw new Error("Unable to determine AWS region due to missing " + '"options.credential_source.region_url"');
      }
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.regionUrl,
        method: "GET",
        responseType: "text",
        headers: metadataHeaders
      };
      const response = await context.transporter.request(opts);
      return response.data.substr(0, response.data.length - 1);
    }
    async getAwsSecurityCredentials(context) {
      if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get)) {
        return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get);
      }
      const metadataHeaders = {};
      if (this.imdsV2SessionTokenUrl) {
        metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
      }
      const roleName = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName).call(this, metadataHeaders, context.transporter);
      const awsCreds = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials).call(this, roleName, metadataHeaders, context.transporter);
      return {
        accessKeyId: awsCreds.AccessKeyId,
        secretAccessKey: awsCreds.SecretAccessKey,
        token: awsCreds.Token
      };
    }
  }
  exports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
  _DefaultAwsSecurityCredentialsSupplier_instances = new WeakSet, _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken = async function _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken(transporter) {
    const opts = {
      ...this.additionalGaxiosOptions,
      url: this.imdsV2SessionTokenUrl,
      method: "PUT",
      responseType: "text",
      headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
    };
    const response = await transporter.request(opts);
    return response.data;
  }, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName = async function _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName(headers, transporter) {
    if (!this.securityCredentialsUrl) {
      throw new Error("Unable to determine AWS role name due to missing " + '"options.credential_source.url"');
    }
    const opts = {
      ...this.additionalGaxiosOptions,
      url: this.securityCredentialsUrl,
      method: "GET",
      responseType: "text",
      headers
    };
    const response = await transporter.request(opts);
    return response.data;
  }, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials = async function _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials(roleName, headers, transporter) {
    const response = await transporter.request({
      ...this.additionalGaxiosOptions,
      url: `${this.securityCredentialsUrl}/${roleName}`,
      responseType: "json",
      headers
    });
    return response.data;
  }, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get() {
    return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
  }, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get() {
    if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) {
      return {
        accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
        secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
        token: process.env["AWS_SESSION_TOKEN"]
      };
    }
    return null;
  };
});

// node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a;
  var _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsClient = undefined;
  var awsrequestsigner_1 = require_awsrequestsigner();
  var baseexternalclient_1 = require_baseexternalclient();
  var defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
  var util_1 = require_util11();

  class AwsClient extends baseexternalclient_1.BaseExternalAccountClient {
    constructor(options, additionalOptions) {
      super(options, additionalOptions);
      const opts = (0, util_1.originalOrCamelOptions)(options);
      const credentialSource = opts.get("credential_source");
      const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
      if (!credentialSource && !awsSecurityCredentialsSupplier) {
        throw new Error("A credential source or AWS security credentials supplier must be specified.");
      }
      if (credentialSource && awsSecurityCredentialsSupplier) {
        throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
      }
      if (awsSecurityCredentialsSupplier) {
        this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
        this.regionalCredVerificationUrl = __classPrivateFieldGet(_a, _a, "f", _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);
        this.credentialSourceType = "programmatic";
      } else {
        const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
        this.environmentId = credentialSourceOpts.get("environment_id");
        const regionUrl = credentialSourceOpts.get("region_url");
        const securityCredentialsUrl = credentialSourceOpts.get("url");
        const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
        this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
          regionUrl,
          securityCredentialsUrl,
          imdsV2SessionTokenUrl
        });
        this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
        this.credentialSourceType = "aws";
        this.validateEnvironmentId();
      }
      this.awsRequestSigner = null;
      this.region = "";
    }
    validateEnvironmentId() {
      var _b;
      const match = (_b = this.environmentId) === null || _b === undefined ? undefined : _b.match(/^(aws)(\d+)$/);
      if (!match || !this.regionalCredVerificationUrl) {
        throw new Error('No valid AWS "credential_source" provided');
      } else if (parseInt(match[2], 10) !== 1) {
        throw new Error(`aws version "${match[2]}" is not supported in the current build.`);
      }
    }
    async retrieveSubjectToken() {
      if (!this.awsRequestSigner) {
        this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
        this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {
          return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
        }, this.region);
      }
      const options = await this.awsRequestSigner.getRequestOptions({
        ..._a.RETRY_CONFIG,
        url: this.regionalCredVerificationUrl.replace("{region}", this.region),
        method: "POST"
      });
      const reformattedHeader = [];
      const extendedHeaders = Object.assign({
        "x-goog-cloud-target-resource": this.audience
      }, options.headers);
      for (const key in extendedHeaders) {
        reformattedHeader.push({
          key,
          value: extendedHeaders[key]
        });
      }
      return encodeURIComponent(JSON.stringify({
        url: options.url,
        method: options.method,
        headers: reformattedHeader
      }));
    }
  }
  exports.AwsClient = AwsClient;
  _a = AwsClient;
  _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = { value: "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15" };
  AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
  AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
});

// node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = undefined;
  var SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
  var OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
  var OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";

  class ExecutableResponse {
    constructor(responseJson) {
      if (!responseJson.version) {
        throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
      }
      if (responseJson.success === undefined) {
        throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
      }
      this.version = responseJson.version;
      this.success = responseJson.success;
      if (this.success) {
        this.expirationTime = responseJson.expiration_time;
        this.tokenType = responseJson.token_type;
        if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {
          throw new InvalidTokenTypeFieldError("Executable response must contain a 'token_type' field when successful " + `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
        }
        if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
          if (!responseJson.saml_response) {
            throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
          }
          this.subjectToken = responseJson.saml_response;
        } else {
          if (!responseJson.id_token) {
            throw new InvalidSubjectTokenError("Executable response must contain a 'id_token' field when " + `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
          }
          this.subjectToken = responseJson.id_token;
        }
      } else {
        if (!responseJson.code) {
          throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
        }
        if (!responseJson.message) {
          throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
        }
        this.errorCode = responseJson.code;
        this.errorMessage = responseJson.message;
      }
    }
    isValid() {
      return !this.isExpired() && this.success;
    }
    isExpired() {
      return this.expirationTime !== undefined && this.expirationTime < Math.round(Date.now() / 1000);
    }
  }
  exports.ExecutableResponse = ExecutableResponse;

  class ExecutableResponseError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.ExecutableResponseError = ExecutableResponseError;

  class InvalidVersionFieldError extends ExecutableResponseError {
  }
  exports.InvalidVersionFieldError = InvalidVersionFieldError;

  class InvalidSuccessFieldError extends ExecutableResponseError {
  }
  exports.InvalidSuccessFieldError = InvalidSuccessFieldError;

  class InvalidExpirationTimeFieldError extends ExecutableResponseError {
  }
  exports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;

  class InvalidTokenTypeFieldError extends ExecutableResponseError {
  }
  exports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;

  class InvalidCodeFieldError extends ExecutableResponseError {
  }
  exports.InvalidCodeFieldError = InvalidCodeFieldError;

  class InvalidMessageFieldError extends ExecutableResponseError {
  }
  exports.InvalidMessageFieldError = InvalidMessageFieldError;

  class InvalidSubjectTokenError extends ExecutableResponseError {
  }
  exports.InvalidSubjectTokenError = InvalidSubjectTokenError;
});

// node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PluggableAuthHandler = undefined;
  var pluggable_auth_client_1 = require_pluggable_auth_client();
  var executable_response_1 = require_executable_response();
  var childProcess = __require("child_process");
  var fs = __require("fs");

  class PluggableAuthHandler {
    constructor(options) {
      if (!options.command) {
        throw new Error("No command provided.");
      }
      this.commandComponents = PluggableAuthHandler.parseCommand(options.command);
      this.timeoutMillis = options.timeoutMillis;
      if (!this.timeoutMillis) {
        throw new Error("No timeoutMillis provided.");
      }
      this.outputFile = options.outputFile;
    }
    retrieveResponseFromExecutable(envMap) {
      return new Promise((resolve, reject) => {
        const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {
          env: { ...process.env, ...Object.fromEntries(envMap) }
        });
        let output = "";
        child.stdout.on("data", (data) => {
          output += data;
        });
        child.stderr.on("data", (err) => {
          output += err;
        });
        const timeout = setTimeout(() => {
          child.removeAllListeners();
          child.kill();
          return reject(new Error("The executable failed to finish within the timeout specified."));
        }, this.timeoutMillis);
        child.on("close", (code) => {
          clearTimeout(timeout);
          if (code === 0) {
            try {
              const responseJson = JSON.parse(output);
              const response = new executable_response_1.ExecutableResponse(responseJson);
              return resolve(response);
            } catch (error) {
              if (error instanceof executable_response_1.ExecutableResponseError) {
                return reject(error);
              }
              return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
            }
          } else {
            return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));
          }
        });
      });
    }
    async retrieveCachedResponse() {
      if (!this.outputFile || this.outputFile.length === 0) {
        return;
      }
      let filePath;
      try {
        filePath = await fs.promises.realpath(this.outputFile);
      } catch (_a) {
        return;
      }
      if (!(await fs.promises.lstat(filePath)).isFile()) {
        return;
      }
      const responseString = await fs.promises.readFile(filePath, {
        encoding: "utf8"
      });
      if (responseString === "") {
        return;
      }
      try {
        const responseJson = JSON.parse(responseString);
        const response = new executable_response_1.ExecutableResponse(responseJson);
        if (response.isValid()) {
          return new executable_response_1.ExecutableResponse(responseJson);
        }
        return;
      } catch (error) {
        if (error instanceof executable_response_1.ExecutableResponseError) {
          throw error;
        }
        throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
      }
    }
    static parseCommand(command) {
      const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
      if (!components) {
        throw new Error(`Provided command: "${command}" could not be parsed.`);
      }
      for (let i = 0;i < components.length; i++) {
        if (components[i][0] === '"' && components[i].slice(-1) === '"') {
          components[i] = components[i].slice(1, -1);
        }
      }
      return components;
    }
  }
  exports.PluggableAuthHandler = PluggableAuthHandler;
});

// node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PluggableAuthClient = exports.ExecutableError = undefined;
  var baseexternalclient_1 = require_baseexternalclient();
  var executable_response_1 = require_executable_response();
  var pluggable_auth_handler_1 = require_pluggable_auth_handler();

  class ExecutableError extends Error {
    constructor(message, code) {
      super(`The executable failed with exit code: ${code} and error message: ${message}.`);
      this.code = code;
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.ExecutableError = ExecutableError;
  var DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;
  var MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;
  var MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;
  var GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
  var MAXIMUM_EXECUTABLE_VERSION = 1;

  class PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {
    constructor(options, additionalOptions) {
      super(options, additionalOptions);
      if (!options.credential_source.executable) {
        throw new Error('No valid Pluggable Auth "credential_source" provided.');
      }
      this.command = options.credential_source.executable.command;
      if (!this.command) {
        throw new Error('No valid Pluggable Auth "credential_source" provided.');
      }
      if (options.credential_source.executable.timeout_millis === undefined) {
        this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
      } else {
        this.timeoutMillis = options.credential_source.executable.timeout_millis;
        if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {
          throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` + `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
        }
      }
      this.outputFile = options.credential_source.executable.output_file;
      this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
        command: this.command,
        timeoutMillis: this.timeoutMillis,
        outputFile: this.outputFile
      });
      this.credentialSourceType = "executable";
    }
    async retrieveSubjectToken() {
      if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") {
        throw new Error("Pluggable Auth executables need to be explicitly allowed to run by " + "setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment " + "Variable to 1.");
      }
      let executableResponse = undefined;
      if (this.outputFile) {
        executableResponse = await this.handler.retrieveCachedResponse();
      }
      if (!executableResponse) {
        const envMap = new Map;
        envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
        envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
        envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
        if (this.outputFile) {
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
        }
        const serviceAccountEmail = this.getServiceAccountEmail();
        if (serviceAccountEmail) {
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
        }
        executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);
      }
      if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {
        throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
      }
      if (!executableResponse.success) {
        throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
      }
      if (this.outputFile) {
        if (!executableResponse.expirationTime) {
          throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
        }
      }
      if (executableResponse.isExpired()) {
        throw new Error("Executable response is expired.");
      }
      return executableResponse.subjectToken;
    }
  }
  exports.PluggableAuthClient = PluggableAuthClient;
});

// node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExternalAccountClient = undefined;
  var baseexternalclient_1 = require_baseexternalclient();
  var identitypoolclient_1 = require_identitypoolclient();
  var awsclient_1 = require_awsclient();
  var pluggable_auth_client_1 = require_pluggable_auth_client();

  class ExternalAccountClient {
    constructor() {
      throw new Error("ExternalAccountClients should be initialized via: " + "ExternalAccountClient.fromJSON(), " + "directly via explicit constructors, eg. " + "new AwsClient(options), new IdentityPoolClient(options), new" + "PluggableAuthClientOptions, or via " + "new GoogleAuth(options).getClient()");
    }
    static fromJSON(options, additionalOptions) {
      var _a, _b;
      if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
        if ((_a = options.credential_source) === null || _a === undefined ? undefined : _a.environment_id) {
          return new awsclient_1.AwsClient(options, additionalOptions);
        } else if ((_b = options.credential_source) === null || _b === undefined ? undefined : _b.executable) {
          return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);
        } else {
          return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);
        }
      } else {
        return null;
      }
    }
  }
  exports.ExternalAccountClient = ExternalAccountClient;
});

// node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = undefined;
  var authclient_1 = require_authclient();
  var oauth2common_1 = require_oauth2common();
  var gaxios_1 = require_src3();
  var stream = __require("stream");
  var baseexternalclient_1 = require_baseexternalclient();
  exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
  var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";

  class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
    constructor(url, transporter, clientAuthentication) {
      super(clientAuthentication);
      this.url = url;
      this.transporter = transporter;
    }
    async refreshToken(refreshToken, additionalHeaders) {
      const values = new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken
      });
      const headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        ...additionalHeaders
      };
      const opts = {
        ...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,
        url: this.url,
        method: "POST",
        headers,
        data: values.toString(),
        responseType: "json"
      };
      this.applyClientAuthenticationOptions(opts);
      try {
        const response = await this.transporter.request(opts);
        const tokenRefreshResponse = response.data;
        tokenRefreshResponse.res = response;
        return tokenRefreshResponse;
      } catch (error) {
        if (error instanceof gaxios_1.GaxiosError && error.response) {
          throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, error);
        }
        throw error;
      }
    }
  }

  class ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {
    constructor(options, additionalOptions) {
      var _a;
      super({ ...options, ...additionalOptions });
      if (options.universe_domain) {
        this.universeDomain = options.universe_domain;
      }
      this.refreshToken = options.refresh_token;
      const clientAuth = {
        confidentialClientType: "basic",
        clientId: options.client_id,
        clientSecret: options.client_secret
      };
      this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a = options.token_url) !== null && _a !== undefined ? _a : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain), this.transporter, clientAuth);
      this.cachedAccessToken = null;
      this.quotaProjectId = options.quota_project_id;
      if (typeof (additionalOptions === null || additionalOptions === undefined ? undefined : additionalOptions.eagerRefreshThresholdMillis) !== "number") {
        this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;
      } else {
        this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;
      }
      this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === undefined ? undefined : additionalOptions.forceRefreshOnFailure);
    }
    async getAccessToken() {
      if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
        await this.refreshAccessTokenAsync();
      }
      return {
        token: this.cachedAccessToken.access_token,
        res: this.cachedAccessToken.res
      };
    }
    async getRequestHeaders() {
      const accessTokenResponse = await this.getAccessToken();
      const headers = {
        Authorization: `Bearer ${accessTokenResponse.token}`
      };
      return this.addSharedMetadataHeaders(headers);
    }
    request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then((r) => callback(null, r), (e) => {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    async requestAsync(opts, reAuthRetried = false) {
      let response;
      try {
        const requestHeaders = await this.getRequestHeaders();
        opts.headers = opts.headers || {};
        if (requestHeaders && requestHeaders["x-goog-user-project"]) {
          opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
        }
        if (requestHeaders && requestHeaders.Authorization) {
          opts.headers.Authorization = requestHeaders.Authorization;
        }
        response = await this.transporter.request(opts);
      } catch (e) {
        const res = e.response;
        if (res) {
          const statusCode = res.status;
          const isReadableStream = res.config.data instanceof stream.Readable;
          const isAuthErr = statusCode === 401 || statusCode === 403;
          if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
            await this.refreshAccessTokenAsync();
            return await this.requestAsync(opts, true);
          }
        }
        throw e;
      }
      return response;
    }
    async refreshAccessTokenAsync() {
      const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
      this.cachedAccessToken = {
        access_token: refreshResponse.access_token,
        expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,
        res: refreshResponse.res
      };
      if (refreshResponse.refresh_token !== undefined) {
        this.refreshToken = refreshResponse.refresh_token;
      }
      return this.cachedAccessToken;
    }
    isExpired(credentials) {
      const now = new Date().getTime();
      return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
  }
  exports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
});

// node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _GoogleAuth_instances;
  var _GoogleAuth_pendingAuthClient;
  var _GoogleAuth_prepareAndCacheClient;
  var _GoogleAuth_determineClient;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = undefined;
  var child_process_1 = __require("child_process");
  var fs = __require("fs");
  var gcpMetadata = require_src5();
  var os = __require("os");
  var path = __require("path");
  var crypto_1 = require_crypto3();
  var transporters_1 = require_transporters();
  var computeclient_1 = require_computeclient();
  var idtokenclient_1 = require_idtokenclient();
  var envDetect_1 = require_envDetect();
  var jwtclient_1 = require_jwtclient();
  var refreshclient_1 = require_refreshclient();
  var impersonated_1 = require_impersonated();
  var externalclient_1 = require_externalclient();
  var baseexternalclient_1 = require_baseexternalclient();
  var authclient_1 = require_authclient();
  var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
  var util_1 = require_util11();
  exports.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com";
  exports.GoogleAuthExceptionMessages = {
    API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
    NO_PROJECT_ID_FOUND: `Unable to detect a Project Id in the current environment. 
` + `To learn more about authentication and Google APIs, visit: 
` + "https://cloud.google.com/docs/authentication/getting-started",
    NO_CREDENTIALS_FOUND: `Unable to find credentials in current environment. 
` + `To learn more about authentication and Google APIs, visit: 
` + "https://cloud.google.com/docs/authentication/getting-started",
    NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
    NO_UNIVERSE_DOMAIN_FOUND: `Unable to detect a Universe Domain in the current environment.
` + `To learn more about Universe Domain retrieval, visit: 
` + "https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
  };

  class GoogleAuth {
    get isGCE() {
      return this.checkIsGCE;
    }
    constructor(opts = {}) {
      _GoogleAuth_instances.add(this);
      this.checkIsGCE = undefined;
      this.jsonContent = null;
      this.cachedCredential = null;
      _GoogleAuth_pendingAuthClient.set(this, null);
      this.clientOptions = {};
      this._cachedProjectId = opts.projectId || null;
      this.cachedCredential = opts.authClient || null;
      this.keyFilename = opts.keyFilename || opts.keyFile;
      this.scopes = opts.scopes;
      this.clientOptions = opts.clientOptions || {};
      this.jsonContent = opts.credentials || null;
      this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
      if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {
        throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
      }
      if (opts.universeDomain) {
        this.clientOptions.universeDomain = opts.universeDomain;
      }
    }
    setGapicJWTValues(client) {
      client.defaultServicePath = this.defaultServicePath;
      client.useJWTAccessWithScope = this.useJWTAccessWithScope;
      client.defaultScopes = this.defaultScopes;
    }
    getProjectId(callback) {
      if (callback) {
        this.getProjectIdAsync().then((r) => callback(null, r), callback);
      } else {
        return this.getProjectIdAsync();
      }
    }
    async getProjectIdOptional() {
      try {
        return await this.getProjectId();
      } catch (e) {
        if (e instanceof Error && e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {
          return null;
        } else {
          throw e;
        }
      }
    }
    async findAndCacheProjectId() {
      let projectId = null;
      projectId || (projectId = await this.getProductionProjectId());
      projectId || (projectId = await this.getFileProjectId());
      projectId || (projectId = await this.getDefaultServiceProjectId());
      projectId || (projectId = await this.getGCEProjectId());
      projectId || (projectId = await this.getExternalAccountClientProjectId());
      if (projectId) {
        this._cachedProjectId = projectId;
        return projectId;
      } else {
        throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
      }
    }
    async getProjectIdAsync() {
      if (this._cachedProjectId) {
        return this._cachedProjectId;
      }
      if (!this._findProjectIdPromise) {
        this._findProjectIdPromise = this.findAndCacheProjectId();
      }
      return this._findProjectIdPromise;
    }
    async getUniverseDomainFromMetadataServer() {
      var _a;
      let universeDomain;
      try {
        universeDomain = await gcpMetadata.universe("universe-domain");
        universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);
      } catch (e) {
        if (e && ((_a = e === null || e === undefined ? undefined : e.response) === null || _a === undefined ? undefined : _a.status) === 404) {
          universeDomain = authclient_1.DEFAULT_UNIVERSE;
        } else {
          throw e;
        }
      }
      return universeDomain;
    }
    async getUniverseDomain() {
      let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
      try {
        universeDomain !== null && universeDomain !== undefined || (universeDomain = (await this.getClient()).universeDomain);
      } catch (_a) {
        universeDomain !== null && universeDomain !== undefined || (universeDomain = authclient_1.DEFAULT_UNIVERSE);
      }
      return universeDomain;
    }
    getAnyScopes() {
      return this.scopes || this.defaultScopes;
    }
    getApplicationDefault(optionsOrCallback = {}, callback) {
      let options;
      if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }
      if (callback) {
        this.getApplicationDefaultAsync(options).then((r) => callback(null, r.credential, r.projectId), callback);
      } else {
        return this.getApplicationDefaultAsync(options);
      }
    }
    async getApplicationDefaultAsync(options = {}) {
      if (this.cachedCredential) {
        return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);
      }
      let credential;
      credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
      if (credential) {
        if (credential instanceof jwtclient_1.JWT) {
          credential.scopes = this.scopes;
        } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
          credential.scopes = this.getAnyScopes();
        }
        return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
      }
      credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
      if (credential) {
        if (credential instanceof jwtclient_1.JWT) {
          credential.scopes = this.scopes;
        } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
          credential.scopes = this.getAnyScopes();
        }
        return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
      }
      if (await this._checkIsGCE()) {
        options.scopes = this.getAnyScopes();
        return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));
      }
      throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);
    }
    async _checkIsGCE() {
      if (this.checkIsGCE === undefined) {
        this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();
      }
      return this.checkIsGCE;
    }
    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
      const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
      if (!credentialsPath || credentialsPath.length === 0) {
        return null;
      }
      try {
        return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
      } catch (e) {
        if (e instanceof Error) {
          e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;
        }
        throw e;
      }
    }
    async _tryGetApplicationCredentialsFromWellKnownFile(options) {
      let location = null;
      if (this._isWindows()) {
        location = process.env["APPDATA"];
      } else {
        const home = process.env["HOME"];
        if (home) {
          location = path.join(home, ".config");
        }
      }
      if (location) {
        location = path.join(location, "gcloud", "application_default_credentials.json");
        if (!fs.existsSync(location)) {
          location = null;
        }
      }
      if (!location) {
        return null;
      }
      const client = await this._getApplicationCredentialsFromFilePath(location, options);
      return client;
    }
    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
      if (!filePath || filePath.length === 0) {
        throw new Error("The file path is invalid.");
      }
      try {
        filePath = fs.realpathSync(filePath);
        if (!fs.lstatSync(filePath).isFile()) {
          throw new Error;
        }
      } catch (err) {
        if (err instanceof Error) {
          err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
        }
        throw err;
      }
      const readStream = fs.createReadStream(filePath);
      return this.fromStream(readStream, options);
    }
    fromImpersonatedJSON(json) {
      var _a, _b, _c, _d;
      if (!json) {
        throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
      }
      if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
        throw new Error(`The incoming JSON object does not have the "${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}" type`);
      }
      if (!json.source_credentials) {
        throw new Error("The incoming JSON object does not contain a source_credentials field");
      }
      if (!json.service_account_impersonation_url) {
        throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
      }
      const sourceClient = this.fromJSON(json.source_credentials);
      if (((_a = json.service_account_impersonation_url) === null || _a === undefined ? undefined : _a.length) > 256) {
        throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);
      }
      const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === undefined ? undefined : _b.groups) === null || _c === undefined ? undefined : _c.target;
      if (!targetPrincipal) {
        throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);
      }
      const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== undefined ? _d : [];
      return new impersonated_1.Impersonated({
        ...json,
        sourceClient,
        targetPrincipal,
        targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
      });
    }
    fromJSON(json, options = {}) {
      let client;
      const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
      if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {
        client = new refreshclient_1.UserRefreshClient(options);
        client.fromJSON(json);
      } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
        client = this.fromImpersonatedJSON(json);
      } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
        client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
        client.scopes = this.getAnyScopes();
      } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {
        client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);
      } else {
        options.scopes = this.scopes;
        client = new jwtclient_1.JWT(options);
        this.setGapicJWTValues(client);
        client.fromJSON(json);
      }
      if (preferredUniverseDomain) {
        client.universeDomain = preferredUniverseDomain;
      }
      return client;
    }
    _cacheClientFromJSON(json, options) {
      const client = this.fromJSON(json, options);
      this.jsonContent = json;
      this.cachedCredential = client;
      return client;
    }
    fromStream(inputStream, optionsOrCallback = {}, callback) {
      let options = {};
      if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }
      if (callback) {
        this.fromStreamAsync(inputStream, options).then((r) => callback(null, r), callback);
      } else {
        return this.fromStreamAsync(inputStream, options);
      }
    }
    fromStreamAsync(inputStream, options) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          throw new Error("Must pass in a stream containing the Google auth settings.");
        }
        const chunks = [];
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
          try {
            try {
              const data = JSON.parse(chunks.join(""));
              const r = this._cacheClientFromJSON(data, options);
              return resolve(r);
            } catch (err) {
              if (!this.keyFilename)
                throw err;
              const client = new jwtclient_1.JWT({
                ...this.clientOptions,
                keyFile: this.keyFilename
              });
              this.cachedCredential = client;
              this.setGapicJWTValues(client);
              return resolve(client);
            }
          } catch (err) {
            return reject(err);
          }
        });
      });
    }
    fromAPIKey(apiKey, options = {}) {
      return new jwtclient_1.JWT({ ...options, apiKey });
    }
    _isWindows() {
      const sys = os.platform();
      if (sys && sys.length >= 3) {
        if (sys.substring(0, 3).toLowerCase() === "win") {
          return true;
        }
      }
      return false;
    }
    async getDefaultServiceProjectId() {
      return new Promise((resolve) => {
        (0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout) => {
          if (!err && stdout) {
            try {
              const projectId = JSON.parse(stdout).configuration.properties.core.project;
              resolve(projectId);
              return;
            } catch (e) {}
          }
          resolve(null);
        });
      });
    }
    getProductionProjectId() {
      return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
    }
    async getFileProjectId() {
      if (this.cachedCredential) {
        return this.cachedCredential.projectId;
      }
      if (this.keyFilename) {
        const creds = await this.getClient();
        if (creds && creds.projectId) {
          return creds.projectId;
        }
      }
      const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
      if (r) {
        return r.projectId;
      } else {
        return null;
      }
    }
    async getExternalAccountClientProjectId() {
      if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
        return null;
      }
      const creds = await this.getClient();
      return await creds.getProjectId();
    }
    async getGCEProjectId() {
      try {
        const r = await gcpMetadata.project("project-id");
        return r;
      } catch (e) {
        return null;
      }
    }
    getCredentials(callback) {
      if (callback) {
        this.getCredentialsAsync().then((r) => callback(null, r), callback);
      } else {
        return this.getCredentialsAsync();
      }
    }
    async getCredentialsAsync() {
      const client = await this.getClient();
      if (client instanceof impersonated_1.Impersonated) {
        return { client_email: client.getTargetPrincipal() };
      }
      if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {
        const serviceAccountEmail = client.getServiceAccountEmail();
        if (serviceAccountEmail) {
          return {
            client_email: serviceAccountEmail,
            universe_domain: client.universeDomain
          };
        }
      }
      if (this.jsonContent) {
        return {
          client_email: this.jsonContent.client_email,
          private_key: this.jsonContent.private_key,
          universe_domain: this.jsonContent.universe_domain
        };
      }
      if (await this._checkIsGCE()) {
        const [client_email, universe_domain] = await Promise.all([
          gcpMetadata.instance("service-accounts/default/email"),
          this.getUniverseDomain()
        ]);
        return { client_email, universe_domain };
      }
      throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
    }
    async getClient() {
      if (this.cachedCredential) {
        return this.cachedCredential;
      }
      __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f") || __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_determineClient).call(this), "f");
      try {
        return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f");
      } finally {
        __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, "f");
      }
    }
    async getIdTokenClient(targetAudience) {
      const client = await this.getClient();
      if (!("fetchIdToken" in client)) {
        throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
      }
      return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });
    }
    async getAccessToken() {
      const client = await this.getClient();
      return (await client.getAccessToken()).token;
    }
    async getRequestHeaders(url) {
      const client = await this.getClient();
      return client.getRequestHeaders(url);
    }
    async authorizeRequest(opts) {
      opts = opts || {};
      const url = opts.url || opts.uri;
      const client = await this.getClient();
      const headers = await client.getRequestHeaders(url);
      opts.headers = Object.assign(opts.headers || {}, headers);
      return opts;
    }
    async request(opts) {
      const client = await this.getClient();
      return client.request(opts);
    }
    getEnv() {
      return (0, envDetect_1.getEnv)();
    }
    async sign(data, endpoint) {
      const client = await this.getClient();
      const universe = await this.getUniverseDomain();
      endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;
      if (client instanceof impersonated_1.Impersonated) {
        const signed = await client.sign(data);
        return signed.signedBlob;
      }
      const crypto2 = (0, crypto_1.createCrypto)();
      if (client instanceof jwtclient_1.JWT && client.key) {
        const sign = await crypto2.sign(client.key, data);
        return sign;
      }
      const creds = await this.getCredentials();
      if (!creds.client_email) {
        throw new Error("Cannot sign data without `client_email`.");
      }
      return this.signBlob(crypto2, creds.client_email, data, endpoint);
    }
    async signBlob(crypto2, emailOrUniqueId, data, endpoint) {
      const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);
      const res = await this.request({
        method: "POST",
        url: url.href,
        data: {
          payload: crypto2.encodeBase64StringUtf8(data)
        },
        retry: true,
        retryConfig: {
          httpMethodsToRetry: ["POST"]
        }
      });
      return res.data.signedBlob;
    }
  }
  exports.GoogleAuth = GoogleAuth;
  _GoogleAuth_pendingAuthClient = new WeakMap, _GoogleAuth_instances = new WeakSet, _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient(credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
    const projectId = await this.getProjectIdOptional();
    if (quotaProjectIdOverride) {
      credential.quotaProjectId = quotaProjectIdOverride;
    }
    this.cachedCredential = credential;
    return { credential, projectId };
  }, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient() {
    if (this.jsonContent) {
      return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
    } else if (this.keyFilename) {
      const filePath = path.resolve(this.keyFilename);
      const stream = fs.createReadStream(filePath);
      return await this.fromStreamAsync(stream, this.clientOptions);
    } else if (this.apiKey) {
      const client = await this.fromAPIKey(this.apiKey, this.clientOptions);
      client.scopes = this.scopes;
      const { credential } = await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, client);
      return credential;
    } else {
      const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);
      return credential;
    }
  };
  GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;
});

// node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IAMAuth = undefined;

  class IAMAuth {
    constructor(selector, token) {
      this.selector = selector;
      this.token = token;
      this.selector = selector;
      this.token = token;
    }
    getRequestHeaders() {
      return {
        "x-goog-iam-authority-selector": this.selector,
        "x-goog-iam-authorization-token": this.token
      };
    }
  }
  exports.IAMAuth = IAMAuth;
});

// node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = undefined;
  var stream = __require("stream");
  var authclient_1 = require_authclient();
  var sts = require_stscredentials();
  var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
  var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
  var STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
  exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
  exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;

  class DownscopedClient extends authclient_1.AuthClient {
    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {
      super({ ...additionalOptions, quotaProjectId });
      this.authClient = authClient;
      this.credentialAccessBoundary = credentialAccessBoundary;
      if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {
        throw new Error("At least one access boundary rule needs to be defined.");
      } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {
        throw new Error("The provided access boundary has more than " + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
      }
      for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {
        if (rule.availablePermissions.length === 0) {
          throw new Error("At least one permission should be defined in access boundary rules.");
        }
      }
      this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);
      this.cachedDownscopedAccessToken = null;
    }
    setCredentials(credentials) {
      if (!credentials.expiry_date) {
        throw new Error("The access token expiry_date field is missing in the provided " + "credentials.");
      }
      super.setCredentials(credentials);
      this.cachedDownscopedAccessToken = credentials;
    }
    async getAccessToken() {
      if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {
        await this.refreshAccessTokenAsync();
      }
      return {
        token: this.cachedDownscopedAccessToken.access_token,
        expirationTime: this.cachedDownscopedAccessToken.expiry_date,
        res: this.cachedDownscopedAccessToken.res
      };
    }
    async getRequestHeaders() {
      const accessTokenResponse = await this.getAccessToken();
      const headers = {
        Authorization: `Bearer ${accessTokenResponse.token}`
      };
      return this.addSharedMetadataHeaders(headers);
    }
    request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then((r) => callback(null, r), (e) => {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    async requestAsync(opts, reAuthRetried = false) {
      let response;
      try {
        const requestHeaders = await this.getRequestHeaders();
        opts.headers = opts.headers || {};
        if (requestHeaders && requestHeaders["x-goog-user-project"]) {
          opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
        }
        if (requestHeaders && requestHeaders.Authorization) {
          opts.headers.Authorization = requestHeaders.Authorization;
        }
        response = await this.transporter.request(opts);
      } catch (e) {
        const res = e.response;
        if (res) {
          const statusCode = res.status;
          const isReadableStream = res.config.data instanceof stream.Readable;
          const isAuthErr = statusCode === 401 || statusCode === 403;
          if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
            await this.refreshAccessTokenAsync();
            return await this.requestAsync(opts, true);
          }
        }
        throw e;
      }
      return response;
    }
    async refreshAccessTokenAsync() {
      var _a;
      const subjectToken = (await this.authClient.getAccessToken()).token;
      const stsCredentialsOptions = {
        grantType: STS_GRANT_TYPE,
        requestedTokenType: STS_REQUEST_TOKEN_TYPE,
        subjectToken,
        subjectTokenType: STS_SUBJECT_TOKEN_TYPE
      };
      const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);
      const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === undefined ? undefined : _a.expiry_date) || null;
      const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate;
      this.cachedDownscopedAccessToken = {
        access_token: stsResponse.access_token,
        expiry_date: expiryDate,
        res: stsResponse.res
      };
      this.credentials = {};
      Object.assign(this.credentials, this.cachedDownscopedAccessToken);
      delete this.credentials.res;
      this.emit("tokens", {
        refresh_token: null,
        expiry_date: this.cachedDownscopedAccessToken.expiry_date,
        access_token: this.cachedDownscopedAccessToken.access_token,
        token_type: "Bearer",
        id_token: null
      });
      return this.cachedDownscopedAccessToken;
    }
    isExpired(downscopedAccessToken) {
      const now = new Date().getTime();
      return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
  }
  exports.DownscopedClient = DownscopedClient;
});

// node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PassThroughClient = undefined;
  var authclient_1 = require_authclient();

  class PassThroughClient extends authclient_1.AuthClient {
    async request(opts) {
      return this.transporter.request(opts);
    }
    async getAccessToken() {
      return {};
    }
    async getRequestHeaders() {
      return {};
    }
  }
  exports.PassThroughClient = PassThroughClient;
  var a = new PassThroughClient;
  a.getAccessToken();
});

// node_modules/google-auth-library/build/src/index.js
var require_src7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PassThroughClient = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = undefined;
  var googleauth_1 = require_googleauth();
  Object.defineProperty(exports, "GoogleAuth", { enumerable: true, get: function() {
    return googleauth_1.GoogleAuth;
  } });
  exports.gcpMetadata = require_src5();
  exports.gaxios = require_src3();
  var authclient_1 = require_authclient();
  Object.defineProperty(exports, "AuthClient", { enumerable: true, get: function() {
    return authclient_1.AuthClient;
  } });
  Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
    return authclient_1.DEFAULT_UNIVERSE;
  } });
  var computeclient_1 = require_computeclient();
  Object.defineProperty(exports, "Compute", { enumerable: true, get: function() {
    return computeclient_1.Compute;
  } });
  var envDetect_1 = require_envDetect();
  Object.defineProperty(exports, "GCPEnv", { enumerable: true, get: function() {
    return envDetect_1.GCPEnv;
  } });
  var iam_1 = require_iam();
  Object.defineProperty(exports, "IAMAuth", { enumerable: true, get: function() {
    return iam_1.IAMAuth;
  } });
  var idtokenclient_1 = require_idtokenclient();
  Object.defineProperty(exports, "IdTokenClient", { enumerable: true, get: function() {
    return idtokenclient_1.IdTokenClient;
  } });
  var jwtaccess_1 = require_jwtaccess();
  Object.defineProperty(exports, "JWTAccess", { enumerable: true, get: function() {
    return jwtaccess_1.JWTAccess;
  } });
  var jwtclient_1 = require_jwtclient();
  Object.defineProperty(exports, "JWT", { enumerable: true, get: function() {
    return jwtclient_1.JWT;
  } });
  var impersonated_1 = require_impersonated();
  Object.defineProperty(exports, "Impersonated", { enumerable: true, get: function() {
    return impersonated_1.Impersonated;
  } });
  var oauth2client_1 = require_oauth2client();
  Object.defineProperty(exports, "CodeChallengeMethod", { enumerable: true, get: function() {
    return oauth2client_1.CodeChallengeMethod;
  } });
  Object.defineProperty(exports, "OAuth2Client", { enumerable: true, get: function() {
    return oauth2client_1.OAuth2Client;
  } });
  Object.defineProperty(exports, "ClientAuthentication", { enumerable: true, get: function() {
    return oauth2client_1.ClientAuthentication;
  } });
  var loginticket_1 = require_loginticket();
  Object.defineProperty(exports, "LoginTicket", { enumerable: true, get: function() {
    return loginticket_1.LoginTicket;
  } });
  var refreshclient_1 = require_refreshclient();
  Object.defineProperty(exports, "UserRefreshClient", { enumerable: true, get: function() {
    return refreshclient_1.UserRefreshClient;
  } });
  var awsclient_1 = require_awsclient();
  Object.defineProperty(exports, "AwsClient", { enumerable: true, get: function() {
    return awsclient_1.AwsClient;
  } });
  var awsrequestsigner_1 = require_awsrequestsigner();
  Object.defineProperty(exports, "AwsRequestSigner", { enumerable: true, get: function() {
    return awsrequestsigner_1.AwsRequestSigner;
  } });
  var identitypoolclient_1 = require_identitypoolclient();
  Object.defineProperty(exports, "IdentityPoolClient", { enumerable: true, get: function() {
    return identitypoolclient_1.IdentityPoolClient;
  } });
  var externalclient_1 = require_externalclient();
  Object.defineProperty(exports, "ExternalAccountClient", { enumerable: true, get: function() {
    return externalclient_1.ExternalAccountClient;
  } });
  var baseexternalclient_1 = require_baseexternalclient();
  Object.defineProperty(exports, "BaseExternalAccountClient", { enumerable: true, get: function() {
    return baseexternalclient_1.BaseExternalAccountClient;
  } });
  var downscopedclient_1 = require_downscopedclient();
  Object.defineProperty(exports, "DownscopedClient", { enumerable: true, get: function() {
    return downscopedclient_1.DownscopedClient;
  } });
  var pluggable_auth_client_1 = require_pluggable_auth_client();
  Object.defineProperty(exports, "PluggableAuthClient", { enumerable: true, get: function() {
    return pluggable_auth_client_1.PluggableAuthClient;
  } });
  Object.defineProperty(exports, "ExecutableError", { enumerable: true, get: function() {
    return pluggable_auth_client_1.ExecutableError;
  } });
  var passthrough_1 = require_passthrough();
  Object.defineProperty(exports, "PassThroughClient", { enumerable: true, get: function() {
    return passthrough_1.PassThroughClient;
  } });
  var transporters_1 = require_transporters();
  Object.defineProperty(exports, "DefaultTransporter", { enumerable: true, get: function() {
    return transporters_1.DefaultTransporter;
  } });
  var auth = new googleauth_1.GoogleAuth;
  exports.auth = auth;
});

// node_modules/dotenv/package.json
var require_package4 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "17.2.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var path2 = __require("path");
  var os = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package4();
  var version = packageJson.version;
  var TIPS = [
    "\uD83D\uDD10 encrypt with Dotenvx: https://dotenvx.com",
    "\uD83D\uDD10 prevent committing .env to code: https://dotenvx.com/precommit",
    "\uD83D\uDD10 prevent building .env in docker: https://dotenvx.com/prebuild",
    "\uD83D\uDCE1 observe env with Radar: https://dotenvx.com/radar",
    "\uD83D\uDCE1 auto-backup env with Radar: https://dotenvx.com/radar",
    "\uD83D\uDCE1 version env with Radar: https://dotenvx.com/radar",
    "\uD83D\uDEE0️  run anywhere with `dotenvx run -- yourcommand`",
    "⚙️  specify custom .env file path with { path: '/custom/path/.env' }",
    "⚙️  enable debug logging with { debug: true }",
    "⚙️  override existing env vars with { override: true }",
    "⚙️  suppress all logs with { quiet: true }",
    "⚙️  write to custom object with { processEnv: myObject }",
    "⚙️  load multiple .env files with { path: ['.env.local', '.env'] }"
  ];
  function _getRandomTip() {
    return TIPS[Math.floor(Math.random() * TIPS.length)];
  }
  function parseBoolean(value) {
    if (typeof value === "string") {
      return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
    }
    return Boolean(value);
  }
  function supportsAnsi() {
    return process.stdout.isTTY;
  }
  function dim(text) {
    return supportsAnsi() ? `\x1B[2m${text}\x1B[0m` : text;
  }
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath;
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.error(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs3.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
    }
    if (fs3.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path2.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (debug || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path2.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path3 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs3.readFileSync(path3, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path3} ${e.message}`);
        }
        lastError = e;
      }
    }
    const populated = DotenvModule.populate(processEnv, parsedAll, options);
    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
    if (debug || !quiet) {
      const keysCount = Object.keys(populated).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path2.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    const populated = {};
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
          populated[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
        populated[key] = parsed[key];
      }
    }
    return populated;
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// src/main.ts
var import_discord = __toESM(require_src(), 1);

// node_modules/@google/generative-ai/dist/index.mjs
var SchemaType;
(function(SchemaType2) {
  SchemaType2["STRING"] = "string";
  SchemaType2["NUMBER"] = "number";
  SchemaType2["INTEGER"] = "integer";
  SchemaType2["BOOLEAN"] = "boolean";
  SchemaType2["ARRAY"] = "array";
  SchemaType2["OBJECT"] = "object";
})(SchemaType || (SchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var POSSIBLE_ROLES = ["user", "model", "function", "system"];
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
var DynamicRetrievalMode;
(function(DynamicRetrievalMode2) {
  DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));

class GoogleGenerativeAIError extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
}

class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}

class GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
}

class GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {
}

class GoogleGenerativeAIAbortError extends GoogleGenerativeAIError {
}
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.24.1";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));

class RequestUrl {
  constructor(model, task, apiKey, stream, requestOptions) {
    this.model = model;
    this.task = task;
    this.apiKey = apiKey;
    this.stream = stream;
    this.requestOptions = requestOptions;
  }
  toString() {
    var _a, _b;
    const apiVersion = ((_a = this.requestOptions) === null || _a === undefined ? undefined : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === undefined ? undefined : _b.baseUrl) || DEFAULT_BASE_URL;
    let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
    if (this.stream) {
      url += "?alt=sse";
    }
    return url;
  }
}
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  var _a;
  const headers = new Headers;
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = (_a = url.requestOptions) === null || _a === undefined ? undefined : _a.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
  const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
  return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (err.name === "AbortError") {
    err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json = await response.json();
    message = json.error.message;
    if (json.error.details) {
      message += ` ${JSON.stringify(json.error.details)}`;
      errorDetails = json.error.details;
    }
  } catch (e) {}
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === undefined ? undefined : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.timeout) >= 0) {
    const controller = new AbortController;
    if ((requestOptions === null || requestOptions === undefined ? undefined : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    fetchOptions.signal = controller.signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning text from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. ` + `Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return;
  };
  return response;
}
function getText(response) {
  var _a, _b, _c, _d;
  const textStrings = [];
  if ((_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === undefined ? undefined : _c[0].content) === null || _d === undefined ? undefined : _d.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
      if (part.executableCode) {
        textStrings.push("\n```" + part.executableCode.language + `
` + part.executableCode.code + "\n```\n");
      }
      if (part.codeExecutionResult) {
        textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a, _b, _c, _d;
  const functionCalls = [];
  if ((_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === undefined ? undefined : _c[0].content) === null || _d === undefined ? undefined : _d.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return;
  }
}
var badFinishReasons = [
  FinishReason.RECITATION,
  FinishReason.SAFETY,
  FinishReason.LANGUAGE
];
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a, _b, _c;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a = response.promptFeedback) === null || _a === undefined ? undefined : _a.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === undefined ? undefined : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c = response.candidates) === null || _c === undefined ? undefined : _c[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value;
          let match = currentText.match(responseLineRE);
          let parsedResponse;
          while (match) {
            try {
              parsedResponse = JSON.parse(match[1]);
            } catch (e) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match[0].length);
            match = currentText.match(responseLineRE);
          }
          return pump();
        }).catch((e) => {
          let err = e;
          err.stack = e.stack;
          if (err.name === "AbortError") {
            err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
          } else {
            err = new GoogleGenerativeAIError("Error reading from the stream");
          }
          throw err;
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === undefined ? undefined : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      let candidateIndex = 0;
      for (const candidate of response.candidates) {
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[candidateIndex]) {
          aggregatedResponse.candidates[candidateIndex] = {
            index: candidateIndex
          };
        }
        aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
        aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[candidateIndex].content) {
            aggregatedResponse.candidates[candidateIndex].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (part.executableCode) {
              newPart.executableCode = part.executableCode;
            }
            if (part.codeExecutionResult) {
              newPart.codeExecutionResult = part.codeExecutionResult;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
          }
        }
      }
      candidateIndex++;
    }
    if (response.usageMetadata) {
      aggregatedResponse.usageMetadata = response.usageMetadata;
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, true, JSON.stringify(params), requestOptions);
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request) {
  let newParts = [];
  if (typeof request === "string") {
    newParts = [{ text: request }];
  } else {
    for (const partOrString of request) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatCountTokensInput(params, modelParams) {
  var _a;
  let formattedGenerateContentRequest = {
    model: modelParams === null || modelParams === undefined ? undefined : modelParams.model,
    generationConfig: modelParams === null || modelParams === undefined ? undefined : modelParams.generationConfig,
    safetySettings: modelParams === null || modelParams === undefined ? undefined : modelParams.safetySettings,
    tools: modelParams === null || modelParams === undefined ? undefined : modelParams.tools,
    toolConfig: modelParams === null || modelParams === undefined ? undefined : modelParams.toolConfig,
    systemInstruction: modelParams === null || modelParams === undefined ? undefined : modelParams.systemInstruction,
    cachedContent: (_a = modelParams === null || modelParams === undefined ? undefined : modelParams.cachedContent) === null || _a === undefined ? undefined : _a.name,
    contents: []
  };
  const containsGenerateContentRequest = params.generateContentRequest != null;
  if (params.contents) {
    if (containsGenerateContentRequest) {
      throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    }
    formattedGenerateContentRequest.contents = params.contents;
  } else if (containsGenerateContentRequest) {
    formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
  } else {
    const content = formatNewContent(params);
    formattedGenerateContentRequest.contents = [content];
  }
  return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
var VALID_PART_FIELDS = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
];
var VALID_PARTS_PER_ROLE = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  system: ["text"]
};
function validateChatHistory(history) {
  let prevContent = false;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    prevContent = true;
  }
}
function isValidResponse(response) {
  var _a;
  if (response.candidates === undefined || response.candidates.length === 0) {
    return false;
  }
  const content = (_a = response.candidates[0]) === null || _a === undefined ? undefined : _a.content;
  if (content === undefined) {
    return false;
  }
  if (content.parts === undefined || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === undefined || Object.keys(part).length === 0) {
      return false;
    }
    if (part.text !== undefined && part.text === "") {
      return false;
    }
  }
  return true;
}
var SILENT_ERROR = "SILENT_ERROR";

class ChatSession {
  constructor(apiKey, model, params, _requestOptions = {}) {
    this.model = model;
    this.params = params;
    this._requestOptions = _requestOptions;
    this._history = [];
    this._sendPromise = Promise.resolve();
    this._apiKey = apiKey;
    if (params === null || params === undefined ? undefined : params.history) {
      validateChatHistory(params.history);
      this._history = params.history;
    }
  }
  async getHistory() {
    await this._sendPromise;
    return this._history;
  }
  async sendMessage(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
      tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
      toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === undefined ? undefined : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    let finalResult;
    this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
      var _a2;
      if (isValidResponse(result.response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({
          parts: [],
          role: "model"
        }, (_a2 = result.response.candidates) === null || _a2 === undefined ? undefined : _a2[0].content);
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(result.response);
        if (blockErrorMessage) {
          console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
      finalResult = result;
    }).catch((e) => {
      this._sendPromise = Promise.resolve();
      throw e;
    });
    await this._sendPromise;
    return finalResult;
  }
  async sendMessageStream(request, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
      tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
      toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === undefined ? undefined : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
    this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
      throw new Error(SILENT_ERROR);
    }).then((streamResult) => streamResult.response).then((response) => {
      if (isValidResponse(response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({}, response.candidates[0].content);
        if (!responseContent.role) {
          responseContent.role = "model";
        }
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(response);
        if (blockErrorMessage) {
          console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
    }).catch((e) => {
      if (e.message !== SILENT_ERROR) {
        console.error(e);
      }
    });
    return streamPromise;
  }
}
async function countTokens(apiKey, model, params, singleRequestOptions) {
  const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request) => {
    return Object.assign(Object.assign({}, request), { model });
  });
  const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}

class GenerativeModel {
  constructor(apiKey, modelParams, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
    if (modelParams.model.includes("/")) {
      this.model = modelParams.model;
    } else {
      this.model = `models/${modelParams.model}`;
    }
    this.generationConfig = modelParams.generationConfig || {};
    this.safetySettings = modelParams.safetySettings || [];
    this.tools = modelParams.tools;
    this.toolConfig = modelParams.toolConfig;
    this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
    this.cachedContent = modelParams.cachedContent;
  }
  async generateContent(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  async generateContentStream(request, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  startChat(startChatParams) {
    var _a;
    return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, startChatParams), this._requestOptions);
  }
  async countTokens(request, requestOptions = {}) {
    const formattedParams = formatCountTokensInput(request, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    });
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  async embedContent(request, requestOptions = {}) {
    const formattedParams = formatEmbedContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
  }
}

class GoogleGenerativeAI {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  getGenerativeModel(modelParams, requestOptions) {
    if (!modelParams.model) {
      throw new GoogleGenerativeAIError(`Must provide a model name. ` + `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
    }
    return new GenerativeModel(this.apiKey, modelParams, requestOptions);
  }
  getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
    if (!cachedContent.name) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
    }
    if (!cachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    const disallowedDuplicates = ["model", "systemInstruction"];
    for (const key of disallowedDuplicates) {
      if ((modelParams === null || modelParams === undefined ? undefined : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === undefined ? undefined : modelParams[key]) !== cachedContent[key]) {
        if (key === "model") {
          const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
          const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
          if (modelParamsComp === cachedContentComp) {
            continue;
          }
        }
        throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams` + ` (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
      }
    }
    const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
    return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
  }
}

// node_modules/@google/genai/dist/node/index.mjs
var import_google_auth_library = __toESM(require_src7(), 1);
import { createWriteStream, writeFile } from "fs";
import { Readable } from "node:stream";

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver2(), 1);
var import_sender = __toESM(require_sender2(), 1);
var import_websocket = __toESM(require_websocket2(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// node_modules/@google/genai/dist/node/index.mjs
import * as fs from "fs/promises";
var _defaultBaseGeminiUrl = undefined;
var _defaultBaseVertexUrl = undefined;
function getDefaultBaseUrls() {
  return {
    geminiUrl: _defaultBaseGeminiUrl,
    vertexUrl: _defaultBaseVertexUrl
  };
}
function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
  var _a, _b;
  if (!(httpOptions === null || httpOptions === undefined ? undefined : httpOptions.baseUrl)) {
    const defaultBaseUrls = getDefaultBaseUrls();
    if (vertexai) {
      return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== undefined ? _a : vertexBaseUrlFromEnv;
    } else {
      return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== undefined ? _b : geminiBaseUrlFromEnv;
    }
  }
  return httpOptions.baseUrl;
}

class BaseModule {
}
function formatMap(templateString, valueMap) {
  const regex = /\{([^}]+)\}/g;
  return templateString.replace(regex, (match, key) => {
    if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
      const value = valueMap[key];
      return value !== undefined && value !== null ? String(value) : "";
    } else {
      throw new Error(`Key '${key}' not found in valueMap.`);
    }
  });
}
function setValueByPath(data, keys, value) {
  for (let i = 0;i < keys.length - 1; i++) {
    const key = keys[i];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      if (!(keyName in data)) {
        if (Array.isArray(value)) {
          data[keyName] = Array.from({ length: value.length }, () => ({}));
        } else {
          throw new Error(`Value must be a list given an array path ${key}`);
        }
      }
      if (Array.isArray(data[keyName])) {
        const arrayData = data[keyName];
        if (Array.isArray(value)) {
          for (let j = 0;j < arrayData.length; j++) {
            const entry = arrayData[j];
            setValueByPath(entry, keys.slice(i + 1), value[j]);
          }
        } else {
          for (const d of arrayData) {
            setValueByPath(d, keys.slice(i + 1), value);
          }
        }
      }
      return;
    } else if (key.endsWith("[0]")) {
      const keyName = key.slice(0, -3);
      if (!(keyName in data)) {
        data[keyName] = [{}];
      }
      const arrayData = data[keyName];
      setValueByPath(arrayData[0], keys.slice(i + 1), value);
      return;
    }
    if (!data[key] || typeof data[key] !== "object") {
      data[key] = {};
    }
    data = data[key];
  }
  const keyToSet = keys[keys.length - 1];
  const existingData = data[keyToSet];
  if (existingData !== undefined) {
    if (!value || typeof value === "object" && Object.keys(value).length === 0) {
      return;
    }
    if (value === existingData) {
      return;
    }
    if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
      Object.assign(existingData, value);
    } else {
      throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
    }
  } else {
    data[keyToSet] = value;
  }
}
function getValueByPath(data, keys) {
  try {
    if (keys.length === 1 && keys[0] === "_self") {
      return data;
    }
    for (let i = 0;i < keys.length; i++) {
      if (typeof data !== "object" || data === null) {
        return;
      }
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (keyName in data) {
          const arrayData = data[keyName];
          if (!Array.isArray(arrayData)) {
            return;
          }
          return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1)));
        } else {
          return;
        }
      } else {
        data = data[key];
      }
    }
    return data;
  } catch (error) {
    if (error instanceof TypeError) {
      return;
    }
    throw error;
  }
}
function tBytes$1(fromBytes) {
  if (typeof fromBytes !== "string") {
    throw new Error("fromImageBytes must be a string");
  }
  return fromBytes;
}
var Outcome2;
(function(Outcome3) {
  Outcome3["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
  Outcome3["OUTCOME_OK"] = "OUTCOME_OK";
  Outcome3["OUTCOME_FAILED"] = "OUTCOME_FAILED";
  Outcome3["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
})(Outcome2 || (Outcome2 = {}));
var Language;
(function(Language2) {
  Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
  Language2["PYTHON"] = "PYTHON";
})(Language || (Language = {}));
var Type;
(function(Type2) {
  Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
  Type2["STRING"] = "STRING";
  Type2["NUMBER"] = "NUMBER";
  Type2["INTEGER"] = "INTEGER";
  Type2["BOOLEAN"] = "BOOLEAN";
  Type2["ARRAY"] = "ARRAY";
  Type2["OBJECT"] = "OBJECT";
  Type2["NULL"] = "NULL";
})(Type || (Type = {}));
var HarmCategory2;
(function(HarmCategory3) {
  HarmCategory3["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory3["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory3["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory3["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory3["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory3["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
  HarmCategory3["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
  HarmCategory3["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
  HarmCategory3["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
  HarmCategory3["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
})(HarmCategory2 || (HarmCategory2 = {}));
var HarmBlockMethod;
(function(HarmBlockMethod2) {
  HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
  HarmBlockMethod2["SEVERITY"] = "SEVERITY";
  HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
})(HarmBlockMethod || (HarmBlockMethod = {}));
var HarmBlockThreshold2;
(function(HarmBlockThreshold3) {
  HarmBlockThreshold3["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold3["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold3["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold3["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold3["BLOCK_NONE"] = "BLOCK_NONE";
  HarmBlockThreshold3["OFF"] = "OFF";
})(HarmBlockThreshold2 || (HarmBlockThreshold2 = {}));
var Mode;
(function(Mode2) {
  Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(Mode || (Mode = {}));
var AuthType;
(function(AuthType2) {
  AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
  AuthType2["NO_AUTH"] = "NO_AUTH";
  AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
  AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
  AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
  AuthType2["OAUTH"] = "OAUTH";
  AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
})(AuthType || (AuthType = {}));
var ApiSpec;
(function(ApiSpec2) {
  ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
  ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
  ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
})(ApiSpec || (ApiSpec = {}));
var Environment;
(function(Environment2) {
  Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
  Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
})(Environment || (Environment = {}));
var UrlRetrievalStatus;
(function(UrlRetrievalStatus2) {
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
var FinishReason2;
(function(FinishReason3) {
  FinishReason3["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason3["STOP"] = "STOP";
  FinishReason3["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason3["SAFETY"] = "SAFETY";
  FinishReason3["RECITATION"] = "RECITATION";
  FinishReason3["LANGUAGE"] = "LANGUAGE";
  FinishReason3["OTHER"] = "OTHER";
  FinishReason3["BLOCKLIST"] = "BLOCKLIST";
  FinishReason3["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason3["SPII"] = "SPII";
  FinishReason3["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason3["IMAGE_SAFETY"] = "IMAGE_SAFETY";
  FinishReason3["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
})(FinishReason2 || (FinishReason2 = {}));
var HarmProbability2;
(function(HarmProbability3) {
  HarmProbability3["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability3["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability3["LOW"] = "LOW";
  HarmProbability3["MEDIUM"] = "MEDIUM";
  HarmProbability3["HIGH"] = "HIGH";
})(HarmProbability2 || (HarmProbability2 = {}));
var HarmSeverity;
(function(HarmSeverity2) {
  HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
  HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
  HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
  HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
  HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
})(HarmSeverity || (HarmSeverity = {}));
var BlockedReason;
(function(BlockedReason2) {
  BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockedReason2["SAFETY"] = "SAFETY";
  BlockedReason2["OTHER"] = "OTHER";
  BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
  BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
})(BlockedReason || (BlockedReason = {}));
var TrafficType;
(function(TrafficType2) {
  TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
  TrafficType2["ON_DEMAND"] = "ON_DEMAND";
  TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
})(TrafficType || (TrafficType = {}));
var Modality;
(function(Modality2) {
  Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  Modality2["TEXT"] = "TEXT";
  Modality2["IMAGE"] = "IMAGE";
  Modality2["AUDIO"] = "AUDIO";
})(Modality || (Modality = {}));
var MediaResolution;
(function(MediaResolution2) {
  MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
  MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
  MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
  MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
})(MediaResolution || (MediaResolution = {}));
var JobState;
(function(JobState2) {
  JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
  JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
  JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
  JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
  JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
  JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
  JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
  JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
  JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
  JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
  JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
  JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(JobState || (JobState = {}));
var AdapterSize;
(function(AdapterSize2) {
  AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
  AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
  AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
  AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
  AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
  AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
  AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
})(AdapterSize || (AdapterSize = {}));
var FeatureSelectionPreference;
(function(FeatureSelectionPreference2) {
  FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
  FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
  FeatureSelectionPreference2["BALANCED"] = "BALANCED";
  FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
var Behavior;
(function(Behavior2) {
  Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
  Behavior2["BLOCKING"] = "BLOCKING";
  Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
})(Behavior || (Behavior = {}));
var DynamicRetrievalConfigMode;
(function(DynamicRetrievalConfigMode2) {
  DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
var FunctionCallingConfigMode;
(function(FunctionCallingConfigMode2) {
  FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingConfigMode2["AUTO"] = "AUTO";
  FunctionCallingConfigMode2["ANY"] = "ANY";
  FunctionCallingConfigMode2["NONE"] = "NONE";
})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
var SafetyFilterLevel;
(function(SafetyFilterLevel2) {
  SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
})(SafetyFilterLevel || (SafetyFilterLevel = {}));
var PersonGeneration;
(function(PersonGeneration2) {
  PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
  PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
  PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
})(PersonGeneration || (PersonGeneration = {}));
var ImagePromptLanguage;
(function(ImagePromptLanguage2) {
  ImagePromptLanguage2["auto"] = "auto";
  ImagePromptLanguage2["en"] = "en";
  ImagePromptLanguage2["ja"] = "ja";
  ImagePromptLanguage2["ko"] = "ko";
  ImagePromptLanguage2["hi"] = "hi";
  ImagePromptLanguage2["zh"] = "zh";
  ImagePromptLanguage2["pt"] = "pt";
  ImagePromptLanguage2["es"] = "es";
})(ImagePromptLanguage || (ImagePromptLanguage = {}));
var MaskReferenceMode;
(function(MaskReferenceMode2) {
  MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
  MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
  MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
  MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
  MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
})(MaskReferenceMode || (MaskReferenceMode = {}));
var ControlReferenceType;
(function(ControlReferenceType2) {
  ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
  ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
  ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
  ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
})(ControlReferenceType || (ControlReferenceType = {}));
var SubjectReferenceType;
(function(SubjectReferenceType2) {
  SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
  SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
  SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
  SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
})(SubjectReferenceType || (SubjectReferenceType = {}));
var EditMode;
(function(EditMode2) {
  EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
  EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
  EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
  EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
  EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
  EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
  EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
  EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
})(EditMode || (EditMode = {}));
var VideoCompressionQuality;
(function(VideoCompressionQuality2) {
  VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
  VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
})(VideoCompressionQuality || (VideoCompressionQuality = {}));
var FileState;
(function(FileState2) {
  FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  FileState2["PROCESSING"] = "PROCESSING";
  FileState2["ACTIVE"] = "ACTIVE";
  FileState2["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
var FileSource;
(function(FileSource2) {
  FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
  FileSource2["UPLOADED"] = "UPLOADED";
  FileSource2["GENERATED"] = "GENERATED";
})(FileSource || (FileSource = {}));
var MediaModality;
(function(MediaModality2) {
  MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  MediaModality2["TEXT"] = "TEXT";
  MediaModality2["IMAGE"] = "IMAGE";
  MediaModality2["VIDEO"] = "VIDEO";
  MediaModality2["AUDIO"] = "AUDIO";
  MediaModality2["DOCUMENT"] = "DOCUMENT";
})(MediaModality || (MediaModality = {}));
var StartSensitivity;
(function(StartSensitivity2) {
  StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
  StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
  StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
})(StartSensitivity || (StartSensitivity = {}));
var EndSensitivity;
(function(EndSensitivity2) {
  EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
  EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
  EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
})(EndSensitivity || (EndSensitivity = {}));
var ActivityHandling;
(function(ActivityHandling2) {
  ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
  ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
  ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
})(ActivityHandling || (ActivityHandling = {}));
var TurnCoverage;
(function(TurnCoverage2) {
  TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
  TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
  TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
})(TurnCoverage || (TurnCoverage = {}));
var FunctionResponseScheduling;
(function(FunctionResponseScheduling2) {
  FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
  FunctionResponseScheduling2["SILENT"] = "SILENT";
  FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
  FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
var Scale;
(function(Scale2) {
  Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
  Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
  Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
  Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
  Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
  Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
  Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
  Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
  Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
  Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
  Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
  Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
  Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
})(Scale || (Scale = {}));
var LiveMusicPlaybackControl;
(function(LiveMusicPlaybackControl2) {
  LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
  LiveMusicPlaybackControl2["PLAY"] = "PLAY";
  LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
  LiveMusicPlaybackControl2["STOP"] = "STOP";
  LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
class HttpResponse {
  constructor(response) {
    const headers = {};
    for (const pair of response.headers.entries()) {
      headers[pair[0]] = pair[1];
    }
    this.headers = headers;
    this.responseInternal = response;
  }
  json() {
    return this.responseInternal.json();
  }
}
class GenerateContentResponse {
  get text() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) === null || _c === undefined ? undefined : _c.parts) === null || _d === undefined ? undefined : _d.length) === 0) {
      return;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning text from the first one.");
    }
    let text = "";
    let anyTextPartText = false;
    const nonTextParts = [];
    for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === undefined ? undefined : _e[0]) === null || _f === undefined ? undefined : _f.content) === null || _g === undefined ? undefined : _g.parts) !== null && _h !== undefined ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && (fieldValue !== null || fieldValue !== undefined)) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartText = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartText ? text : undefined;
  }
  get data() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) === null || _c === undefined ? undefined : _c.parts) === null || _d === undefined ? undefined : _d.length) === 0) {
      return;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning data from the first one.");
    }
    let data = "";
    const nonDataParts = [];
    for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === undefined ? undefined : _e[0]) === null || _f === undefined ? undefined : _f.content) === null || _g === undefined ? undefined : _g.parts) !== null && _h !== undefined ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== undefined)) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : undefined;
  }
  get functionCalls() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) === null || _c === undefined ? undefined : _c.parts) === null || _d === undefined ? undefined : _d.length) === 0) {
      return;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning function calls from the first one.");
    }
    const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === undefined ? undefined : _e[0]) === null || _f === undefined ? undefined : _f.content) === null || _g === undefined ? undefined : _g.parts) === null || _h === undefined ? undefined : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== undefined);
    if ((functionCalls === null || functionCalls === undefined ? undefined : functionCalls.length) === 0) {
      return;
    }
    return functionCalls;
  }
  get executableCode() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) === null || _c === undefined ? undefined : _c.parts) === null || _d === undefined ? undefined : _d.length) === 0) {
      return;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning executable code from the first one.");
    }
    const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === undefined ? undefined : _e[0]) === null || _f === undefined ? undefined : _f.content) === null || _g === undefined ? undefined : _g.parts) === null || _h === undefined ? undefined : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== undefined);
    if ((executableCode === null || executableCode === undefined ? undefined : executableCode.length) === 0) {
      return;
    }
    return (_j = executableCode === null || executableCode === undefined ? undefined : executableCode[0]) === null || _j === undefined ? undefined : _j.code;
  }
  get codeExecutionResult() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) === null || _c === undefined ? undefined : _c.parts) === null || _d === undefined ? undefined : _d.length) === 0) {
      return;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
    }
    const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === undefined ? undefined : _e[0]) === null || _f === undefined ? undefined : _f.content) === null || _g === undefined ? undefined : _g.parts) === null || _h === undefined ? undefined : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== undefined);
    if ((codeExecutionResult === null || codeExecutionResult === undefined ? undefined : codeExecutionResult.length) === 0) {
      return;
    }
    return (_j = codeExecutionResult === null || codeExecutionResult === undefined ? undefined : codeExecutionResult[0]) === null || _j === undefined ? undefined : _j.output;
  }
}

class EmbedContentResponse {
}

class GenerateImagesResponse {
}

class EditImageResponse {
}

class UpscaleImageResponse {
}

class ListModelsResponse {
}

class DeleteModelResponse {
}

class CountTokensResponse {
}

class ComputeTokensResponse {
}

class GenerateVideosResponse {
}

class ListTuningJobsResponse {
}

class DeleteCachedContentResponse {
}

class ListCachedContentsResponse {
}

class ListFilesResponse {
}

class CreateFileResponse {
}

class DeleteFileResponse {
}
class ListBatchJobsResponse {
}
class LiveServerMessage {
  get text() {
    var _a, _b, _c;
    let text = "";
    let anyTextPartFound = false;
    const nonTextParts = [];
    for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === undefined ? undefined : _a.modelTurn) === null || _b === undefined ? undefined : _b.parts) !== null && _c !== undefined ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartFound = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartFound ? text : undefined;
  }
  get data() {
    var _a, _b, _c;
    let data = "";
    const nonDataParts = [];
    for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === undefined ? undefined : _a.modelTurn) === null || _b === undefined ? undefined : _b.parts) !== null && _c !== undefined ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && fieldValue !== null) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : undefined;
  }
}

class GenerateVideosOperation {
  _fromAPIResponse({ apiResponse, isVertexAI }) {
    const operation = new GenerateVideosOperation;
    operation.name = apiResponse["name"];
    operation.metadata = apiResponse["metadata"];
    operation.done = apiResponse["done"];
    operation.error = apiResponse["error"];
    if (isVertexAI) {
      const response = apiResponse["response"];
      if (response) {
        const operationResponse = new GenerateVideosResponse;
        const responseVideos = response["videos"];
        operationResponse.generatedVideos = responseVideos === null || responseVideos === undefined ? undefined : responseVideos.map((generatedVideo) => {
          return {
            video: {
              uri: generatedVideo["gcsUri"],
              videoBytes: generatedVideo["bytesBase64Encoded"] ? tBytes$1(generatedVideo["bytesBase64Encoded"]) : undefined,
              mimeType: generatedVideo["mimeType"]
            }
          };
        });
        operationResponse.raiMediaFilteredCount = response["raiMediaFilteredCount"];
        operationResponse.raiMediaFilteredReasons = response["raiMediaFilteredReasons"];
        operation.response = operationResponse;
      }
    } else {
      const response = apiResponse["response"];
      if (response) {
        const operationResponse = new GenerateVideosResponse;
        const generatedVideoResponse = response["generateVideoResponse"];
        const responseVideos = generatedVideoResponse === null || generatedVideoResponse === undefined ? undefined : generatedVideoResponse["generatedSamples"];
        operationResponse.generatedVideos = responseVideos === null || responseVideos === undefined ? undefined : responseVideos.map((generatedVideo) => {
          const video = generatedVideo["video"];
          return {
            video: {
              uri: video === null || video === undefined ? undefined : video["uri"],
              videoBytes: (video === null || video === undefined ? undefined : video["encodedVideo"]) ? tBytes$1(video === null || video === undefined ? undefined : video["encodedVideo"]) : undefined,
              mimeType: generatedVideo["encoding"]
            }
          };
        });
        operationResponse.raiMediaFilteredCount = generatedVideoResponse === null || generatedVideoResponse === undefined ? undefined : generatedVideoResponse["raiMediaFilteredCount"];
        operationResponse.raiMediaFilteredReasons = generatedVideoResponse === null || generatedVideoResponse === undefined ? undefined : generatedVideoResponse["raiMediaFilteredReasons"];
        operation.response = operationResponse;
      }
    }
    return operation;
  }
}
class LiveMusicServerMessage {
  get audioChunk() {
    if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
      return this.serverContent.audioChunks[0];
    }
    return;
  }
}
function tModel(apiClient, model) {
  if (!model || typeof model !== "string") {
    throw new Error("model is required and must be a string");
  }
  if (apiClient.isVertexAI()) {
    if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
      return model;
    } else if (model.indexOf("/") >= 0) {
      const parts = model.split("/", 2);
      return `publishers/${parts[0]}/models/${parts[1]}`;
    } else {
      return `publishers/google/models/${model}`;
    }
  } else {
    if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
      return model;
    } else {
      return `models/${model}`;
    }
  }
}
function tCachesModel(apiClient, model) {
  const transformedModel = tModel(apiClient, model);
  if (!transformedModel) {
    return "";
  }
  if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
  } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
  } else {
    return transformedModel;
  }
}
function tBlobs(blobs) {
  if (Array.isArray(blobs)) {
    return blobs.map((blob) => tBlob(blob));
  } else {
    return [tBlob(blobs)];
  }
}
function tBlob(blob) {
  if (typeof blob === "object" && blob !== null) {
    return blob;
  }
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
}
function tImageBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tAudioBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tPart(origin) {
  if (origin === null || origin === undefined) {
    throw new Error("PartUnion is required");
  }
  if (typeof origin === "object") {
    return origin;
  }
  if (typeof origin === "string") {
    return { text: origin };
  }
  throw new Error(`Unsupported part type: ${typeof origin}`);
}
function tParts(origin) {
  if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {
    throw new Error("PartListUnion is required");
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tPart(item));
  }
  return [tPart(origin)];
}
function _isContent(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
}
function _isFunctionCallPart(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "functionCall" in origin;
}
function _isFunctionResponsePart(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "functionResponse" in origin;
}
function tContent(origin) {
  if (origin === null || origin === undefined) {
    throw new Error("ContentUnion is required");
  }
  if (_isContent(origin)) {
    return origin;
  }
  return {
    role: "user",
    parts: tParts(origin)
  };
}
function tContentsForEmbed(apiClient, origin) {
  if (!origin) {
    return [];
  }
  if (apiClient.isVertexAI() && Array.isArray(origin)) {
    return origin.flatMap((item) => {
      const content = tContent(item);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {
        return [content.parts[0].text];
      }
      return [];
    });
  } else if (apiClient.isVertexAI()) {
    const content = tContent(origin);
    if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {
      return [content.parts[0].text];
    }
    return [];
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tContent(item));
  }
  return [tContent(origin)];
}
function tContents(origin) {
  if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {
    throw new Error("contents are required");
  }
  if (!Array.isArray(origin)) {
    if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    }
    return [tContent(origin)];
  }
  const result = [];
  const accumulatedParts = [];
  const isContentArray = _isContent(origin[0]);
  for (const item of origin) {
    const isContent = _isContent(item);
    if (isContent != isContentArray) {
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    }
    if (isContent) {
      result.push(item);
    } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
    } else {
      accumulatedParts.push(item);
    }
  }
  if (!isContentArray) {
    result.push({ role: "user", parts: tParts(accumulatedParts) });
  }
  return result;
}
function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
  if (typeList.includes("null")) {
    resultingSchema["nullable"] = true;
  }
  const listWithoutNull = typeList.filter((type) => type !== "null");
  if (listWithoutNull.length === 1) {
    resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
  } else {
    resultingSchema["anyOf"] = [];
    for (const i of listWithoutNull) {
      resultingSchema["anyOf"].push({
        type: Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
      });
    }
  }
}
function processJsonSchema(_jsonSchema) {
  const genAISchema = {};
  const schemaFieldNames = ["items"];
  const listSchemaFieldNames = ["anyOf"];
  const dictSchemaFieldNames = ["properties"];
  if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
    throw new Error("type and anyOf cannot be both populated.");
  }
  const incomingAnyOf = _jsonSchema["anyOf"];
  if (incomingAnyOf != null && incomingAnyOf.length == 2) {
    if (incomingAnyOf[0]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[1];
    } else if (incomingAnyOf[1]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[0];
    }
  }
  if (_jsonSchema["type"] instanceof Array) {
    flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
  }
  for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
    if (fieldValue == null) {
      continue;
    }
    if (fieldName == "type") {
      if (fieldValue === "null") {
        throw new Error("type: null can not be the only possible type for the field.");
      }
      if (fieldValue instanceof Array) {
        continue;
      }
      genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else if (schemaFieldNames.includes(fieldName)) {
      genAISchema[fieldName] = processJsonSchema(fieldValue);
    } else if (listSchemaFieldNames.includes(fieldName)) {
      const listSchemaFieldValue = [];
      for (const item of fieldValue) {
        if (item["type"] == "null") {
          genAISchema["nullable"] = true;
          continue;
        }
        listSchemaFieldValue.push(processJsonSchema(item));
      }
      genAISchema[fieldName] = listSchemaFieldValue;
    } else if (dictSchemaFieldNames.includes(fieldName)) {
      const dictSchemaFieldValue = {};
      for (const [key, value] of Object.entries(fieldValue)) {
        dictSchemaFieldValue[key] = processJsonSchema(value);
      }
      genAISchema[fieldName] = dictSchemaFieldValue;
    } else {
      if (fieldName === "additionalProperties") {
        continue;
      }
      genAISchema[fieldName] = fieldValue;
    }
  }
  return genAISchema;
}
function tSchema(schema) {
  return processJsonSchema(schema);
}
function tSpeechConfig(speechConfig) {
  if (typeof speechConfig === "object") {
    return speechConfig;
  } else if (typeof speechConfig === "string") {
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: speechConfig
        }
      }
    };
  } else {
    throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
  }
}
function tLiveSpeechConfig(speechConfig) {
  if ("multiSpeakerVoiceConfig" in speechConfig) {
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  }
  return speechConfig;
}
function tTool(tool) {
  if (tool.functionDeclarations) {
    for (const functionDeclaration of tool.functionDeclarations) {
      if (functionDeclaration.parameters) {
        if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
          functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
        } else {
          if (!functionDeclaration.parametersJsonSchema) {
            functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
            delete functionDeclaration.parameters;
          }
        }
      }
      if (functionDeclaration.response) {
        if (!Object.keys(functionDeclaration.response).includes("$schema")) {
          functionDeclaration.response = processJsonSchema(functionDeclaration.response);
        } else {
          if (!functionDeclaration.responseJsonSchema) {
            functionDeclaration.responseJsonSchema = functionDeclaration.response;
            delete functionDeclaration.response;
          }
        }
      }
    }
  }
  return tool;
}
function tTools(tools) {
  if (tools === undefined || tools === null) {
    throw new Error("tools is required");
  }
  if (!Array.isArray(tools)) {
    throw new Error("tools is required and must be an array of Tools");
  }
  const result = [];
  for (const tool of tools) {
    result.push(tool);
  }
  return result;
}
function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
  const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
  if (client.isVertexAI()) {
    if (resourceName2.startsWith("projects/")) {
      return resourceName2;
    } else if (resourceName2.startsWith("locations/")) {
      return `projects/${client.getProject()}/${resourceName2}`;
    } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
    } else if (shouldAppendPrefix) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
    } else {
      return resourceName2;
    }
  }
  if (shouldAppendPrefix) {
    return `${resourcePrefix}/${resourceName2}`;
  }
  return resourceName2;
}
function tCachedContentName(apiClient, name) {
  if (typeof name !== "string") {
    throw new Error("name must be a string");
  }
  return resourceName(apiClient, name, "cachedContents");
}
function tTuningJobStatus(status) {
  switch (status) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return status;
  }
}
function tBytes(fromImageBytes) {
  return tBytes$1(fromImageBytes);
}
function _isFile(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "name" in origin;
}
function isGeneratedVideo(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "video" in origin;
}
function isVideo(origin) {
  return origin !== null && origin !== undefined && typeof origin === "object" && "uri" in origin;
}
function tFileName(fromName) {
  var _a;
  let name;
  if (_isFile(fromName)) {
    name = fromName.name;
  }
  if (isVideo(fromName)) {
    name = fromName.uri;
    if (name === undefined) {
      return;
    }
  }
  if (isGeneratedVideo(fromName)) {
    name = (_a = fromName.video) === null || _a === undefined ? undefined : _a.uri;
    if (name === undefined) {
      return;
    }
  }
  if (typeof fromName === "string") {
    name = fromName;
  }
  if (name === undefined) {
    throw new Error("Could not extract file name from the provided input.");
  }
  if (name.startsWith("https://")) {
    const suffix = name.split("files/")[1];
    const match = suffix.match(/[a-z0-9]+/);
    if (match === null) {
      throw new Error(`Could not extract file name from URI ${name}`);
    }
    name = match[0];
  } else if (name.startsWith("files/")) {
    name = name.split("files/")[1];
  }
  return name;
}
function tModelsUrl(apiClient, baseModels) {
  let res;
  if (apiClient.isVertexAI()) {
    res = baseModels ? "publishers/google/models" : "models";
  } else {
    res = baseModels ? "models" : "tunedModels";
  }
  return res;
}
function tExtractModels(response) {
  for (const key of ["models", "tunedModels", "publisherModels"]) {
    if (hasField(response, key)) {
      return response[key];
    }
  }
  return [];
}
function hasField(data, fieldName) {
  return data !== null && typeof data === "object" && fieldName in data;
}
function mcpToGeminiTool(mcpTool, config = {}) {
  const mcpToolSchema = mcpTool;
  const functionDeclaration = {
    name: mcpToolSchema["name"],
    description: mcpToolSchema["description"],
    parametersJsonSchema: mcpToolSchema["inputSchema"]
  };
  if (config.behavior) {
    functionDeclaration["behavior"] = config.behavior;
  }
  const geminiTool = {
    functionDeclarations: [
      functionDeclaration
    ]
  };
  return geminiTool;
}
function mcpToolsToGeminiTool(mcpTools, config = {}) {
  const functionDeclarations = [];
  const toolNames = new Set;
  for (const mcpTool of mcpTools) {
    const mcpToolName = mcpTool.name;
    if (toolNames.has(mcpToolName)) {
      throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
    }
    toolNames.add(mcpToolName);
    const geminiTool = mcpToGeminiTool(mcpTool, config);
    if (geminiTool.functionDeclarations) {
      functionDeclarations.push(...geminiTool.functionDeclarations);
    }
  }
  return { functionDeclarations };
}
function tBatchJobSource(apiClient, src) {
  if (typeof src !== "string" && !Array.isArray(src)) {
    if (apiClient && apiClient.isVertexAI()) {
      if (src.gcsUri && src.bigqueryUri) {
        throw new Error("Only one of `gcsUri` or `bigqueryUri` can be set.");
      } else if (!src.gcsUri && !src.bigqueryUri) {
        throw new Error("One of `gcsUri` or `bigqueryUri` must be set.");
      }
    } else {
      if (src.inlinedRequests && src.fileName) {
        throw new Error("Only one of `inlinedRequests` or `fileName` can be set.");
      } else if (!src.inlinedRequests && !src.fileName) {
        throw new Error("One of `inlinedRequests` or `fileName` must be set.");
      }
    }
    return src;
  } else if (Array.isArray(src)) {
    return { inlinedRequests: src };
  } else if (typeof src === "string") {
    if (src.startsWith("gs://")) {
      return {
        format: "jsonl",
        gcsUri: [src]
      };
    } else if (src.startsWith("bq://")) {
      return {
        format: "bigquery",
        bigqueryUri: src
      };
    } else if (src.startsWith("files/")) {
      return {
        fileName: src
      };
    }
  }
  throw new Error(`Unsupported source: ${src}`);
}
function tBatchJobDestination(dest) {
  if (typeof dest !== "string") {
    return dest;
  }
  const destString = dest;
  if (destString.startsWith("gs://")) {
    return {
      format: "jsonl",
      gcsUri: destString
    };
  } else if (destString.startsWith("bq://")) {
    return {
      format: "bigquery",
      bigqueryUri: destString
    };
  } else {
    throw new Error(`Unsupported destination: ${destString}`);
  }
}
function tBatchJobName(apiClient, name) {
  const nameString = name;
  if (!apiClient.isVertexAI()) {
    const mldevPattern = /batches\/[^/]+$/;
    if (mldevPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
  if (vertexPattern.test(nameString)) {
    return nameString.split("/").pop();
  } else if (/^\d+$/.test(nameString)) {
    return nameString;
  } else {
    throw new Error(`Invalid batch job name: ${nameString}.`);
  }
}
function tJobState(state) {
  const stateString = state;
  if (stateString === "BATCH_STATE_UNSPECIFIED") {
    return "JOB_STATE_UNSPECIFIED";
  } else if (stateString === "BATCH_STATE_PENDING") {
    return "JOB_STATE_PENDING";
  } else if (stateString === "BATCH_STATE_SUCCEEDED") {
    return "JOB_STATE_SUCCEEDED";
  } else if (stateString === "BATCH_STATE_FAILED") {
    return "JOB_STATE_FAILED";
  } else if (stateString === "BATCH_STATE_CANCELLED") {
    return "JOB_STATE_CANCELLED";
  } else {
    return stateString;
  }
}
function videoMetadataToMldev$4(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$4(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$4(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$4(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToMldev$1(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function safetySettingToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["method"]) !== undefined) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToMldev$4(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$4(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$4(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$4(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$4(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$4(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$4() {
  const toObject = {};
  return toObject;
}
function toolToMldev$4(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== undefined) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== undefined) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== undefined) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$4());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev$2(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev$2(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$2(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToMldev$1(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== undefined) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== undefined) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== undefined && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev$1(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$4(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== undefined && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== undefined) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== undefined && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== undefined) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev$1(fromThinkingConfig));
  }
  return toObject;
}
function inlinedRequestToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["request", "contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function batchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["format"]) !== undefined) {
    throw new Error("format parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["gcsUri"]) !== undefined) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["bigqueryUri"]) !== undefined) {
    throw new Error("bigqueryUri parameter is not supported in Gemini API.");
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    let transformedList = fromInlinedRequests;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedRequestToMldev(apiClient, item);
      });
    }
    setValueByPath(toObject, ["requests", "requests"], transformedList);
  }
  return toObject;
}
function createBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  if (getValueByPath(fromObject, ["dest"]) !== undefined) {
    throw new Error("dest parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createBatchJobConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function cancelBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listBatchJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  if (getValueByPath(fromObject, ["filter"]) !== undefined) {
    throw new Error("filter parameter is not supported in Gemini API.");
  }
  return toObject;
}
function listBatchJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listBatchJobsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function deleteBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function batchJobSourceToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["instancesFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== undefined) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedRequests"]) !== undefined) {
    throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function batchJobDestinationToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["predictionsFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== undefined) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedResponses"]) !== undefined) {
    throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function createBatchJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDest = getValueByPath(fromObject, ["dest"]);
  if (parentObject !== undefined && fromDest != null) {
    setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
  }
  return toObject;
}
function createBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createBatchJobConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function cancelBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listBatchJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== undefined && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listBatchJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listBatchJobsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function deleteBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function videoMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev$2(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev$2(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev$2(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev$2(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromMldev$1(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromMldev$2(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$2(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function jobErrorFromMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  return toObject;
}
function inlinedResponseFromMldev(fromObject) {
  const toObject = {};
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
  }
  return toObject;
}
function batchJobDestinationFromMldev(fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedResponses = getValueByPath(fromObject, [
    "inlinedResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedResponses != null) {
    let transformedList = fromInlinedResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedResponseFromMldev(item);
      });
    }
    setValueByPath(toObject, ["inlinedResponses"], transformedList);
  }
  return toObject;
}
function batchJobFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, [
    "metadata",
    "displayName"
  ]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["metadata", "state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, [
    "metadata",
    "createTime"
  ]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "metadata",
    "endTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, [
    "metadata",
    "updateTime"
  ]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(fromDest));
  }
  return toObject;
}
function listBatchJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function deleteResourceJobFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
  }
  return toObject;
}
function jobErrorFromVertex(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  return toObject;
}
function batchJobSourceFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigquerySource",
    "inputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobDestinationFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, [
    "gcsDestination",
    "outputUriPrefix"
  ]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigqueryDestination",
    "outputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
  }
  const fromDest = getValueByPath(fromObject, ["outputConfig"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(fromDest));
  }
  return toObject;
}
function listBatchJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, [
    "batchPredictionJobs"
  ]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function deleteResourceJobFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
  }
  return toObject;
}
var PagedItem;
(function(PagedItem2) {
  PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
  PagedItem2["PAGED_ITEM_MODELS"] = "models";
  PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
  PagedItem2["PAGED_ITEM_FILES"] = "files";
  PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
})(PagedItem || (PagedItem = {}));

class Pager {
  constructor(name, request, response, params) {
    this.pageInternal = [];
    this.paramsInternal = {};
    this.requestInternal = request;
    this.init(name, response, params);
  }
  init(name, response, params) {
    var _a, _b;
    this.nameInternal = name;
    this.pageInternal = response[this.nameInternal] || [];
    this.sdkHttpResponseInternal = response === null || response === undefined ? undefined : response.sdkHttpResponse;
    this.idxInternal = 0;
    let requestParams = { config: {} };
    if (!params || Object.keys(params).length === 0) {
      requestParams = { config: {} };
    } else if (typeof params === "object") {
      requestParams = Object.assign({}, params);
    } else {
      requestParams = params;
    }
    if (requestParams["config"]) {
      requestParams["config"]["pageToken"] = response["nextPageToken"];
    }
    this.paramsInternal = requestParams;
    this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === undefined ? undefined : _a["pageSize"]) !== null && _b !== undefined ? _b : this.pageInternal.length;
  }
  initNextPage(response) {
    this.init(this.nameInternal, response, this.paramsInternal);
  }
  get page() {
    return this.pageInternal;
  }
  get name() {
    return this.nameInternal;
  }
  get pageSize() {
    return this.pageInternalSize;
  }
  get sdkHttpResponse() {
    return this.sdkHttpResponseInternal;
  }
  get params() {
    return this.paramsInternal;
  }
  get pageLength() {
    return this.pageInternal.length;
  }
  getItem(index) {
    return this.pageInternal[index];
  }
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        if (this.idxInternal >= this.pageLength) {
          if (this.hasNextPage()) {
            await this.nextPage();
          } else {
            return { value: undefined, done: true };
          }
        }
        const item = this.getItem(this.idxInternal);
        this.idxInternal += 1;
        return { value: item, done: false };
      },
      return: async () => {
        return { value: undefined, done: true };
      }
    };
  }
  async nextPage() {
    if (!this.hasNextPage()) {
      throw new Error("No more pages to fetch.");
    }
    const response = await this.requestInternal(this.params);
    this.initNextPage(response);
    return this.page;
  }
  hasNextPage() {
    var _a;
    if (((_a = this.params["config"]) === null || _a === undefined ? undefined : _a["pageToken"]) !== undefined) {
      return true;
    }
    return false;
  }
}

class Batches extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.create = async (params) => {
      if (this.apiClient.isVertexAI()) {
        const timestamp = Date.now();
        const timestampStr = timestamp.toString();
        if (Array.isArray(params.src)) {
          throw new Error("InlinedRequest[] is not supported in Vertex AI. Please use " + "Google Cloud Storage URI or BigQuery URI instead.");
        }
        params.config = params.config || {};
        if (params.config.displayName === undefined) {
          params.config.displayName = "genaiBatchJob_${timestampStr}";
        }
        if (params.config.dest === undefined && typeof params.src === "string") {
          if (params.src.startsWith("gs://") && params.src.endsWith(".jsonl")) {
            params.config.dest = `${params.src.slice(0, -6)}/dest`;
          } else if (params.src.startsWith("bq://")) {
            params.config.dest = `${params.src}_dest_${timestampStr}`;
          } else {
            throw new Error("Unsupported source:" + params.src);
          }
        }
      }
      return await this.createInternal(params);
    };
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
    };
  }
  async createInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createBatchJobParametersToVertex(this.apiClient, params);
      path = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = createBatchJobParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:batchGenerateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async get(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getBatchJobParametersToVertex(this.apiClient, params);
      path = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getBatchJobParametersToMldev(this.apiClient, params);
      path = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async cancel(params) {
    var _a, _b, _c, _d;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = cancelBatchJobParametersToVertex(this.apiClient, params);
      path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      });
    } else {
      const body = cancelBatchJobParametersToMldev(this.apiClient, params);
      path = formatMap("batches/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      });
    }
  }
  async listInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listBatchJobsParametersToVertex(params);
      path = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromVertex(apiResponse);
        const typedResp = new ListBatchJobsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listBatchJobsParametersToMldev(params);
      path = formatMap("batches", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromMldev(apiResponse);
        const typedResp = new ListBatchJobsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async delete(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteBatchJobParametersToVertex(this.apiClient, params);
      path = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = deleteBatchJobParametersToMldev(this.apiClient, params);
      path = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
}
function videoMetadataToMldev$3(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$3(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$3(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$3(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev$3(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$3(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$3(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$3(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$3(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$3(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$3() {
  const toObject = {};
  return toObject;
}
function toolToMldev$3(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== undefined) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== undefined) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== undefined) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$3());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev$1(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev$1(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$1(fromRetrievalConfig));
  }
  return toObject;
}
function createCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== undefined && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== undefined && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== undefined && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== undefined && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["kmsKeyName"]) !== undefined) {
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createCachedContentConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function updateCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== undefined && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== undefined && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateCachedContentConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function listCachedContentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listCachedContentsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataToVertex$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex$2(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex$2(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToVertex$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== undefined) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex$2(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex$2(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$2(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex$2(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex$2() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex$2(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$2(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex$2(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex$2(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex$2() {
  const toObject = {};
  return toObject;
}
function toolToVertex$2(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$2());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$2(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex$2());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToVertex$1(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToVertex$1(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex$1(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex$1(fromRetrievalConfig));
  }
  return toObject;
}
function createCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== undefined && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== undefined && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== undefined && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== undefined && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex$1(fromToolConfig));
  }
  const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
  if (parentObject !== undefined && fromKmsKeyName != null) {
    setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
  }
  return toObject;
}
function createCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createCachedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function updateCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== undefined && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== undefined && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateCachedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function listCachedContentsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listCachedContentsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function cachedContentFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (fromExpireTime != null) {
    setValueByPath(toObject, ["expireTime"], fromExpireTime);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function deleteCachedContentResponseFromMldev() {
  const toObject = {};
  return toObject;
}
function listCachedContentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return cachedContentFromMldev(item);
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function cachedContentFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (fromExpireTime != null) {
    setValueByPath(toObject, ["expireTime"], fromExpireTime);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function deleteCachedContentResponseFromVertex() {
  const toObject = {};
  return toObject;
}
function listCachedContentsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return cachedContentFromVertex(item);
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}

class Caches extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
    };
  }
  async create(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createCachedContentParametersToVertex(this.apiClient, params);
      path = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = createCachedContentParametersToMldev(this.apiClient, params);
      path = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async get(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getCachedContentParametersToVertex(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getCachedContentParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async delete(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteCachedContentParametersToVertex(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteCachedContentResponseFromVertex();
        const typedResp = new DeleteCachedContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteCachedContentParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteCachedContentResponseFromMldev();
        const typedResp = new DeleteCachedContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async update(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateCachedContentParametersToVertex(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = updateCachedContentParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = cachedContentFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listCachedContentsParametersToVertex(params);
      path = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromVertex(apiResponse);
        const typedResp = new ListCachedContentsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listCachedContentsParametersToMldev(params);
      path = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromMldev(apiResponse);
        const typedResp = new ListCachedContentsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await2(v) {
  return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isValidResponse2(response) {
  var _a;
  if (response.candidates == undefined || response.candidates.length === 0) {
    return false;
  }
  const content = (_a = response.candidates[0]) === null || _a === undefined ? undefined : _a.content;
  if (content === undefined) {
    return false;
  }
  return isValidContent(content);
}
function isValidContent(content) {
  if (content.parts === undefined || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === undefined || Object.keys(part).length === 0) {
      return false;
    }
    if (!part.thought && part.text !== undefined && part.text === "") {
      return false;
    }
  }
  return true;
}
function validateHistory(history) {
  if (history.length === 0) {
    return;
  }
  for (const content of history) {
    if (content.role !== "user" && content.role !== "model") {
      throw new Error(`Role must be user or model, but got ${content.role}.`);
    }
  }
}
function extractCuratedHistory(comprehensiveHistory) {
  if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {
    return [];
  }
  const curatedHistory = [];
  const length = comprehensiveHistory.length;
  let i = 0;
  while (i < length) {
    if (comprehensiveHistory[i].role === "user") {
      curatedHistory.push(comprehensiveHistory[i]);
      i++;
    } else {
      const modelOutput = [];
      let isValid = true;
      while (i < length && comprehensiveHistory[i].role === "model") {
        modelOutput.push(comprehensiveHistory[i]);
        if (isValid && !isValidContent(comprehensiveHistory[i])) {
          isValid = false;
        }
        i++;
      }
      if (isValid) {
        curatedHistory.push(...modelOutput);
      } else {
        curatedHistory.pop();
      }
    }
  }
  return curatedHistory;
}

class Chats {
  constructor(modelsModule, apiClient) {
    this.modelsModule = modelsModule;
    this.apiClient = apiClient;
  }
  create(params) {
    return new Chat(this.apiClient, this.modelsModule, params.model, params.config, structuredClone(params.history));
  }
}

class Chat {
  constructor(apiClient, modelsModule, model, config = {}, history = []) {
    this.apiClient = apiClient;
    this.modelsModule = modelsModule;
    this.model = model;
    this.config = config;
    this.history = history;
    this.sendPromise = Promise.resolve();
    validateHistory(history);
  }
  async sendMessage(params) {
    var _a;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const responsePromise = this.modelsModule.generateContent({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a = params.config) !== null && _a !== undefined ? _a : this.config
    });
    this.sendPromise = (async () => {
      var _a2, _b, _c;
      const response = await responsePromise;
      const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === undefined ? undefined : _a2[0]) === null || _b === undefined ? undefined : _b.content;
      const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
      const index = this.getHistory(true).length;
      let automaticFunctionCallingHistory = [];
      if (fullAutomaticFunctionCallingHistory != null) {
        automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== undefined ? _c : [];
      }
      const modelOutput = outputContent ? [outputContent] : [];
      this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
      return;
    })();
    await this.sendPromise.catch(() => {
      this.sendPromise = Promise.resolve();
    });
    return responsePromise;
  }
  async sendMessageStream(params) {
    var _a;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const streamResponse = this.modelsModule.generateContentStream({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a = params.config) !== null && _a !== undefined ? _a : this.config
    });
    this.sendPromise = streamResponse.then(() => {
      return;
    }).catch(() => {
      return;
    });
    const response = await streamResponse;
    const result = this.processStreamResponse(response, inputContent);
    return result;
  }
  getHistory(curated = false) {
    const history = curated ? extractCuratedHistory(this.history) : this.history;
    return structuredClone(history);
  }
  processStreamResponse(streamResponse, inputContent) {
    var _a, _b;
    return __asyncGenerator2(this, arguments, function* processStreamResponse_1() {
      var _c, e_1, _d, _e;
      const outputContent = [];
      try {
        for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1;streamResponse_1_1 = yield __await2(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
          _e = streamResponse_1_1.value;
          _f = false;
          const chunk = _e;
          if (isValidResponse2(chunk)) {
            const content = (_b = (_a = chunk.candidates) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content;
            if (content !== undefined) {
              outputContent.push(content);
            }
          }
          yield yield __await2(chunk);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_f && !_c && (_d = streamResponse_1.return))
            yield __await2(_d.call(streamResponse_1));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.recordHistory(inputContent, outputContent);
    });
  }
  recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
    let outputContents = [];
    if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== undefined)) {
      outputContents = modelOutput;
    } else {
      outputContents.push({
        role: "model",
        parts: []
      });
    }
    if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
      this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
    } else {
      this.history.push(userInput);
    }
    this.history.push(...outputContents);
  }
}

class ApiError extends Error {
  constructor(options) {
    super(options.message);
    this.name = "ApiError";
    this.status = options.status;
    Object.setPrototypeOf(this, ApiError.prototype);
  }
}
function listFilesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listFilesConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function fileStatusToMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  return toObject;
}
function fileToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
  if (fromSizeBytes != null) {
    setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromExpirationTime = getValueByPath(fromObject, [
    "expirationTime"
  ]);
  if (fromExpirationTime != null) {
    setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
  if (fromSha256Hash != null) {
    setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
  }
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
  if (fromDownloadUri != null) {
    setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], fromState);
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    setValueByPath(toObject, ["source"], fromSource);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fileStatusToMldev(fromError));
  }
  return toObject;
}
function createFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFile = getValueByPath(fromObject, ["file"]);
  if (fromFile != null) {
    setValueByPath(toObject, ["file"], fileToMldev(fromFile));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function getFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function deleteFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function fileStatusFromMldev(fromObject) {
  const toObject = {};
  const fromDetails = getValueByPath(fromObject, ["details"]);
  if (fromDetails != null) {
    setValueByPath(toObject, ["details"], fromDetails);
  }
  const fromMessage = getValueByPath(fromObject, ["message"]);
  if (fromMessage != null) {
    setValueByPath(toObject, ["message"], fromMessage);
  }
  const fromCode = getValueByPath(fromObject, ["code"]);
  if (fromCode != null) {
    setValueByPath(toObject, ["code"], fromCode);
  }
  return toObject;
}
function fileFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
  if (fromSizeBytes != null) {
    setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromExpirationTime = getValueByPath(fromObject, [
    "expirationTime"
  ]);
  if (fromExpirationTime != null) {
    setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
  if (fromSha256Hash != null) {
    setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
  }
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
  if (fromDownloadUri != null) {
    setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], fromState);
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    setValueByPath(toObject, ["source"], fromSource);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fileStatusFromMldev(fromError));
  }
  return toObject;
}
function listFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return fileFromMldev(item);
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
function createFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteFileResponseFromMldev() {
  const toObject = {};
  return toObject;
}

class Files extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
    };
  }
  async upload(params) {
    if (this.apiClient.isVertexAI()) {
      throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
    }
    return this.apiClient.uploadFile(params.file, params.config).then((response) => {
      const file = fileFromMldev(response);
      return file;
    });
  }
  async download(params) {
    await this.apiClient.downloadFile(params);
  }
  async listInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = listFilesParametersToMldev(params);
      path = formatMap("files", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listFilesResponseFromMldev(apiResponse);
        const typedResp = new ListFilesResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async createInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createFileParametersToMldev(params);
      path = formatMap("upload/v1beta/files", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = createFileResponseFromMldev(apiResponse);
        const typedResp = new CreateFileResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async get(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = getFileParametersToMldev(params);
      path = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = fileFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async delete(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = deleteFileParametersToMldev(params);
      path = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteFileResponseFromMldev();
        const typedResp = new DeleteFileResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
}
function prebuiltVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToMldev$2(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$2(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$2(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev$2(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$2(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$2(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$2(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$2(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$2() {
  const toObject = {};
  return toObject;
}
function toolToMldev$2(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== undefined) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== undefined) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== undefined) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$2());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== undefined) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function audioTranscriptionConfigToMldev$1() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToMldev$1(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToMldev$1(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev$1(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== undefined && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== undefined && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== undefined && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== undefined && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== undefined && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== undefined && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== undefined && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== undefined && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== undefined && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$2(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== undefined && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev$1());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev$1());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== undefined && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== undefined && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== undefined && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev$1(fromProactivity));
  }
  return toObject;
}
function liveConnectParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
  }
  return toObject;
}
function activityStartToMldev() {
  const toObject = {};
  return toObject;
}
function activityEndToMldev() {
  const toObject = {};
  return toObject;
}
function liveSendRealtimeInputParametersToMldev(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    setValueByPath(toObject, ["mediaChunks"], tBlobs(fromMedia));
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], activityStartToMldev());
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], activityEndToMldev());
  }
  return toObject;
}
function weightedPromptToMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromWeight = getValueByPath(fromObject, ["weight"]);
  if (fromWeight != null) {
    setValueByPath(toObject, ["weight"], fromWeight);
  }
  return toObject;
}
function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptToMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicGenerationConfigToMldev(fromObject) {
  const toObject = {};
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromGuidance = getValueByPath(fromObject, ["guidance"]);
  if (fromGuidance != null) {
    setValueByPath(toObject, ["guidance"], fromGuidance);
  }
  const fromBpm = getValueByPath(fromObject, ["bpm"]);
  if (fromBpm != null) {
    setValueByPath(toObject, ["bpm"], fromBpm);
  }
  const fromDensity = getValueByPath(fromObject, ["density"]);
  if (fromDensity != null) {
    setValueByPath(toObject, ["density"], fromDensity);
  }
  const fromBrightness = getValueByPath(fromObject, ["brightness"]);
  if (fromBrightness != null) {
    setValueByPath(toObject, ["brightness"], fromBrightness);
  }
  const fromScale = getValueByPath(fromObject, ["scale"]);
  if (fromScale != null) {
    setValueByPath(toObject, ["scale"], fromScale);
  }
  const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
  if (fromMuteBass != null) {
    setValueByPath(toObject, ["muteBass"], fromMuteBass);
  }
  const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
  if (fromMuteDrums != null) {
    setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
  }
  const fromOnlyBassAndDrums = getValueByPath(fromObject, [
    "onlyBassAndDrums"
  ]);
  if (fromOnlyBassAndDrums != null) {
    setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
  }
  return toObject;
}
function liveMusicSetConfigParametersToMldev(fromObject) {
  const toObject = {};
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
  }
  return toObject;
}
function liveMusicClientSetupToMldev(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  return toObject;
}
function liveMusicClientContentToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptToMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicClientMessageToMldev(fromObject) {
  const toObject = {};
  const fromSetup = getValueByPath(fromObject, ["setup"]);
  if (fromSetup != null) {
    setValueByPath(toObject, ["setup"], liveMusicClientSetupToMldev(fromSetup));
  }
  const fromClientContent = getValueByPath(fromObject, [
    "clientContent"
  ]);
  if (fromClientContent != null) {
    setValueByPath(toObject, ["clientContent"], liveMusicClientContentToMldev(fromClientContent));
  }
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
  }
  const fromPlaybackControl = getValueByPath(fromObject, [
    "playbackControl"
  ]);
  if (fromPlaybackControl != null) {
    setValueByPath(toObject, ["playbackControl"], fromPlaybackControl);
  }
  return toObject;
}
function prebuiltVoiceConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speechConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex$1(fromVoiceConfig));
  }
  if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== undefined) {
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToVertex$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToVertex$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== undefined) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex$1(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex$1(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$1(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex$1(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex$1() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$1(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex$1(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex$1(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex$1() {
  const toObject = {};
  return toObject;
}
function toolToVertex$1(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$1());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$1(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex$1());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToVertex(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  const fromTransparent = getValueByPath(fromObject, ["transparent"]);
  if (fromTransparent != null) {
    setValueByPath(toObject, ["transparent"], fromTransparent);
  }
  return toObject;
}
function audioTranscriptionConfigToVertex() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToVertex(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToVertex(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToVertex(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToVertex(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToVertex(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToVertex(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== undefined && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== undefined && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== undefined && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== undefined && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== undefined && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== undefined && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== undefined && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== undefined && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== undefined && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToVertex$1(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== undefined && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToVertex(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToVertex());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToVertex());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== undefined && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToVertex(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== undefined && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToVertex(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== undefined && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToVertex(fromProactivity));
  }
  return toObject;
}
function liveConnectParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function activityStartToVertex() {
  const toObject = {};
  return toObject;
}
function activityEndToVertex() {
  const toObject = {};
  return toObject;
}
function liveSendRealtimeInputParametersToVertex(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    setValueByPath(toObject, ["mediaChunks"], tBlobs(fromMedia));
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], activityStartToVertex());
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], activityEndToVertex());
  }
  return toObject;
}
function liveServerSetupCompleteFromMldev() {
  const toObject = {};
  return toObject;
}
function videoMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev$1(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev$1(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function transcriptionFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFinished = getValueByPath(fromObject, ["finished"]);
  if (fromFinished != null) {
    setValueByPath(toObject, ["finished"], fromFinished);
  }
  return toObject;
}
function urlMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function liveServerContentFromMldev(fromObject) {
  const toObject = {};
  const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
  if (fromModelTurn != null) {
    setValueByPath(toObject, ["modelTurn"], contentFromMldev$1(fromModelTurn));
  }
  const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
  if (fromTurnComplete != null) {
    setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
  }
  const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
  if (fromInterrupted != null) {
    setValueByPath(toObject, ["interrupted"], fromInterrupted);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromGenerationComplete = getValueByPath(fromObject, [
    "generationComplete"
  ]);
  if (fromGenerationComplete != null) {
    setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
  }
  const fromInputTranscription = getValueByPath(fromObject, [
    "inputTranscription"
  ]);
  if (fromInputTranscription != null) {
    setValueByPath(toObject, ["inputTranscription"], transcriptionFromMldev(fromInputTranscription));
  }
  const fromOutputTranscription = getValueByPath(fromObject, [
    "outputTranscription"
  ]);
  if (fromOutputTranscription != null) {
    setValueByPath(toObject, ["outputTranscription"], transcriptionFromMldev(fromOutputTranscription));
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$1(fromUrlContextMetadata));
  }
  return toObject;
}
function functionCallFromMldev(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function liveServerToolCallFromMldev(fromObject) {
  const toObject = {};
  const fromFunctionCalls = getValueByPath(fromObject, [
    "functionCalls"
  ]);
  if (fromFunctionCalls != null) {
    let transformedList = fromFunctionCalls;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionCallFromMldev(item);
      });
    }
    setValueByPath(toObject, ["functionCalls"], transformedList);
  }
  return toObject;
}
function liveServerToolCallCancellationFromMldev(fromObject) {
  const toObject = {};
  const fromIds = getValueByPath(fromObject, ["ids"]);
  if (fromIds != null) {
    setValueByPath(toObject, ["ids"], fromIds);
  }
  return toObject;
}
function modalityTokenCountFromMldev(fromObject) {
  const toObject = {};
  const fromModality = getValueByPath(fromObject, ["modality"]);
  if (fromModality != null) {
    setValueByPath(toObject, ["modality"], fromModality);
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function usageMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "responseTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "responseTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromMldev(item);
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  return toObject;
}
function liveServerGoAwayFromMldev(fromObject) {
  const toObject = {};
  const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
  if (fromTimeLeft != null) {
    setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
  }
  return toObject;
}
function liveServerSessionResumptionUpdateFromMldev(fromObject) {
  const toObject = {};
  const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
  if (fromNewHandle != null) {
    setValueByPath(toObject, ["newHandle"], fromNewHandle);
  }
  const fromResumable = getValueByPath(fromObject, ["resumable"]);
  if (fromResumable != null) {
    setValueByPath(toObject, ["resumable"], fromResumable);
  }
  const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
    "lastConsumedClientMessageIndex"
  ]);
  if (fromLastConsumedClientMessageIndex != null) {
    setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
  }
  return toObject;
}
function liveServerMessageFromMldev(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromMldev());
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveServerContentFromMldev(fromServerContent));
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], liveServerToolCallFromMldev(fromToolCall));
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromMldev(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], liveServerGoAwayFromMldev(fromGoAway));
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));
  }
  return toObject;
}
function liveMusicServerSetupCompleteFromMldev() {
  const toObject = {};
  return toObject;
}
function weightedPromptFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromWeight = getValueByPath(fromObject, ["weight"]);
  if (fromWeight != null) {
    setValueByPath(toObject, ["weight"], fromWeight);
  }
  return toObject;
}
function liveMusicClientContentFromMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return weightedPromptFromMldev(item);
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveMusicGenerationConfigFromMldev(fromObject) {
  const toObject = {};
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromGuidance = getValueByPath(fromObject, ["guidance"]);
  if (fromGuidance != null) {
    setValueByPath(toObject, ["guidance"], fromGuidance);
  }
  const fromBpm = getValueByPath(fromObject, ["bpm"]);
  if (fromBpm != null) {
    setValueByPath(toObject, ["bpm"], fromBpm);
  }
  const fromDensity = getValueByPath(fromObject, ["density"]);
  if (fromDensity != null) {
    setValueByPath(toObject, ["density"], fromDensity);
  }
  const fromBrightness = getValueByPath(fromObject, ["brightness"]);
  if (fromBrightness != null) {
    setValueByPath(toObject, ["brightness"], fromBrightness);
  }
  const fromScale = getValueByPath(fromObject, ["scale"]);
  if (fromScale != null) {
    setValueByPath(toObject, ["scale"], fromScale);
  }
  const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
  if (fromMuteBass != null) {
    setValueByPath(toObject, ["muteBass"], fromMuteBass);
  }
  const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
  if (fromMuteDrums != null) {
    setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
  }
  const fromOnlyBassAndDrums = getValueByPath(fromObject, [
    "onlyBassAndDrums"
  ]);
  if (fromOnlyBassAndDrums != null) {
    setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
  }
  return toObject;
}
function liveMusicSourceMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromClientContent = getValueByPath(fromObject, [
    "clientContent"
  ]);
  if (fromClientContent != null) {
    setValueByPath(toObject, ["clientContent"], liveMusicClientContentFromMldev(fromClientContent));
  }
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));
  }
  return toObject;
}
function audioChunkFromMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  const fromSourceMetadata = getValueByPath(fromObject, [
    "sourceMetadata"
  ]);
  if (fromSourceMetadata != null) {
    setValueByPath(toObject, ["sourceMetadata"], liveMusicSourceMetadataFromMldev(fromSourceMetadata));
  }
  return toObject;
}
function liveMusicServerContentFromMldev(fromObject) {
  const toObject = {};
  const fromAudioChunks = getValueByPath(fromObject, ["audioChunks"]);
  if (fromAudioChunks != null) {
    let transformedList = fromAudioChunks;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return audioChunkFromMldev(item);
      });
    }
    setValueByPath(toObject, ["audioChunks"], transformedList);
  }
  return toObject;
}
function liveMusicFilteredPromptFromMldev(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFilteredReason = getValueByPath(fromObject, [
    "filteredReason"
  ]);
  if (fromFilteredReason != null) {
    setValueByPath(toObject, ["filteredReason"], fromFilteredReason);
  }
  return toObject;
}
function liveMusicServerMessageFromMldev(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveMusicServerSetupCompleteFromMldev());
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveMusicServerContentFromMldev(fromServerContent));
  }
  const fromFilteredPrompt = getValueByPath(fromObject, [
    "filteredPrompt"
  ]);
  if (fromFilteredPrompt != null) {
    setValueByPath(toObject, ["filteredPrompt"], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));
  }
  return toObject;
}
function liveServerSetupCompleteFromVertex(fromObject) {
  const toObject = {};
  const fromSessionId = getValueByPath(fromObject, ["sessionId"]);
  if (fromSessionId != null) {
    setValueByPath(toObject, ["sessionId"], fromSessionId);
  }
  return toObject;
}
function videoMetadataFromVertex$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromVertex$1(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromVertex$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromVertex$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromVertex$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromVertex$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromVertex$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function transcriptionFromVertex(fromObject) {
  const toObject = {};
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromFinished = getValueByPath(fromObject, ["finished"]);
  if (fromFinished != null) {
    setValueByPath(toObject, ["finished"], fromFinished);
  }
  return toObject;
}
function liveServerContentFromVertex(fromObject) {
  const toObject = {};
  const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
  if (fromModelTurn != null) {
    setValueByPath(toObject, ["modelTurn"], contentFromVertex$1(fromModelTurn));
  }
  const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
  if (fromTurnComplete != null) {
    setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
  }
  const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
  if (fromInterrupted != null) {
    setValueByPath(toObject, ["interrupted"], fromInterrupted);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromGenerationComplete = getValueByPath(fromObject, [
    "generationComplete"
  ]);
  if (fromGenerationComplete != null) {
    setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
  }
  const fromInputTranscription = getValueByPath(fromObject, [
    "inputTranscription"
  ]);
  if (fromInputTranscription != null) {
    setValueByPath(toObject, ["inputTranscription"], transcriptionFromVertex(fromInputTranscription));
  }
  const fromOutputTranscription = getValueByPath(fromObject, [
    "outputTranscription"
  ]);
  if (fromOutputTranscription != null) {
    setValueByPath(toObject, ["outputTranscription"], transcriptionFromVertex(fromOutputTranscription));
  }
  return toObject;
}
function functionCallFromVertex(fromObject) {
  const toObject = {};
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function liveServerToolCallFromVertex(fromObject) {
  const toObject = {};
  const fromFunctionCalls = getValueByPath(fromObject, [
    "functionCalls"
  ]);
  if (fromFunctionCalls != null) {
    let transformedList = fromFunctionCalls;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionCallFromVertex(item);
      });
    }
    setValueByPath(toObject, ["functionCalls"], transformedList);
  }
  return toObject;
}
function liveServerToolCallCancellationFromVertex(fromObject) {
  const toObject = {};
  const fromIds = getValueByPath(fromObject, ["ids"]);
  if (fromIds != null) {
    setValueByPath(toObject, ["ids"], fromIds);
  }
  return toObject;
}
function modalityTokenCountFromVertex(fromObject) {
  const toObject = {};
  const fromModality = getValueByPath(fromObject, ["modality"]);
  if (fromModality != null) {
    setValueByPath(toObject, ["modality"], fromModality);
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function usageMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "candidatesTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "candidatesTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modalityTokenCountFromVertex(item);
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
  if (fromTrafficType != null) {
    setValueByPath(toObject, ["trafficType"], fromTrafficType);
  }
  return toObject;
}
function liveServerGoAwayFromVertex(fromObject) {
  const toObject = {};
  const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
  if (fromTimeLeft != null) {
    setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
  }
  return toObject;
}
function liveServerSessionResumptionUpdateFromVertex(fromObject) {
  const toObject = {};
  const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
  if (fromNewHandle != null) {
    setValueByPath(toObject, ["newHandle"], fromNewHandle);
  }
  const fromResumable = getValueByPath(fromObject, ["resumable"]);
  if (fromResumable != null) {
    setValueByPath(toObject, ["resumable"], fromResumable);
  }
  const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
    "lastConsumedClientMessageIndex"
  ]);
  if (fromLastConsumedClientMessageIndex != null) {
    setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
  }
  return toObject;
}
function liveServerMessageFromVertex(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromVertex(fromSetupComplete));
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], liveServerContentFromVertex(fromServerContent));
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], liveServerToolCallFromVertex(fromToolCall));
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], liveServerGoAwayFromVertex(fromGoAway));
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));
  }
  return toObject;
}
function videoMetadataToMldev$1(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev$1(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev$1(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$1(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev$1(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToMldev(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function safetySettingToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["method"]) !== undefined) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToMldev$1(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev$1(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev$1(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$1(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev$1(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev$1() {
  const toObject = {};
  return toObject;
}
function toolToMldev$1(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== undefined) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== undefined) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== undefined) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev$1());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToMldev(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToMldev(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToMldev(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToMldev(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToMldev(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToMldev(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToMldev(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== undefined) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== undefined) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== undefined && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== undefined && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== undefined) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== undefined && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== undefined) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev(fromThinkingConfig));
  }
  return toObject;
}
function generateContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function embedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== undefined && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== undefined && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== undefined && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== undefined) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== undefined) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    setValueByPath(toObject, ["requests[]", "content"], tContentsForEmbed(apiClient, fromContents));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], embedContentConfigToMldev(fromConfig, toObject));
  }
  const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
  if (fromModelForEmbedContent !== undefined) {
    setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
  }
  return toObject;
}
function generateImagesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== undefined) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["negativePrompt"]) !== undefined) {
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== undefined && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== undefined && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  if (getValueByPath(fromObject, ["seed"]) !== undefined) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== undefined && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== undefined && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  if (getValueByPath(fromObject, ["addWatermark"]) !== undefined) {
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["imageSize"]) !== undefined) {
    throw new Error("imageSize parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["enhancePrompt"]) !== undefined) {
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateImagesParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateImagesConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== undefined && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== undefined && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listModelsConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function updateModelConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== undefined && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== undefined && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateModelConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function deleteModelParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function countTokensConfigToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["systemInstruction"]) !== undefined) {
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tools"]) !== undefined) {
    throw new Error("tools parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["generationConfig"]) !== undefined) {
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function countTokensParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], countTokensConfigToMldev(fromConfig));
  }
  return toObject;
}
function imageToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== undefined) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generateVideosConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== undefined && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== undefined) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["fps"]) !== undefined) {
    throw new Error("fps parameter is not supported in Gemini API.");
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== undefined && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  if (getValueByPath(fromObject, ["seed"]) !== undefined) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== undefined && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  if (getValueByPath(fromObject, ["resolution"]) !== undefined) {
    throw new Error("resolution parameter is not supported in Gemini API.");
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  if (getValueByPath(fromObject, ["pubsubTopic"]) !== undefined) {
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== undefined && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== undefined && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  if (getValueByPath(fromObject, ["generateAudio"]) !== undefined) {
    throw new Error("generateAudio parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["lastFrame"]) !== undefined) {
    throw new Error("lastFrame parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["compressionQuality"]) !== undefined) {
    throw new Error("compressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateVideosParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  if (getValueByPath(fromObject, ["video"]) !== undefined) {
    throw new Error("video parameter is not supported in Gemini API.");
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateVideosConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataToVertex(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToVertex(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToVertex(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToVertex(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToVertex(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToVertex(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function schemaToVertex(fromObject) {
  const toObject = {};
  const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
  if (fromAnyOf != null) {
    setValueByPath(toObject, ["anyOf"], fromAnyOf);
  }
  const fromDefault = getValueByPath(fromObject, ["default"]);
  if (fromDefault != null) {
    setValueByPath(toObject, ["default"], fromDefault);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromEnum = getValueByPath(fromObject, ["enum"]);
  if (fromEnum != null) {
    setValueByPath(toObject, ["enum"], fromEnum);
  }
  const fromExample = getValueByPath(fromObject, ["example"]);
  if (fromExample != null) {
    setValueByPath(toObject, ["example"], fromExample);
  }
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromItems = getValueByPath(fromObject, ["items"]);
  if (fromItems != null) {
    setValueByPath(toObject, ["items"], fromItems);
  }
  const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
  if (fromMaxItems != null) {
    setValueByPath(toObject, ["maxItems"], fromMaxItems);
  }
  const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
  if (fromMaxLength != null) {
    setValueByPath(toObject, ["maxLength"], fromMaxLength);
  }
  const fromMaxProperties = getValueByPath(fromObject, [
    "maxProperties"
  ]);
  if (fromMaxProperties != null) {
    setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
  }
  const fromMaximum = getValueByPath(fromObject, ["maximum"]);
  if (fromMaximum != null) {
    setValueByPath(toObject, ["maximum"], fromMaximum);
  }
  const fromMinItems = getValueByPath(fromObject, ["minItems"]);
  if (fromMinItems != null) {
    setValueByPath(toObject, ["minItems"], fromMinItems);
  }
  const fromMinLength = getValueByPath(fromObject, ["minLength"]);
  if (fromMinLength != null) {
    setValueByPath(toObject, ["minLength"], fromMinLength);
  }
  const fromMinProperties = getValueByPath(fromObject, [
    "minProperties"
  ]);
  if (fromMinProperties != null) {
    setValueByPath(toObject, ["minProperties"], fromMinProperties);
  }
  const fromMinimum = getValueByPath(fromObject, ["minimum"]);
  if (fromMinimum != null) {
    setValueByPath(toObject, ["minimum"], fromMinimum);
  }
  const fromNullable = getValueByPath(fromObject, ["nullable"]);
  if (fromNullable != null) {
    setValueByPath(toObject, ["nullable"], fromNullable);
  }
  const fromPattern = getValueByPath(fromObject, ["pattern"]);
  if (fromPattern != null) {
    setValueByPath(toObject, ["pattern"], fromPattern);
  }
  const fromProperties = getValueByPath(fromObject, ["properties"]);
  if (fromProperties != null) {
    setValueByPath(toObject, ["properties"], fromProperties);
  }
  const fromPropertyOrdering = getValueByPath(fromObject, [
    "propertyOrdering"
  ]);
  if (fromPropertyOrdering != null) {
    setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
  }
  const fromRequired = getValueByPath(fromObject, ["required"]);
  if (fromRequired != null) {
    setValueByPath(toObject, ["required"], fromRequired);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (fromTitle != null) {
    setValueByPath(toObject, ["title"], fromTitle);
  }
  const fromType = getValueByPath(fromObject, ["type"]);
  if (fromType != null) {
    setValueByPath(toObject, ["type"], fromType);
  }
  return toObject;
}
function modelSelectionConfigToVertex(fromObject) {
  const toObject = {};
  const fromFeatureSelectionPreference = getValueByPath(fromObject, [
    "featureSelectionPreference"
  ]);
  if (fromFeatureSelectionPreference != null) {
    setValueByPath(toObject, ["featureSelectionPreference"], fromFeatureSelectionPreference);
  }
  return toObject;
}
function safetySettingToVertex(fromObject) {
  const toObject = {};
  const fromMethod = getValueByPath(fromObject, ["method"]);
  if (fromMethod != null) {
    setValueByPath(toObject, ["method"], fromMethod);
  }
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function functionDeclarationToVertex(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["behavior"]) !== undefined) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToVertex(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToVertex(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToVertex(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToVertex(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function enterpriseWebSearchToVertex() {
  const toObject = {};
  return toObject;
}
function apiKeyConfigToVertex(fromObject) {
  const toObject = {};
  const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
  if (fromApiKeyString != null) {
    setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
  }
  return toObject;
}
function authConfigToVertex(fromObject) {
  const toObject = {};
  const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
  if (fromApiKeyConfig != null) {
    setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex(fromApiKeyConfig));
  }
  const fromAuthType = getValueByPath(fromObject, ["authType"]);
  if (fromAuthType != null) {
    setValueByPath(toObject, ["authType"], fromAuthType);
  }
  const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
    "googleServiceAccountConfig"
  ]);
  if (fromGoogleServiceAccountConfig != null) {
    setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
  }
  const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
    "httpBasicAuthConfig"
  ]);
  if (fromHttpBasicAuthConfig != null) {
    setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
  }
  const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
  if (fromOauthConfig != null) {
    setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
  }
  const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
  if (fromOidcConfig != null) {
    setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
  }
  return toObject;
}
function googleMapsToVertex(fromObject) {
  const toObject = {};
  const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
  if (fromAuthConfig != null) {
    setValueByPath(toObject, ["authConfig"], authConfigToVertex(fromAuthConfig));
  }
  return toObject;
}
function urlContextToVertex() {
  const toObject = {};
  return toObject;
}
function toolToVertex(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToVertex(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex());
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToVertex(fromGoogleMaps));
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToVertex());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function functionCallingConfigToVertex(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  return toObject;
}
function latLngToVertex(fromObject) {
  const toObject = {};
  const fromLatitude = getValueByPath(fromObject, ["latitude"]);
  if (fromLatitude != null) {
    setValueByPath(toObject, ["latitude"], fromLatitude);
  }
  const fromLongitude = getValueByPath(fromObject, ["longitude"]);
  if (fromLongitude != null) {
    setValueByPath(toObject, ["longitude"], fromLongitude);
  }
  return toObject;
}
function retrievalConfigToVertex(fromObject) {
  const toObject = {};
  const fromLatLng = getValueByPath(fromObject, ["latLng"]);
  if (fromLatLng != null) {
    setValueByPath(toObject, ["latLng"], latLngToVertex(fromLatLng));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function toolConfigToVertex(fromObject) {
  const toObject = {};
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex(fromFunctionCallingConfig));
  }
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex(fromRetrievalConfig));
  }
  return toObject;
}
function prebuiltVoiceConfigToVertex(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToVertex(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speechConfigToVertex(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex(fromVoiceConfig));
  }
  if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== undefined) {
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function thinkingConfigToVertex(fromObject) {
  const toObject = {};
  const fromIncludeThoughts = getValueByPath(fromObject, [
    "includeThoughts"
  ]);
  if (fromIncludeThoughts != null) {
    setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
  }
  const fromThinkingBudget = getValueByPath(fromObject, [
    "thinkingBudget"
  ]);
  if (fromThinkingBudget != null) {
    setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
  }
  return toObject;
}
function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], schemaToVertex(tSchema(fromResponseSchema)));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], modelSelectionConfigToVertex(fromModelSelectionConfig));
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== undefined && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToVertex(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== undefined && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex(fromToolConfig));
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== undefined && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== undefined && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToVertex(fromThinkingConfig));
  }
  return toObject;
}
function generateContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function embedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== undefined && fromTaskType != null) {
    setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== undefined && fromTitle != null) {
    setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== undefined && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== undefined && fromMimeType != null) {
    setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
  }
  const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
  if (parentObject !== undefined && fromAutoTruncate != null) {
    setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
  }
  return toObject;
}
function embedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    setValueByPath(toObject, ["instances[]", "content"], tContentsForEmbed(apiClient, fromContents));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], embedContentConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function generateImagesConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== undefined && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== undefined && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== undefined && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== undefined && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== undefined && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== undefined && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== undefined && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== undefined && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== undefined && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  return toObject;
}
function generateImagesParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateImagesConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function imageToVertex(fromObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function maskReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  const fromSegmentationClasses = getValueByPath(fromObject, [
    "segmentationClasses"
  ]);
  if (fromSegmentationClasses != null) {
    setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (fromMaskDilation != null) {
    setValueByPath(toObject, ["dilation"], fromMaskDilation);
  }
  return toObject;
}
function controlReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromControlType = getValueByPath(fromObject, ["controlType"]);
  if (fromControlType != null) {
    setValueByPath(toObject, ["controlType"], fromControlType);
  }
  const fromEnableControlImageComputation = getValueByPath(fromObject, [
    "enableControlImageComputation"
  ]);
  if (fromEnableControlImageComputation != null) {
    setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
  }
  return toObject;
}
function styleReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromStyleDescription = getValueByPath(fromObject, [
    "styleDescription"
  ]);
  if (fromStyleDescription != null) {
    setValueByPath(toObject, ["styleDescription"], fromStyleDescription);
  }
  return toObject;
}
function subjectReferenceConfigToVertex(fromObject) {
  const toObject = {};
  const fromSubjectType = getValueByPath(fromObject, ["subjectType"]);
  if (fromSubjectType != null) {
    setValueByPath(toObject, ["subjectType"], fromSubjectType);
  }
  const fromSubjectDescription = getValueByPath(fromObject, [
    "subjectDescription"
  ]);
  if (fromSubjectDescription != null) {
    setValueByPath(toObject, ["subjectDescription"], fromSubjectDescription);
  }
  return toObject;
}
function referenceImageAPIInternalToVertex(fromObject) {
  const toObject = {};
  const fromReferenceImage = getValueByPath(fromObject, [
    "referenceImage"
  ]);
  if (fromReferenceImage != null) {
    setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
  }
  const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
  if (fromReferenceId != null) {
    setValueByPath(toObject, ["referenceId"], fromReferenceId);
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  const fromMaskImageConfig = getValueByPath(fromObject, [
    "maskImageConfig"
  ]);
  if (fromMaskImageConfig != null) {
    setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
  }
  const fromControlImageConfig = getValueByPath(fromObject, [
    "controlImageConfig"
  ]);
  if (fromControlImageConfig != null) {
    setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
  }
  const fromStyleImageConfig = getValueByPath(fromObject, [
    "styleImageConfig"
  ]);
  if (fromStyleImageConfig != null) {
    setValueByPath(toObject, ["styleImageConfig"], styleReferenceConfigToVertex(fromStyleImageConfig));
  }
  const fromSubjectImageConfig = getValueByPath(fromObject, [
    "subjectImageConfig"
  ]);
  if (fromSubjectImageConfig != null) {
    setValueByPath(toObject, ["subjectImageConfig"], subjectReferenceConfigToVertex(fromSubjectImageConfig));
  }
  return toObject;
}
function editImageConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== undefined && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== undefined && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== undefined && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== undefined && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== undefined && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== undefined && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== undefined && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromEditMode = getValueByPath(fromObject, ["editMode"]);
  if (parentObject !== undefined && fromEditMode != null) {
    setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== undefined && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
  }
  return toObject;
}
function editImageParametersInternalToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return referenceImageAPIInternalToVertex(item);
      });
    }
    setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], editImageConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhanceInputImage = getValueByPath(fromObject, [
    "enhanceInputImage"
  ]);
  if (parentObject !== undefined && fromEnhanceInputImage != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
  }
  const fromImagePreservationFactor = getValueByPath(fromObject, [
    "imagePreservationFactor"
  ]);
  if (parentObject !== undefined && fromImagePreservationFactor != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== undefined && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  return toObject;
}
function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromUpscaleFactor = getValueByPath(fromObject, [
    "upscaleFactor"
  ]);
  if (fromUpscaleFactor != null) {
    setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], upscaleImageAPIConfigInternalToVertex(fromConfig, toObject));
  }
  return toObject;
}
function getModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== undefined && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== undefined && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listModelsConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function updateModelConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== undefined && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== undefined && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== undefined && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], updateModelConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function deleteModelParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function countTokensConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== undefined && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["generationConfig"], fromGenerationConfig);
  }
  return toObject;
}
function countTokensParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], countTokensConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function computeTokensParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToVertex(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function videoToVertex(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generateVideosConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== undefined && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== undefined && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (parentObject !== undefined && fromFps != null) {
    setValueByPath(parentObject, ["parameters", "fps"], fromFps);
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== undefined && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== undefined && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== undefined && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
  if (parentObject !== undefined && fromPubsubTopic != null) {
    setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== undefined && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== undefined && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromGenerateAudio = getValueByPath(fromObject, [
    "generateAudio"
  ]);
  if (parentObject !== undefined && fromGenerateAudio != null) {
    setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== undefined && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
  }
  const fromCompressionQuality = getValueByPath(fromObject, [
    "compressionQuality"
  ]);
  if (parentObject !== undefined && fromCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
  }
  return toObject;
}
function generateVideosParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], generateVideosConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function videoMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromMldev(fromObject) {
  const toObject = {};
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromMldev(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromMldev(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromMldev(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromMldev(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromMldev(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromMldev(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromMldev(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function contentEmbeddingFromMldev(fromObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  return toObject;
}
function embedContentMetadataFromMldev() {
  const toObject = {};
  return toObject;
}
function embedContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromMldev(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], embedContentMetadataFromMldev());
  }
  return toObject;
}
function imageFromMldev(fromObject) {
  const toObject = {};
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function safetyAttributesFromMldev(fromObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function generatedImageFromMldev(fromObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
  }
  return toObject;
}
function generateImagesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function tunedModelInfoFromMldev(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function modelFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["version"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
  }
  const fromInputTokenLimit = getValueByPath(fromObject, [
    "inputTokenLimit"
  ]);
  if (fromInputTokenLimit != null) {
    setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
  }
  const fromOutputTokenLimit = getValueByPath(fromObject, [
    "outputTokenLimit"
  ]);
  if (fromOutputTokenLimit != null) {
    setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
  }
  const fromSupportedActions = getValueByPath(fromObject, [
    "supportedGenerationMethods"
  ]);
  if (fromSupportedActions != null) {
    setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
  }
  return toObject;
}
function listModelsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromMldev(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function deleteModelResponseFromMldev() {
  const toObject = {};
  return toObject;
}
function countTokensResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  return toObject;
}
function videoFromMldev(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["video", "uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "video",
    "encodedVideo"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generatedVideoFromMldev(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
  }
  return toObject;
}
function generateVideosResponseFromMldev(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
  }
  return toObject;
}
function videoMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobFromVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataFromVertex(fromObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partFromVertex(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobFromVertex(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataFromVertex(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentFromVertex(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partFromVertex(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function citationMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citations"]);
  if (fromCitations != null) {
    setValueByPath(toObject, ["citations"], fromCitations);
  }
  return toObject;
}
function urlMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
  if (fromRetrievedUrl != null) {
    setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
  }
  const fromUrlRetrievalStatus = getValueByPath(fromObject, [
    "urlRetrievalStatus"
  ]);
  if (fromUrlRetrievalStatus != null) {
    setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
  }
  return toObject;
}
function urlContextMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
  if (fromUrlMetadata != null) {
    let transformedList = fromUrlMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return urlMetadataFromVertex(item);
      });
    }
    setValueByPath(toObject, ["urlMetadata"], transformedList);
  }
  return toObject;
}
function candidateFromVertex(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], contentFromVertex(fromContent));
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromVertex(fromCitationMetadata));
  }
  const fromFinishMessage = getValueByPath(fromObject, [
    "finishMessage"
  ]);
  if (fromFinishMessage != null) {
    setValueByPath(toObject, ["finishMessage"], fromFinishMessage);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromVertex(fromUrlContextMetadata));
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
  }
  return toObject;
}
function generateContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromVertex(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function contentEmbeddingStatisticsFromVertex(fromObject) {
  const toObject = {};
  const fromTruncated = getValueByPath(fromObject, ["truncated"]);
  if (fromTruncated != null) {
    setValueByPath(toObject, ["truncated"], fromTruncated);
  }
  const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function contentEmbeddingFromVertex(fromObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  const fromStatistics = getValueByPath(fromObject, ["statistics"]);
  if (fromStatistics != null) {
    setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
  }
  return toObject;
}
function embedContentMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromBillableCharacterCount = getValueByPath(fromObject, [
    "billableCharacterCount"
  ]);
  if (fromBillableCharacterCount != null) {
    setValueByPath(toObject, ["billableCharacterCount"], fromBillableCharacterCount);
  }
  return toObject;
}
function embedContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, [
    "predictions[]",
    "embeddings"
  ]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromVertex(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], embedContentMetadataFromVertex(fromMetadata));
  }
  return toObject;
}
function imageFromVertex(fromObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function safetyAttributesFromVertex(fromObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function generatedImageFromVertex(fromObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
  }
  const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromEnhancedPrompt != null) {
    setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
  }
  return toObject;
}
function generateImagesResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function editImageResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function upscaleImageResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function endpointFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["endpoint"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDeployedModelId = getValueByPath(fromObject, [
    "deployedModelId"
  ]);
  if (fromDeployedModelId != null) {
    setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
  }
  return toObject;
}
function tunedModelInfoFromVertex(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function checkpointFromVertex(fromObject) {
  const toObject = {};
  const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
  if (fromCheckpointId != null) {
    setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
  }
  const fromEpoch = getValueByPath(fromObject, ["epoch"]);
  if (fromEpoch != null) {
    setValueByPath(toObject, ["epoch"], fromEpoch);
  }
  const fromStep = getValueByPath(fromObject, ["step"]);
  if (fromStep != null) {
    setValueByPath(toObject, ["step"], fromStep);
  }
  return toObject;
}
function modelFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["versionId"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
  if (fromEndpoints != null) {
    let transformedList = fromEndpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return endpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["endpoints"], transformedList);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (fromDefaultCheckpointId != null) {
    setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return checkpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function listModelsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromVertex(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function deleteModelResponseFromVertex() {
  const toObject = {};
  return toObject;
}
function countTokensResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  return toObject;
}
function computeTokensResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
  if (fromTokensInfo != null) {
    setValueByPath(toObject, ["tokensInfo"], fromTokensInfo);
  }
  return toObject;
}
function videoFromVertex(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function generatedVideoFromVertex(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
  }
  return toObject;
}
function generateVideosResponseFromVertex(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosOperationFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
  }
  return toObject;
}
var CONTENT_TYPE_HEADER = "Content-Type";
var SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
var USER_AGENT_HEADER = "User-Agent";
var GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
var SDK_VERSION = "1.12.0";
var LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
var VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
var GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
var responseLineRE2 = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;

class ApiClient {
  constructor(opts) {
    var _a, _b;
    this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
    const initHttpOptions = {};
    if (this.clientOptions.vertexai) {
      initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== undefined ? _a : VERTEX_AI_API_DEFAULT_VERSION;
      initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
      this.normalizeAuthParameters();
    } else {
      initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== undefined ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
      initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
    }
    initHttpOptions.headers = this.getDefaultHeaders();
    this.clientOptions.httpOptions = initHttpOptions;
    if (opts.httpOptions) {
      this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
    }
  }
  baseUrlFromProjectLocation() {
    if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
      return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
    }
    return `https://aiplatform.googleapis.com/`;
  }
  normalizeAuthParameters() {
    if (this.clientOptions.project && this.clientOptions.location) {
      this.clientOptions.apiKey = undefined;
      return;
    }
    this.clientOptions.project = undefined;
    this.clientOptions.location = undefined;
  }
  isVertexAI() {
    var _a;
    return (_a = this.clientOptions.vertexai) !== null && _a !== undefined ? _a : false;
  }
  getProject() {
    return this.clientOptions.project;
  }
  getLocation() {
    return this.clientOptions.location;
  }
  getApiVersion() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {
      return this.clientOptions.httpOptions.apiVersion;
    }
    throw new Error("API version is not set.");
  }
  getBaseUrl() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {
      return this.clientOptions.httpOptions.baseUrl;
    }
    throw new Error("Base URL is not set.");
  }
  getRequestUrl() {
    return this.getRequestUrlInternal(this.clientOptions.httpOptions);
  }
  getHeaders() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {
      return this.clientOptions.httpOptions.headers;
    } else {
      throw new Error("Headers are not set.");
    }
  }
  getRequestUrlInternal(httpOptions) {
    if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {
      throw new Error("HTTP options are not correctly set.");
    }
    const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
    const urlElement = [baseUrl];
    if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
      urlElement.push(httpOptions.apiVersion);
    }
    return urlElement.join("/");
  }
  getBaseResourcePath() {
    return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
  }
  getApiKey() {
    return this.clientOptions.apiKey;
  }
  getWebsocketBaseUrl() {
    const baseUrl = this.getBaseUrl();
    const urlParts = new URL(baseUrl);
    urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
    return urlParts.toString();
  }
  setBaseUrl(url) {
    if (this.clientOptions.httpOptions) {
      this.clientOptions.httpOptions.baseUrl = url;
    } else {
      throw new Error("HTTP options are not correctly set.");
    }
  }
  constructUrl(path, httpOptions, prependProjectLocation) {
    const urlElement = [this.getRequestUrlInternal(httpOptions)];
    if (prependProjectLocation) {
      urlElement.push(this.getBaseResourcePath());
    }
    if (path !== "") {
      urlElement.push(path);
    }
    const url = new URL(`${urlElement.join("/")}`);
    return url;
  }
  shouldPrependVertexProjectPath(request) {
    if (this.clientOptions.apiKey) {
      return false;
    }
    if (!this.clientOptions.vertexai) {
      return false;
    }
    if (request.path.startsWith("projects/")) {
      return false;
    }
    if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
      return false;
    }
    return true;
  }
  async request(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (request.queryParams) {
      for (const [key, value] of Object.entries(request.queryParams)) {
        url.searchParams.append(key, String(value));
      }
    }
    let requestInit = {};
    if (request.httpMethod === "GET") {
      if (request.body && request.body !== "{}") {
        throw new Error("Request body should be empty for GET request, but got non empty request body");
      }
    } else {
      requestInit.body = request.body;
    }
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
    return this.unaryApiCall(url, requestInit, request.httpMethod);
  }
  patchHttpOptions(baseHttpOptions, requestHttpOptions) {
    const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
    for (const [key, value] of Object.entries(requestHttpOptions)) {
      if (typeof value === "object") {
        patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
      } else if (value !== undefined) {
        patchedHttpOptions[key] = value;
      }
    }
    return patchedHttpOptions;
  }
  async requestStream(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
      url.searchParams.set("alt", "sse");
    }
    let requestInit = {};
    requestInit.body = request.body;
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
    return this.streamApiCall(url, requestInit, request.httpMethod);
  }
  async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {
    if (httpOptions && httpOptions.timeout || abortSignal) {
      const abortController = new AbortController;
      const signal = abortController.signal;
      if (httpOptions.timeout && (httpOptions === null || httpOptions === undefined ? undefined : httpOptions.timeout) > 0) {
        const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
        if (timeoutHandle && typeof timeoutHandle.unref === "function") {
          timeoutHandle.unref();
        }
      }
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => {
          abortController.abort();
        });
      }
      requestInit.signal = signal;
    }
    if (httpOptions && httpOptions.extraBody !== null) {
      includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
    }
    requestInit.headers = await this.getHeadersInternal(httpOptions);
    return requestInit;
  }
  async unaryApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return new HttpResponse(response);
    }).catch((e) => {
      if (e instanceof Error) {
        throw e;
      } else {
        throw new Error(JSON.stringify(e));
      }
    });
  }
  async streamApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return this.processStreamResponse(response);
    }).catch((e) => {
      if (e instanceof Error) {
        throw e;
      } else {
        throw new Error(JSON.stringify(e));
      }
    });
  }
  processStreamResponse(response) {
    var _a;
    return __asyncGenerator2(this, arguments, function* processStreamResponse_1() {
      const reader = (_a = response === null || response === undefined ? undefined : response.body) === null || _a === undefined ? undefined : _a.getReader();
      const decoder = new TextDecoder("utf-8");
      if (!reader) {
        throw new Error("Response body is empty");
      }
      try {
        let buffer = "";
        while (true) {
          const { done, value } = yield __await2(reader.read());
          if (done) {
            if (buffer.trim().length > 0) {
              throw new Error("Incomplete JSON segment at the end");
            }
            break;
          }
          const chunkString = decoder.decode(value, { stream: true });
          try {
            const chunkJson = JSON.parse(chunkString);
            if ("error" in chunkJson) {
              const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
              const status = errorJson["status"];
              const code = errorJson["code"];
              const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
              if (code >= 400 && code < 600) {
                const apiError = new ApiError({
                  message: errorMessage,
                  status: code
                });
                throw apiError;
              }
            }
          } catch (e) {
            const error = e;
            if (error.name === "ApiError") {
              throw e;
            }
          }
          buffer += chunkString;
          let match = buffer.match(responseLineRE2);
          while (match) {
            const processedChunkString = match[1];
            try {
              const partialResponse = new Response(processedChunkString, {
                headers: response === null || response === undefined ? undefined : response.headers,
                status: response === null || response === undefined ? undefined : response.status,
                statusText: response === null || response === undefined ? undefined : response.statusText
              });
              yield yield __await2(new HttpResponse(partialResponse));
              buffer = buffer.slice(match[0].length);
              match = buffer.match(responseLineRE2);
            } catch (e) {
              throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  async apiCall(url, requestInit) {
    return fetch(url, requestInit).catch((e) => {
      throw new Error(`exception ${e} sending request`);
    });
  }
  getDefaultHeaders() {
    const headers = {};
    const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
    headers[USER_AGENT_HEADER] = versionHeaderValue;
    headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
    headers[CONTENT_TYPE_HEADER] = "application/json";
    return headers;
  }
  async getHeadersInternal(httpOptions) {
    const headers = new Headers;
    if (httpOptions && httpOptions.headers) {
      for (const [key, value] of Object.entries(httpOptions.headers)) {
        headers.append(key, value);
      }
      if (httpOptions.timeout && httpOptions.timeout > 0) {
        headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));
      }
    }
    await this.clientOptions.auth.addAuthHeaders(headers);
    return headers;
  }
  async uploadFile(file, config) {
    var _a;
    const fileToUpload = {};
    if (config != null) {
      fileToUpload.mimeType = config.mimeType;
      fileToUpload.name = config.name;
      fileToUpload.displayName = config.displayName;
    }
    if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
      fileToUpload.name = `files/${fileToUpload.name}`;
    }
    const uploader = this.clientOptions.uploader;
    const fileStat = await uploader.stat(file);
    fileToUpload.sizeBytes = String(fileStat.size);
    const mimeType = (_a = config === null || config === undefined ? undefined : config.mimeType) !== null && _a !== undefined ? _a : fileStat.type;
    if (mimeType === undefined || mimeType === "") {
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    }
    fileToUpload.mimeType = mimeType;
    const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);
    return uploader.upload(file, uploadUrl, this);
  }
  async downloadFile(params) {
    const downloader = this.clientOptions.downloader;
    await downloader.download(params, this);
  }
  async fetchUploadUrl(file, config) {
    var _a;
    let httpOptions = {};
    if (config === null || config === undefined ? undefined : config.httpOptions) {
      httpOptions = config.httpOptions;
    } else {
      httpOptions = {
        apiVersion: "",
        headers: {
          "Content-Type": "application/json",
          "X-Goog-Upload-Protocol": "resumable",
          "X-Goog-Upload-Command": "start",
          "X-Goog-Upload-Header-Content-Length": `${file.sizeBytes}`,
          "X-Goog-Upload-Header-Content-Type": `${file.mimeType}`
        }
      };
    }
    const body = {
      file
    };
    const httpResponse = await this.request({
      path: formatMap("upload/v1beta/files", body["_url"]),
      body: JSON.stringify(body),
      httpMethod: "POST",
      httpOptions
    });
    if (!httpResponse || !(httpResponse === null || httpResponse === undefined ? undefined : httpResponse.headers)) {
      throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
    }
    const uploadUrl = (_a = httpResponse === null || httpResponse === undefined ? undefined : httpResponse.headers) === null || _a === undefined ? undefined : _a["x-goog-upload-url"];
    if (uploadUrl === undefined) {
      throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
    }
    return uploadUrl;
  }
}
async function throwErrorIfNotOK(response) {
  var _a;
  if (response === undefined) {
    throw new Error("response is undefined");
  }
  if (!response.ok) {
    const status = response.status;
    let errorBody;
    if ((_a = response.headers.get("content-type")) === null || _a === undefined ? undefined : _a.includes("application/json")) {
      errorBody = await response.json();
    } else {
      errorBody = {
        error: {
          message: await response.text(),
          code: response.status,
          status: response.statusText
        }
      };
    }
    const errorMessage = JSON.stringify(errorBody);
    if (status >= 400 && status < 600) {
      const apiError = new ApiError({
        message: errorMessage,
        status
      });
      throw apiError;
    }
    throw new Error(errorMessage);
  }
}
function includeExtraBodyToRequestInit(requestInit, extraBody) {
  if (!extraBody || Object.keys(extraBody).length === 0) {
    return;
  }
  if (requestInit.body instanceof Blob) {
    console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
    return;
  }
  let currentBodyObject = {};
  if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
    try {
      const parsedBody = JSON.parse(requestInit.body);
      if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
        currentBodyObject = parsedBody;
      } else {
        console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
        return;
      }
    } catch (e) {
      console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
      return;
    }
  }
  function deepMerge(target, source) {
    const output = Object.assign({}, target);
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        const sourceValue = source[key];
        const targetValue = output[key];
        if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
          output[key] = deepMerge(targetValue, sourceValue);
        } else {
          if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
            console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
          }
          output[key] = sourceValue;
        }
      }
    }
    return output;
  }
  const mergedBody = deepMerge(currentBodyObject, extraBody);
  requestInit.body = JSON.stringify(mergedBody);
}
var MCP_LABEL = "mcp_used/unknown";
var hasMcpToolUsageFromMcpToTool = false;
function hasMcpToolUsage(tools) {
  for (const tool of tools) {
    if (isMcpCallableTool(tool)) {
      return true;
    }
    if (typeof tool === "object" && "inputSchema" in tool) {
      return true;
    }
  }
  return hasMcpToolUsageFromMcpToTool;
}
function setMcpUsageHeader(headers) {
  var _a;
  const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== undefined ? _a : "";
  headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
}
function isMcpCallableTool(object) {
  return object !== null && typeof object === "object" && object instanceof McpCallableTool;
}
function listAllTools(mcpClient, maxTools = 100) {
  return __asyncGenerator2(this, arguments, function* listAllTools_1() {
    let cursor = undefined;
    let numTools = 0;
    while (numTools < maxTools) {
      const t = yield __await2(mcpClient.listTools({ cursor }));
      for (const tool of t.tools) {
        yield yield __await2(tool);
        numTools++;
      }
      if (!t.nextCursor) {
        break;
      }
      cursor = t.nextCursor;
    }
  });
}

class McpCallableTool {
  constructor(mcpClients = [], config) {
    this.mcpTools = [];
    this.functionNameToMcpClient = {};
    this.mcpClients = mcpClients;
    this.config = config;
  }
  static create(mcpClients, config) {
    return new McpCallableTool(mcpClients, config);
  }
  async initialize() {
    var _a, e_1, _b, _c;
    if (this.mcpTools.length > 0) {
      return;
    }
    const functionMap = {};
    const mcpTools = [];
    for (const mcpClient of this.mcpClients) {
      try {
        for (var _d = true, _e = (e_1 = undefined, __asyncValues(listAllTools(mcpClient))), _f;_f = await _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const mcpTool = _c;
          mcpTools.push(mcpTool);
          const mcpToolName = mcpTool.name;
          if (functionMap[mcpToolName]) {
            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
          }
          functionMap[mcpToolName] = mcpClient;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return))
            await _b.call(_e);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    this.mcpTools = mcpTools;
    this.functionNameToMcpClient = functionMap;
  }
  async tool() {
    await this.initialize();
    return mcpToolsToGeminiTool(this.mcpTools, this.config);
  }
  async callTool(functionCalls) {
    await this.initialize();
    const functionCallResponseParts = [];
    for (const functionCall of functionCalls) {
      if (functionCall.name in this.functionNameToMcpClient) {
        const mcpClient = this.functionNameToMcpClient[functionCall.name];
        let requestOptions = undefined;
        if (this.config.timeout) {
          requestOptions = {
            timeout: this.config.timeout
          };
        }
        const callToolResponse = await mcpClient.callTool({
          name: functionCall.name,
          arguments: functionCall.args
        }, undefined, requestOptions);
        functionCallResponseParts.push({
          functionResponse: {
            name: functionCall.name,
            response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
          }
        });
      }
    }
    return functionCallResponseParts;
  }
}
async function handleWebSocketMessage$1(apiClient, onmessage, event) {
  const serverMessage = new LiveMusicServerMessage;
  let data;
  if (event.data instanceof Blob) {
    data = JSON.parse(await event.data.text());
  } else {
    data = JSON.parse(event.data);
  }
  const response = liveMusicServerMessageFromMldev(data);
  Object.assign(serverMessage, response);
  onmessage(serverMessage);
}

class LiveMusic {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
  }
  async connect(params) {
    var _a, _b;
    if (this.apiClient.isVertexAI()) {
      throw new Error("Live music is not supported for Vertex AI.");
    }
    console.warn("Live music generation is experimental and may change in future versions.");
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
    const apiKey = this.apiClient.getApiKey();
    const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
    let onopenResolve = () => {};
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a = callbacks === null || callbacks === undefined ? undefined : callbacks.onerror) !== null && _a !== undefined ? _a : function(e) {},
      onclose: (_b = callbacks === null || callbacks === undefined ? undefined : callbacks.onclose) !== null && _b !== undefined ? _b : function(e) {}
    };
    const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    const model = tModel(this.apiClient, params.model);
    const setup = liveMusicClientSetupToMldev({
      model
    });
    const clientMessage = liveMusicClientMessageToMldev({ setup });
    conn.send(JSON.stringify(clientMessage));
    return new LiveMusicSession(conn, this.apiClient);
  }
}

class LiveMusicSession {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  async setWeightedPrompts(params) {
    if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
      throw new Error("Weighted prompts must be set and contain at least one entry.");
    }
    const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);
    const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);
    this.conn.send(JSON.stringify({ clientContent }));
  }
  async setMusicGenerationConfig(params) {
    if (!params.musicGenerationConfig) {
      params.musicGenerationConfig = {};
    }
    const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
    const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);
    this.conn.send(JSON.stringify(clientMessage));
  }
  sendPlaybackControl(playbackControl) {
    const clientMessage = liveMusicClientMessageToMldev({
      playbackControl
    });
    this.conn.send(JSON.stringify(clientMessage));
  }
  play() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
  }
  pause() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
  }
  stop() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
  }
  resetContext() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
  }
  close() {
    this.conn.close();
  }
}
function headersToMap$1(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders$1(map) {
  const headers = new Headers;
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function handleWebSocketMessage(apiClient, onmessage, event) {
  const serverMessage = new LiveServerMessage;
  let jsonData;
  if (event.data instanceof Blob) {
    jsonData = await event.data.text();
  } else if (event.data instanceof ArrayBuffer) {
    jsonData = new TextDecoder().decode(event.data);
  } else {
    jsonData = event.data;
  }
  const data = JSON.parse(jsonData);
  if (apiClient.isVertexAI()) {
    const resp = liveServerMessageFromVertex(data);
    Object.assign(serverMessage, resp);
  } else {
    const resp = liveServerMessageFromMldev(data);
    Object.assign(serverMessage, resp);
  }
  onmessage(serverMessage);
}

class Live {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
    this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
  }
  async connect(params) {
    var _a, _b, _c, _d, _e, _f;
    if (params.config && params.config.httpOptions) {
      throw new Error("The Live module does not support httpOptions at request-level in" + " LiveConnectConfig yet. Please use the client-level httpOptions" + " configuration instead.");
    }
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    let url;
    const clientHeaders = this.apiClient.getHeaders();
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      setMcpUsageHeader(clientHeaders);
    }
    const headers = mapToHeaders(clientHeaders);
    if (this.apiClient.isVertexAI()) {
      url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
      await this.auth.addAuthHeaders(headers);
    } else {
      const apiKey = this.apiClient.getApiKey();
      let method = "BidiGenerateContent";
      let keyName = "key";
      if (apiKey === null || apiKey === undefined ? undefined : apiKey.startsWith("auth_tokens/")) {
        console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
        if (apiVersion !== "v1alpha") {
          console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
        }
        method = "BidiGenerateContentConstrained";
        keyName = "access_token";
      }
      url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
    }
    let onopenResolve = () => {};
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      var _a2;
      (_a2 = callbacks === null || callbacks === undefined ? undefined : callbacks.onopen) === null || _a2 === undefined || _a2.call(callbacks);
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        handleWebSocketMessage(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a = callbacks === null || callbacks === undefined ? undefined : callbacks.onerror) !== null && _a !== undefined ? _a : function(e) {},
      onclose: (_b = callbacks === null || callbacks === undefined ? undefined : callbacks.onclose) !== null && _b !== undefined ? _b : function(e) {}
    };
    const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    let transformedModel = tModel(this.apiClient, params.model);
    if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
      const project = this.apiClient.getProject();
      const location = this.apiClient.getLocation();
      transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
    }
    let clientMessage = {};
    if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === undefined ? undefined : _c.responseModalities) === undefined) {
      if (params.config === undefined) {
        params.config = { responseModalities: [Modality.AUDIO] };
      } else {
        params.config.responseModalities = [Modality.AUDIO];
      }
    }
    if ((_d = params.config) === null || _d === undefined ? undefined : _d.generationConfig) {
      console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
    }
    const inputTools = (_f = (_e = params.config) === null || _e === undefined ? undefined : _e.tools) !== null && _f !== undefined ? _f : [];
    const convertedTools = [];
    for (const tool of inputTools) {
      if (this.isCallableTool(tool)) {
        const callableTool = tool;
        convertedTools.push(await callableTool.tool());
      } else {
        convertedTools.push(tool);
      }
    }
    if (convertedTools.length > 0) {
      params.config.tools = convertedTools;
    }
    const liveConnectParameters = {
      model: transformedModel,
      config: params.config,
      callbacks: params.callbacks
    };
    if (this.apiClient.isVertexAI()) {
      clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
    } else {
      clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
    }
    delete clientMessage["config"];
    conn.send(JSON.stringify(clientMessage));
    return new Session(conn, this.apiClient);
  }
  isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
}
var defaultLiveSendClientContentParamerters = {
  turnComplete: true
};

class Session {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  tLiveClientContent(apiClient, params) {
    if (params.turns !== null && params.turns !== undefined) {
      let contents = [];
      try {
        contents = tContents(params.turns);
        if (apiClient.isVertexAI()) {
          contents = contents.map((item) => contentToVertex(item));
        } else {
          contents = contents.map((item) => contentToMldev$1(item));
        }
      } catch (_a) {
        throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
      }
      return {
        clientContent: { turns: contents, turnComplete: params.turnComplete }
      };
    }
    return {
      clientContent: { turnComplete: params.turnComplete }
    };
  }
  tLiveClienttToolResponse(apiClient, params) {
    let functionResponses = [];
    if (params.functionResponses == null) {
      throw new Error("functionResponses is required.");
    }
    if (!Array.isArray(params.functionResponses)) {
      functionResponses = [params.functionResponses];
    } else {
      functionResponses = params.functionResponses;
    }
    if (functionResponses.length === 0) {
      throw new Error("functionResponses is required.");
    }
    for (const functionResponse of functionResponses) {
      if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
        throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
      }
      if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
        throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
      }
    }
    const clientMessage = {
      toolResponse: { functionResponses }
    };
    return clientMessage;
  }
  sendClientContent(params) {
    params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
    const clientMessage = this.tLiveClientContent(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  sendRealtimeInput(params) {
    let clientMessage = {};
    if (this.apiClient.isVertexAI()) {
      clientMessage = {
        realtimeInput: liveSendRealtimeInputParametersToVertex(params)
      };
    } else {
      clientMessage = {
        realtimeInput: liveSendRealtimeInputParametersToMldev(params)
      };
    }
    this.conn.send(JSON.stringify(clientMessage));
  }
  sendToolResponse(params) {
    if (params.functionResponses == null) {
      throw new Error("Tool response parameters are required.");
    }
    const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  close() {
    this.conn.close();
  }
}
function headersToMap(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders(map) {
  const headers = new Headers;
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var DEFAULT_MAX_REMOTE_CALLS = 10;
function shouldDisableAfc(config) {
  var _a, _b, _c;
  if ((_a = config === null || config === undefined ? undefined : config.automaticFunctionCalling) === null || _a === undefined ? undefined : _a.disable) {
    return true;
  }
  let callableToolsPresent = false;
  for (const tool of (_b = config === null || config === undefined ? undefined : config.tools) !== null && _b !== undefined ? _b : []) {
    if (isCallableTool(tool)) {
      callableToolsPresent = true;
      break;
    }
  }
  if (!callableToolsPresent) {
    return true;
  }
  const maxCalls = (_c = config === null || config === undefined ? undefined : config.automaticFunctionCalling) === null || _c === undefined ? undefined : _c.maximumRemoteCalls;
  if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
    console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
    return true;
  }
  return false;
}
function isCallableTool(tool) {
  return "callTool" in tool && typeof tool.callTool === "function";
}
function hasCallableTools(params) {
  var _a, _b, _c;
  return (_c = (_b = (_a = params.config) === null || _a === undefined ? undefined : _a.tools) === null || _b === undefined ? undefined : _b.some((tool) => isCallableTool(tool))) !== null && _c !== undefined ? _c : false;
}
function hasNonCallableTools(params) {
  var _a, _b, _c;
  return (_c = (_b = (_a = params.config) === null || _a === undefined ? undefined : _a.tools) === null || _b === undefined ? undefined : _b.some((tool) => !isCallableTool(tool))) !== null && _c !== undefined ? _c : false;
}
function shouldAppendAfcHistory(config) {
  var _a;
  return !((_a = config === null || config === undefined ? undefined : config.automaticFunctionCalling) === null || _a === undefined ? undefined : _a.ignoreCallHistory);
}

class Models extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.generateContent = async (params) => {
      var _a, _b, _c, _d, _e;
      const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
      this.maybeMoveToResponseJsonSchem(params);
      if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
        return await this.generateContentInternal(transformedParams);
      }
      if (hasNonCallableTools(params)) {
        throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
      }
      let response;
      let functionResponseContent;
      const automaticFunctionCallingHistory = tContents(transformedParams.contents);
      const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === undefined ? undefined : _a.automaticFunctionCalling) === null || _b === undefined ? undefined : _b.maximumRemoteCalls) !== null && _c !== undefined ? _c : DEFAULT_MAX_REMOTE_CALLS;
      let remoteCalls = 0;
      while (remoteCalls < maxRemoteCalls) {
        response = await this.generateContentInternal(transformedParams);
        if (!response.functionCalls || response.functionCalls.length === 0) {
          break;
        }
        const responseContent = response.candidates[0].content;
        const functionResponseParts = [];
        for (const tool of (_e = (_d = params.config) === null || _d === undefined ? undefined : _d.tools) !== null && _e !== undefined ? _e : []) {
          if (isCallableTool(tool)) {
            const callableTool = tool;
            const parts = await callableTool.callTool(response.functionCalls);
            functionResponseParts.push(...parts);
          }
        }
        remoteCalls++;
        functionResponseContent = {
          role: "user",
          parts: functionResponseParts
        };
        transformedParams.contents = tContents(transformedParams.contents);
        transformedParams.contents.push(responseContent);
        transformedParams.contents.push(functionResponseContent);
        if (shouldAppendAfcHistory(transformedParams.config)) {
          automaticFunctionCallingHistory.push(responseContent);
          automaticFunctionCallingHistory.push(functionResponseContent);
        }
      }
      if (shouldAppendAfcHistory(transformedParams.config)) {
        response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
      }
      return response;
    };
    this.generateContentStream = async (params) => {
      this.maybeMoveToResponseJsonSchem(params);
      if (shouldDisableAfc(params.config)) {
        const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
        return await this.generateContentStreamInternal(transformedParams);
      } else {
        return await this.processAfcStream(params);
      }
    };
    this.generateImages = async (params) => {
      return await this.generateImagesInternal(params).then((apiResponse) => {
        var _a;
        let positivePromptSafetyAttributes;
        const generatedImages = [];
        if (apiResponse === null || apiResponse === undefined ? undefined : apiResponse.generatedImages) {
          for (const generatedImage of apiResponse.generatedImages) {
            if (generatedImage && (generatedImage === null || generatedImage === undefined ? undefined : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === undefined ? undefined : generatedImage.safetyAttributes) === null || _a === undefined ? undefined : _a.contentType) === "Positive Prompt") {
              positivePromptSafetyAttributes = generatedImage === null || generatedImage === undefined ? undefined : generatedImage.safetyAttributes;
            } else {
              generatedImages.push(generatedImage);
            }
          }
        }
        let response;
        if (positivePromptSafetyAttributes) {
          response = {
            generatedImages,
            positivePromptSafetyAttributes,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        } else {
          response = {
            generatedImages,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        }
        return response;
      });
    };
    this.list = async (params) => {
      var _a;
      const defaultConfig = {
        queryBase: true
      };
      const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === undefined ? undefined : params.config);
      const actualParams = {
        config: actualConfig
      };
      if (this.apiClient.isVertexAI()) {
        if (!actualParams.config.queryBase) {
          if ((_a = actualParams.config) === null || _a === undefined ? undefined : _a.filter) {
            throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
          } else {
            actualParams.config.filter = "labels.tune-type:*";
          }
        }
      }
      return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);
    };
    this.editImage = async (params) => {
      const paramsInternal = {
        model: params.model,
        prompt: params.prompt,
        referenceImages: [],
        config: params.config
      };
      if (params.referenceImages) {
        if (params.referenceImages) {
          paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
        }
      }
      return await this.editImageInternal(paramsInternal);
    };
    this.upscaleImage = async (params) => {
      let apiConfig = {
        numberOfImages: 1,
        mode: "upscale"
      };
      if (params.config) {
        apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
      }
      const apiParams = {
        model: params.model,
        image: params.image,
        upscaleFactor: params.upscaleFactor,
        config: apiConfig
      };
      return await this.upscaleImageInternal(apiParams);
    };
    this.generateVideos = async (params) => {
      return await this.generateVideosInternal(params);
    };
  }
  maybeMoveToResponseJsonSchem(params) {
    if (params.config && params.config.responseSchema) {
      if (!params.config.responseJsonSchema) {
        if (Object.keys(params.config.responseSchema).includes("$schema")) {
          params.config.responseJsonSchema = params.config.responseSchema;
          delete params.config.responseSchema;
        }
      }
    }
    return;
  }
  async processParamsMaybeAddMcpUsage(params) {
    var _a, _b, _c;
    const tools = (_a = params.config) === null || _a === undefined ? undefined : _a.tools;
    if (!tools) {
      return params;
    }
    const transformedTools = await Promise.all(tools.map(async (tool) => {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        return await callableTool.tool();
      }
      return tool;
    }));
    const newParams = {
      model: params.model,
      contents: params.contents,
      config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
    };
    newParams.config.tools = transformedTools;
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      const headers = (_c = (_b = params.config.httpOptions) === null || _b === undefined ? undefined : _b.headers) !== null && _c !== undefined ? _c : {};
      let newHeaders = Object.assign({}, headers);
      if (Object.keys(newHeaders).length === 0) {
        newHeaders = this.apiClient.getDefaultHeaders();
      }
      setMcpUsageHeader(newHeaders);
      newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
    }
    return newParams;
  }
  async initAfcToolsMap(params) {
    var _a, _b, _c;
    const afcTools = new Map;
    for (const tool of (_b = (_a = params.config) === null || _a === undefined ? undefined : _a.tools) !== null && _b !== undefined ? _b : []) {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        const toolDeclaration = await callableTool.tool();
        for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== undefined ? _c : []) {
          if (!declaration.name) {
            throw new Error("Function declaration name is required.");
          }
          if (afcTools.has(declaration.name)) {
            throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
          }
          afcTools.set(declaration.name, callableTool);
        }
      }
    }
    return afcTools;
  }
  async processAfcStream(params) {
    var _a, _b, _c;
    const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === undefined ? undefined : _a.automaticFunctionCalling) === null || _b === undefined ? undefined : _b.maximumRemoteCalls) !== null && _c !== undefined ? _c : DEFAULT_MAX_REMOTE_CALLS;
    let wereFunctionsCalled = false;
    let remoteCallCount = 0;
    const afcToolsMap = await this.initAfcToolsMap(params);
    return function(models, afcTools, params2) {
      var _a2, _b2;
      return __asyncGenerator2(this, arguments, function* () {
        var _c2, e_1, _d, _e;
        while (remoteCallCount < maxRemoteCalls) {
          if (wereFunctionsCalled) {
            remoteCallCount++;
            wereFunctionsCalled = false;
          }
          const transformedParams = yield __await2(models.processParamsMaybeAddMcpUsage(params2));
          const response = yield __await2(models.generateContentStreamInternal(transformedParams));
          const functionResponses = [];
          const responseContents = [];
          try {
            for (var _f = true, response_1 = (e_1 = undefined, __asyncValues(response)), response_1_1;response_1_1 = yield __await2(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
              _e = response_1_1.value;
              _f = false;
              const chunk = _e;
              yield yield __await2(chunk);
              if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === undefined ? undefined : _a2.content)) {
                responseContents.push(chunk.candidates[0].content);
                for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== undefined ? _b2 : []) {
                  if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                    if (!part.functionCall.name) {
                      throw new Error("Function call name was not returned by the model.");
                    }
                    if (!afcTools.has(part.functionCall.name)) {
                      throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                    } else {
                      const responseParts = yield __await2(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                      functionResponses.push(...responseParts);
                    }
                  }
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_c2 && (_d = response_1.return))
                yield __await2(_d.call(response_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (functionResponses.length > 0) {
            wereFunctionsCalled = true;
            const typedResponseChunk = new GenerateContentResponse;
            typedResponseChunk.candidates = [
              {
                content: {
                  role: "user",
                  parts: functionResponses
                }
              }
            ];
            yield yield __await2(typedResponseChunk);
            const newContents = [];
            newContents.push(...responseContents);
            newContents.push({
              role: "user",
              parts: functionResponses
            });
            const updatedContents = tContents(params2.contents).concat(newContents);
            params2.contents = updatedContents;
          } else {
            break;
          }
        }
      });
    }(this, afcToolsMap, params);
  }
  async generateContentInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromVertex(apiResponse);
        const typedResp = new GenerateContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromMldev(apiResponse);
        const typedResp = new GenerateContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async generateContentStreamInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator2(this, arguments, function* () {
          var _a2, e_2, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1;apiResponse_1_1 = yield __await2(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
              _c2 = apiResponse_1_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromVertex(yield __await2(chunk.json()));
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse;
              Object.assign(typedResp, resp);
              yield yield __await2(typedResp);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d2 && !_a2 && (_b2 = apiResponse_1.return))
                yield __await2(_b2.call(apiResponse_1));
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        });
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator2(this, arguments, function* () {
          var _a2, e_3, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1;apiResponse_2_1 = yield __await2(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
              _c2 = apiResponse_2_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromMldev(yield __await2(chunk.json()));
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse;
              Object.assign(typedResp, resp);
              yield yield __await2(typedResp);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (!_d2 && !_a2 && (_b2 = apiResponse_2.return))
                yield __await2(_b2.call(apiResponse_2));
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        });
      });
    }
  }
  async embedContent(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = embedContentParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromVertex(apiResponse);
        const typedResp = new EmbedContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = embedContentParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:batchEmbedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromMldev(apiResponse);
        const typedResp = new EmbedContentResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async generateImagesInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateImagesParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromVertex(apiResponse);
        const typedResp = new GenerateImagesResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateImagesParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromMldev(apiResponse);
        const typedResp = new GenerateImagesResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async editImageInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = editImageParametersInternalToVertex(this.apiClient, params);
      path = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = editImageResponseFromVertex(apiResponse);
        const typedResp = new EditImageResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async upscaleImageInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
      path = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = upscaleImageResponseFromVertex(apiResponse);
        const typedResp = new UpscaleImageResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async get(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getModelParametersToVertex(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getModelParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listModelsParametersToVertex(this.apiClient, params);
      path = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromVertex(apiResponse);
        const typedResp = new ListModelsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listModelsParametersToMldev(this.apiClient, params);
      path = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromMldev(apiResponse);
        const typedResp = new ListModelsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async update(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateModelParametersToVertex(this.apiClient, params);
      path = formatMap("{model}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = updateModelParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async delete(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteModelParametersToVertex(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteModelResponseFromVertex();
        const typedResp = new DeleteModelResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteModelParametersToMldev(this.apiClient, params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then(() => {
        const resp = deleteModelResponseFromMldev();
        const typedResp = new DeleteModelResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async countTokens(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = countTokensParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromVertex(apiResponse);
        const typedResp = new CountTokensResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = countTokensParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromMldev(apiResponse);
        const typedResp = new CountTokensResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async computeTokens(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = computeTokensParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:computeTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromVertex(apiResponse);
        const typedResp = new ComputeTokensResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async generateVideosInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateVideosParametersToVertex(this.apiClient, params);
      path = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromVertex(apiResponse);
        const typedResp = new GenerateVideosOperation;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateVideosParametersToMldev(this.apiClient, params);
      path = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromMldev(apiResponse);
        const typedResp = new GenerateVideosOperation;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
}
function getOperationParametersToMldev(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function getOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function fetchPredictOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["operationName"], fromOperationName);
  }
  const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
  if (fromResourceName != null) {
    setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}

class Operations extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  async getVideosOperation(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === undefined || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = undefined;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: false
      });
    }
  }
  async get(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === undefined || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = undefined;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        isVertexAI: false
      });
    }
  }
  async getVideosOperationInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getOperationParametersToVertex(params);
      path = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      const body = getOperationParametersToMldev(params);
      path = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    }
  }
  async fetchPredictVideosOperationInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = fetchPredictOperationParametersToVertex(params);
      path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
}
function prebuiltVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
  if (fromVoiceName != null) {
    setValueByPath(toObject, ["voiceName"], fromVoiceName);
  }
  return toObject;
}
function voiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
    "prebuiltVoiceConfig"
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));
  }
  return toObject;
}
function speakerVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
  if (fromSpeaker != null) {
    setValueByPath(toObject, ["speaker"], fromSpeaker);
  }
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
  }
  return toObject;
}
function multiSpeakerVoiceConfigToMldev(fromObject) {
  const toObject = {};
  const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
    "speakerVoiceConfigs"
  ]);
  if (fromSpeakerVoiceConfigs != null) {
    let transformedList = fromSpeakerVoiceConfigs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return speakerVoiceConfigToMldev(item);
      });
    }
    setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
  }
  return toObject;
}
function speechConfigToMldev(fromObject) {
  const toObject = {};
  const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
  if (fromVoiceConfig != null) {
    setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
  }
  const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
    "multiSpeakerVoiceConfig"
  ]);
  if (fromMultiSpeakerVoiceConfig != null) {
    setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));
  }
  const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
  if (fromLanguageCode != null) {
    setValueByPath(toObject, ["languageCode"], fromLanguageCode);
  }
  return toObject;
}
function videoMetadataToMldev(fromObject) {
  const toObject = {};
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (fromFps != null) {
    setValueByPath(toObject, ["fps"], fromFps);
  }
  const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
  if (fromEndOffset != null) {
    setValueByPath(toObject, ["endOffset"], fromEndOffset);
  }
  const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
  if (fromStartOffset != null) {
    setValueByPath(toObject, ["startOffset"], fromStartOffset);
  }
  return toObject;
}
function blobToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function fileDataToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== undefined) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function partToMldev(fromObject) {
  const toObject = {};
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev(fromVideoMetadata));
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], fromFunctionCall);
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  return toObject;
}
function contentToMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function functionDeclarationToMldev(fromObject) {
  const toObject = {};
  const fromBehavior = getValueByPath(fromObject, ["behavior"]);
  if (fromBehavior != null) {
    setValueByPath(toObject, ["behavior"], fromBehavior);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  return toObject;
}
function intervalToMldev(fromObject) {
  const toObject = {};
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  return toObject;
}
function googleSearchToMldev(fromObject) {
  const toObject = {};
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev(fromTimeRangeFilter));
  }
  return toObject;
}
function dynamicRetrievalConfigToMldev(fromObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  const fromDynamicThreshold = getValueByPath(fromObject, [
    "dynamicThreshold"
  ]);
  if (fromDynamicThreshold != null) {
    setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
  }
  return toObject;
}
function googleSearchRetrievalToMldev(fromObject) {
  const toObject = {};
  const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
    "dynamicRetrievalConfig"
  ]);
  if (fromDynamicRetrievalConfig != null) {
    setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));
  }
  return toObject;
}
function urlContextToMldev() {
  const toObject = {};
  return toObject;
}
function toolToMldev(fromObject) {
  const toObject = {};
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToMldev(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  if (getValueByPath(fromObject, ["retrieval"]) !== undefined) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== undefined) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["googleMaps"]) !== undefined) {
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], urlContextToMldev());
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  return toObject;
}
function sessionResumptionConfigToMldev(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== undefined) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function audioTranscriptionConfigToMldev() {
  const toObject = {};
  return toObject;
}
function automaticActivityDetectionToMldev(fromObject) {
  const toObject = {};
  const fromDisabled = getValueByPath(fromObject, ["disabled"]);
  if (fromDisabled != null) {
    setValueByPath(toObject, ["disabled"], fromDisabled);
  }
  const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
    "startOfSpeechSensitivity"
  ]);
  if (fromStartOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
  }
  const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
    "endOfSpeechSensitivity"
  ]);
  if (fromEndOfSpeechSensitivity != null) {
    setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
  }
  const fromPrefixPaddingMs = getValueByPath(fromObject, [
    "prefixPaddingMs"
  ]);
  if (fromPrefixPaddingMs != null) {
    setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
  }
  const fromSilenceDurationMs = getValueByPath(fromObject, [
    "silenceDurationMs"
  ]);
  if (fromSilenceDurationMs != null) {
    setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
  }
  return toObject;
}
function realtimeInputConfigToMldev(fromObject) {
  const toObject = {};
  const fromAutomaticActivityDetection = getValueByPath(fromObject, [
    "automaticActivityDetection"
  ]);
  if (fromAutomaticActivityDetection != null) {
    setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));
  }
  const fromActivityHandling = getValueByPath(fromObject, [
    "activityHandling"
  ]);
  if (fromActivityHandling != null) {
    setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
  }
  const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
  if (fromTurnCoverage != null) {
    setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
  }
  return toObject;
}
function slidingWindowToMldev(fromObject) {
  const toObject = {};
  const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
  if (fromTargetTokens != null) {
    setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
  }
  return toObject;
}
function contextWindowCompressionConfigToMldev(fromObject) {
  const toObject = {};
  const fromTriggerTokens = getValueByPath(fromObject, [
    "triggerTokens"
  ]);
  if (fromTriggerTokens != null) {
    setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
  }
  const fromSlidingWindow = getValueByPath(fromObject, [
    "slidingWindow"
  ]);
  if (fromSlidingWindow != null) {
    setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev(fromSlidingWindow));
  }
  return toObject;
}
function proactivityConfigToMldev(fromObject) {
  const toObject = {};
  const fromProactiveAudio = getValueByPath(fromObject, [
    "proactiveAudio"
  ]);
  if (fromProactiveAudio != null) {
    setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
  }
  return toObject;
}
function liveConnectConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== undefined && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== undefined && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== undefined && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== undefined && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== undefined && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== undefined && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== undefined && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== undefined && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== undefined && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== undefined && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== undefined && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== undefined && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev());
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== undefined && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev());
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== undefined && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev(fromRealtimeInputConfig));
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== undefined && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev(fromContextWindowCompression));
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== undefined && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev(fromProactivity));
  }
  return toObject;
}
function liveConnectConstraintsToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== undefined && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromNewSessionExpireTime = getValueByPath(fromObject, [
    "newSessionExpireTime"
  ]);
  if (parentObject !== undefined && fromNewSessionExpireTime != null) {
    setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
  }
  const fromUses = getValueByPath(fromObject, ["uses"]);
  if (parentObject !== undefined && fromUses != null) {
    setValueByPath(parentObject, ["uses"], fromUses);
  }
  const fromLiveConnectConstraints = getValueByPath(fromObject, [
    "liveConnectConstraints"
  ]);
  if (parentObject !== undefined && fromLiveConnectConstraints != null) {
    setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
  }
  const fromLockAdditionalFields = getValueByPath(fromObject, [
    "lockAdditionalFields"
  ]);
  if (parentObject !== undefined && fromLockAdditionalFields != null) {
    setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
  }
  return toObject;
}
function createAuthTokenParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function authTokenFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  return toObject;
}
function getFieldMasks(setup) {
  const fields = [];
  for (const key in setup) {
    if (Object.prototype.hasOwnProperty.call(setup, key)) {
      const value = setup[key];
      if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
        const field = Object.keys(value).map((kk) => `${key}.${kk}`);
        fields.push(...field);
      } else {
        fields.push(key);
      }
    }
  }
  return fields.join(",");
}
function convertBidiSetupToTokenSetup(requestDict, config) {
  let setupForMaskGeneration = null;
  const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
  if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
    const innerSetup = bidiGenerateContentSetupValue.setup;
    if (typeof innerSetup === "object" && innerSetup !== null) {
      requestDict["bidiGenerateContentSetup"] = innerSetup;
      setupForMaskGeneration = innerSetup;
    } else {
      delete requestDict["bidiGenerateContentSetup"];
    }
  } else if (bidiGenerateContentSetupValue !== undefined) {
    delete requestDict["bidiGenerateContentSetup"];
  }
  const preExistingFieldMask = requestDict["fieldMask"];
  if (setupForMaskGeneration) {
    const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
    if (Array.isArray(config === null || config === undefined ? undefined : config.lockAdditionalFields) && (config === null || config === undefined ? undefined : config.lockAdditionalFields.length) === 0) {
      if (generatedMaskFromBidi) {
        requestDict["fieldMask"] = generatedMaskFromBidi;
      } else {
        delete requestDict["fieldMask"];
      }
    } else if ((config === null || config === undefined ? undefined : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      const generationConfigFields = [
        "temperature",
        "topK",
        "topP",
        "maxOutputTokens",
        "responseModalities",
        "seed",
        "speechConfig"
      ];
      let mappedFieldsFromPreExisting = [];
      if (preExistingFieldMask.length > 0) {
        mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
          if (generationConfigFields.includes(field)) {
            return `generationConfig.${field}`;
          }
          return field;
        });
      }
      const finalMaskParts = [];
      if (generatedMaskFromBidi) {
        finalMaskParts.push(generatedMaskFromBidi);
      }
      if (mappedFieldsFromPreExisting.length > 0) {
        finalMaskParts.push(...mappedFieldsFromPreExisting);
      }
      if (finalMaskParts.length > 0) {
        requestDict["fieldMask"] = finalMaskParts.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      delete requestDict["fieldMask"];
    }
  } else {
    if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      requestDict["fieldMask"] = preExistingFieldMask.join(",");
    } else {
      delete requestDict["fieldMask"];
    }
  }
  return requestDict;
}

class Tokens extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  async create(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
    } else {
      const body = createAuthTokenParametersToMldev(this.apiClient, params);
      path = formatMap("auth_tokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(transformedBody),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = authTokenFromMldev(apiResponse);
        return resp;
      });
    }
  }
}
var GOOGLE_API_KEY_HEADER = "x-goog-api-key";
var REQUIRED_VERTEX_AI_SCOPE = "https://www.googleapis.com/auth/cloud-platform";

class NodeAuth {
  constructor(opts) {
    if (opts.apiKey !== undefined) {
      this.apiKey = opts.apiKey;
      return;
    }
    const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);
    this.googleAuth = new import_google_auth_library.GoogleAuth(vertexAuthOptions);
  }
  async addAuthHeaders(headers) {
    if (this.apiKey !== undefined) {
      if (this.apiKey.startsWith("auth_tokens/")) {
        throw new Error("Ephemeral tokens are only supported by the live API.");
      }
      this.addKeyHeader(headers);
      return;
    }
    return this.addGoogleAuthHeaders(headers);
  }
  addKeyHeader(headers) {
    if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
      return;
    }
    if (this.apiKey === undefined) {
      throw new Error("Trying to set API key header but apiKey is not set");
    }
    headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
  }
  async addGoogleAuthHeaders(headers) {
    if (this.googleAuth === undefined) {
      throw new Error("Trying to set google-auth headers but googleAuth is unset");
    }
    const authHeaders = await this.googleAuth.getRequestHeaders();
    for (const key in authHeaders) {
      if (headers.get(key) !== null) {
        continue;
      }
      headers.append(key, authHeaders[key]);
    }
  }
}
function buildGoogleAuthOptions(googleAuthOptions) {
  let authOptions;
  if (!googleAuthOptions) {
    authOptions = {
      scopes: [REQUIRED_VERTEX_AI_SCOPE]
    };
    return authOptions;
  } else {
    authOptions = googleAuthOptions;
    if (!authOptions.scopes) {
      authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];
      return authOptions;
    } else if (typeof authOptions.scopes === "string" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {
      throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);
    }
    return authOptions;
  }
}

class NodeDownloader {
  async download(params, apiClient) {
    if (params.downloadPath) {
      const response = await downloadFile(params, apiClient);
      if (response instanceof HttpResponse) {
        const writer = createWriteStream(params.downloadPath);
        Readable.fromWeb(response.responseInternal.body).pipe(writer);
      } else {
        writeFile(params.downloadPath, response, { encoding: "base64" }, (error) => {
          if (error) {
            throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);
          }
        });
      }
    }
  }
}
async function downloadFile(params, apiClient) {
  var _a, _b, _c;
  const name = tFileName(params.file);
  if (name !== undefined) {
    return await apiClient.request({
      path: `files/${name}:download`,
      httpMethod: "GET",
      queryParams: {
        alt: "media"
      },
      httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
      abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
    });
  } else if (isGeneratedVideo(params.file)) {
    const videoBytes = (_c = params.file.video) === null || _c === undefined ? undefined : _c.videoBytes;
    if (typeof videoBytes === "string") {
      return videoBytes;
    } else {
      throw new Error("Failed to download generated video, Uri or videoBytes not found.");
    }
  } else if (isVideo(params.file)) {
    const videoBytes = params.file.videoBytes;
    if (typeof videoBytes === "string") {
      return videoBytes;
    } else {
      throw new Error("Failed to download video, Uri or videoBytes not found.");
    }
  } else {
    throw new Error("Unsupported file type");
  }
}

class NodeWebSocketFactory {
  create(url, headers, callbacks) {
    return new NodeWebSocket(url, headers, callbacks);
  }
}

class NodeWebSocket {
  constructor(url, headers, callbacks) {
    this.url = url;
    this.headers = headers;
    this.callbacks = callbacks;
  }
  connect() {
    this.ws = new import_websocket.default(this.url, { headers: this.headers });
    this.ws.onopen = this.callbacks.onopen;
    this.ws.onerror = this.callbacks.onerror;
    this.ws.onclose = this.callbacks.onclose;
    this.ws.onmessage = this.callbacks.onmessage;
  }
  send(message) {
    if (this.ws === undefined) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.send(message);
  }
  close() {
    if (this.ws === undefined) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.close();
  }
}
function getTuningJobParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listTuningJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== undefined && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listTuningJobsConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function tuningExampleToMldev(fromObject) {
  const toObject = {};
  const fromTextInput = getValueByPath(fromObject, ["textInput"]);
  if (fromTextInput != null) {
    setValueByPath(toObject, ["textInput"], fromTextInput);
  }
  const fromOutput = getValueByPath(fromObject, ["output"]);
  if (fromOutput != null) {
    setValueByPath(toObject, ["output"], fromOutput);
  }
  return toObject;
}
function tuningDatasetToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== undefined) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== undefined) {
    throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
  }
  const fromExamples = getValueByPath(fromObject, ["examples"]);
  if (fromExamples != null) {
    let transformedList = fromExamples;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningExampleToMldev(item);
      });
    }
    setValueByPath(toObject, ["examples", "examples"], transformedList);
  }
  return toObject;
}
function createTuningJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["validationDataset"]) !== undefined) {
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== undefined && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
  }
  if (getValueByPath(fromObject, ["description"]) !== undefined) {
    throw new Error("description parameter is not supported in Gemini API.");
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== undefined && fromEpochCount != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (fromLearningRateMultiplier != null) {
    setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== undefined) {
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["adapterSize"]) !== undefined) {
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  }
  const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
  if (parentObject !== undefined && fromBatchSize != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
  }
  const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
  if (parentObject !== undefined && fromLearningRate != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
  }
  return toObject;
}
function createTuningJobParametersToMldev(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    setValueByPath(toObject, ["tuningTask", "trainingData"], tuningDatasetToMldev(fromTrainingDataset));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createTuningJobConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function getTuningJobParametersToVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], fromConfig);
  }
  return toObject;
}
function listTuningJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== undefined && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== undefined && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== undefined && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], listTuningJobsConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function tuningDatasetToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (parentObject !== undefined && fromGcsUri != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (parentObject !== undefined && fromVertexDatasetResource != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
  }
  if (getValueByPath(fromObject, ["examples"]) !== undefined) {
    throw new Error("examples parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function tuningValidationDatasetToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (parentObject !== undefined && fromVertexDatasetResource != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
  }
  return toObject;
}
function createTuningJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromValidationDataset = getValueByPath(fromObject, [
    "validationDataset"
  ]);
  if (parentObject !== undefined && fromValidationDataset != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset, toObject));
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== undefined && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== undefined && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== undefined && fromEpochCount != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (parentObject !== undefined && fromLearningRateMultiplier != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
    "exportLastCheckpointOnly"
  ]);
  if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
  }
  const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
  if (parentObject !== undefined && fromAdapterSize != null) {
    setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
  }
  if (getValueByPath(fromObject, ["batchSize"]) !== undefined) {
    throw new Error("batchSize parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["learningRate"]) !== undefined) {
    throw new Error("learningRate parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function createTuningJobParametersToVertex(fromObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    setValueByPath(toObject, ["supervisedTuningSpec", "trainingDatasetUri"], tuningDatasetToVertex(fromTrainingDataset, toObject));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createTuningJobConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function tunedModelFromMldev(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["name"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["name"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tuningJobFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, [
    "tuningTask",
    "startTime"
  ]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "tuningTask",
    "completeTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromSatisfiesPzi = getValueByPath(fromObject, ["satisfiesPzi"]);
  if (fromSatisfiesPzi != null) {
    setValueByPath(toObject, ["satisfiesPzi"], fromSatisfiesPzi);
  }
  const fromSatisfiesPzs = getValueByPath(fromObject, ["satisfiesPzs"]);
  if (fromSatisfiesPzs != null) {
    setValueByPath(toObject, ["satisfiesPzs"], fromSatisfiesPzs);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  return toObject;
}
function listTuningJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function tuningOperationFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function tunedModelCheckpointFromVertex(fromObject) {
  const toObject = {};
  const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
  if (fromCheckpointId != null) {
    setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
  }
  const fromEpoch = getValueByPath(fromObject, ["epoch"]);
  if (fromEpoch != null) {
    setValueByPath(toObject, ["epoch"], fromEpoch);
  }
  const fromStep = getValueByPath(fromObject, ["step"]);
  if (fromStep != null) {
    setValueByPath(toObject, ["step"], fromStep);
  }
  const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tunedModelFromVertex(fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tunedModelCheckpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function tuningJobFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromVertex(fromTunedModel));
  }
  const fromSupervisedTuningSpec = getValueByPath(fromObject, [
    "supervisedTuningSpec"
  ]);
  if (fromSupervisedTuningSpec != null) {
    setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
  }
  const fromTuningDataStats = getValueByPath(fromObject, [
    "tuningDataStats"
  ]);
  if (fromTuningDataStats != null) {
    setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
  }
  const fromEncryptionSpec = getValueByPath(fromObject, [
    "encryptionSpec"
  ]);
  if (fromEncryptionSpec != null) {
    setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
  }
  const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
    "partnerModelTuningSpec"
  ]);
  if (fromPartnerModelTuningSpec != null) {
    setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromSatisfiesPzi = getValueByPath(fromObject, ["satisfiesPzi"]);
  if (fromSatisfiesPzi != null) {
    setValueByPath(toObject, ["satisfiesPzi"], fromSatisfiesPzi);
  }
  const fromSatisfiesPzs = getValueByPath(fromObject, ["satisfiesPzs"]);
  if (fromSatisfiesPzs != null) {
    setValueByPath(toObject, ["satisfiesPzs"], fromSatisfiesPzs);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  return toObject;
}
function listTuningJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}

class Tunings extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.get = async (params) => {
      return await this.getInternal(params);
    };
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
    };
    this.tune = async (params) => {
      if (this.apiClient.isVertexAI()) {
        return await this.tuneInternal(params);
      } else {
        const operation = await this.tuneMldevInternal(params);
        let tunedModelName = "";
        if (operation["metadata"] !== undefined && operation["metadata"]["tunedModel"] !== undefined) {
          tunedModelName = operation["metadata"]["tunedModel"];
        } else if (operation["name"] !== undefined && operation["name"].includes("/operations/")) {
          tunedModelName = operation["name"].split("/operations/")[0];
        }
        const tuningJob = {
          name: tunedModelName,
          state: JobState.JOB_STATE_QUEUED
        };
        return tuningJob;
      }
    };
  }
  async getInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getTuningJobParametersToVertex(params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getTuningJobParametersToMldev(params);
      path = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a, _b, _c, _d;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listTuningJobsParametersToVertex(params);
      path = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromVertex(apiResponse);
        const typedResp = new ListTuningJobsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listTuningJobsParametersToMldev(params);
      path = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === undefined ? undefined : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === undefined ? undefined : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromMldev(apiResponse);
        const typedResp = new ListTuningJobsResponse;
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async tuneInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createTuningJobParametersToVertex(params);
      path = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async tuneMldevInternal(params) {
    var _a, _b;
    let response;
    let path = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createTuningJobParametersToMldev(params);
      path = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a = params.config) === null || _a === undefined ? undefined : _a.httpOptions,
        abortSignal: (_b = params.config) === null || _b === undefined ? undefined : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningOperationFromMldev(apiResponse);
        return resp;
      });
    }
  }
}
var MAX_CHUNK_SIZE = 1024 * 1024 * 8;
var MAX_RETRY_COUNT = 3;
var INITIAL_RETRY_DELAY_MS = 1000;
var DELAY_MULTIPLIER = 2;
var X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
async function uploadBlob(file, uploadUrl, apiClient) {
  var _a, _b, _c;
  let fileSize = 0;
  let offset = 0;
  let response = new HttpResponse(new Response);
  let uploadCommand = "upload";
  fileSize = file.size;
  while (offset < fileSize) {
    const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
    const chunk = file.slice(offset, offset + chunkSize);
    if (offset + chunkSize >= fileSize) {
      uploadCommand += ", finalize";
    }
    let retryCount = 0;
    let currentDelayMs = INITIAL_RETRY_DELAY_MS;
    while (retryCount < MAX_RETRY_COUNT) {
      response = await apiClient.request({
        path: "",
        body: chunk,
        httpMethod: "POST",
        httpOptions: {
          apiVersion: "",
          baseUrl: uploadUrl,
          headers: {
            "X-Goog-Upload-Command": uploadCommand,
            "X-Goog-Upload-Offset": String(offset),
            "Content-Length": String(chunkSize)
          }
        }
      });
      if ((_a = response === null || response === undefined ? undefined : response.headers) === null || _a === undefined ? undefined : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
        break;
      }
      retryCount++;
      await sleep(currentDelayMs);
      currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
    }
    offset += chunkSize;
    if (((_b = response === null || response === undefined ? undefined : response.headers) === null || _b === undefined ? undefined : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
      break;
    }
    if (fileSize <= offset) {
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
    }
  }
  const responseJson = await (response === null || response === undefined ? undefined : response.json());
  if (((_c = response === null || response === undefined ? undefined : response.headers) === null || _c === undefined ? undefined : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  return responseJson["file"];
}
async function getBlobStat(file) {
  const fileStat = { size: file.size, type: file.type };
  return fileStat;
}
function sleep(ms) {
  return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
}

class NodeUploader {
  async stat(file) {
    const fileStat = { size: 0, type: undefined };
    if (typeof file === "string") {
      const originalStat = await fs.stat(file);
      fileStat.size = originalStat.size;
      fileStat.type = this.inferMimeType(file);
      return fileStat;
    } else {
      return await getBlobStat(file);
    }
  }
  async upload(file, uploadUrl, apiClient) {
    if (typeof file === "string") {
      return await this.uploadFileFromPath(file, uploadUrl, apiClient);
    } else {
      return uploadBlob(file, uploadUrl, apiClient);
    }
  }
  inferMimeType(filePath) {
    const fileExtension = filePath.slice(filePath.lastIndexOf(".") + 1);
    const mimeTypes = {
      aac: "audio/aac",
      abw: "application/x-abiword",
      arc: "application/x-freearc",
      avi: "video/x-msvideo",
      azw: "application/vnd.amazon.ebook",
      bin: "application/octet-stream",
      bmp: "image/bmp",
      bz: "application/x-bzip",
      bz2: "application/x-bzip2",
      csh: "application/x-csh",
      css: "text/css",
      csv: "text/csv",
      doc: "application/msword",
      docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      eot: "application/vnd.ms-fontobject",
      epub: "application/epub+zip",
      gz: "application/gzip",
      gif: "image/gif",
      htm: "text/html",
      html: "text/html",
      ico: "image/vnd.microsoft.icon",
      ics: "text/calendar",
      jar: "application/java-archive",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      js: "text/javascript",
      json: "application/json",
      jsonld: "application/ld+json",
      kml: "application/vnd.google-earth.kml+xml",
      kmz: "application/vnd.google-earth.kmz+xml",
      mjs: "text/javascript",
      mp3: "audio/mpeg",
      mp4: "video/mp4",
      mpeg: "video/mpeg",
      mpkg: "application/vnd.apple.installer+xml",
      odt: "application/vnd.oasis.opendocument.text",
      oga: "audio/ogg",
      ogv: "video/ogg",
      ogx: "application/ogg",
      opus: "audio/opus",
      otf: "font/otf",
      png: "image/png",
      pdf: "application/pdf",
      php: "application/x-httpd-php",
      ppt: "application/vnd.ms-powerpoint",
      pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      rar: "application/vnd.rar",
      rtf: "application/rtf",
      sh: "application/x-sh",
      svg: "image/svg+xml",
      swf: "application/x-shockwave-flash",
      tar: "application/x-tar",
      tif: "image/tiff",
      tiff: "image/tiff",
      ts: "video/mp2t",
      ttf: "font/ttf",
      txt: "text/plain",
      vsd: "application/vnd.visio",
      wav: "audio/wav",
      weba: "audio/webm",
      webm: "video/webm",
      webp: "image/webp",
      woff: "font/woff",
      woff2: "font/woff2",
      xhtml: "application/xhtml+xml",
      xls: "application/vnd.ms-excel",
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      xml: "application/xml",
      xul: "application/vnd.mozilla.xul+xml",
      zip: "application/zip",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      "7z": "application/x-7z-compressed"
    };
    const mimeType = mimeTypes[fileExtension.toLowerCase()];
    return mimeType;
  }
  async uploadFileFromPath(file, uploadUrl, apiClient) {
    var _a, _b, _c;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response);
    let uploadCommand = "upload";
    let fileHandle;
    try {
      fileHandle = await fs.open(file, "r");
      if (!fileHandle) {
        throw new Error(`Failed to open file`);
      }
      fileSize = (await fileHandle.stat()).size;
      while (offset < fileSize) {
        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
        if (offset + chunkSize >= fileSize) {
          uploadCommand += ", finalize";
        }
        const buffer = new Uint8Array(chunkSize);
        const { bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);
        if (bytesRead !== chunkSize) {
          throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);
        }
        const chunk = new Blob([buffer]);
        let retryCount = 0;
        let currentDelayMs = INITIAL_RETRY_DELAY_MS;
        while (retryCount < MAX_RETRY_COUNT) {
          response = await apiClient.request({
            path: "",
            body: chunk,
            httpMethod: "POST",
            httpOptions: {
              apiVersion: "",
              baseUrl: uploadUrl,
              headers: {
                "X-Goog-Upload-Command": uploadCommand,
                "X-Goog-Upload-Offset": String(offset),
                "Content-Length": String(bytesRead)
              }
            }
          });
          if ((_a = response === null || response === undefined ? undefined : response.headers) === null || _a === undefined ? undefined : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
            break;
          }
          retryCount++;
          await sleep(currentDelayMs);
          currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
        }
        offset += bytesRead;
        if (((_b = response === null || response === undefined ? undefined : response.headers) === null || _b === undefined ? undefined : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
          break;
        }
        if (fileSize <= offset) {
          throw new Error("All content has been uploaded, but the upload status is not finalized.");
        }
      }
      const responseJson = await (response === null || response === undefined ? undefined : response.json());
      if (((_c = response === null || response === undefined ? undefined : response.headers) === null || _c === undefined ? undefined : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
        throw new Error("Failed to upload file: Upload status is not finalized.");
      }
      return responseJson["file"];
    } finally {
      if (fileHandle) {
        await fileHandle.close();
      }
    }
  }
}
var LANGUAGE_LABEL_PREFIX = "gl-node/";

class GoogleGenAI {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f;
    if ((options.project || options.location) && options.apiKey) {
      throw new Error("Project/location and API key are mutually exclusive in the client initializer.");
    }
    this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== undefined ? _a : getBooleanEnv("GOOGLE_GENAI_USE_VERTEXAI")) !== null && _b !== undefined ? _b : false;
    const envApiKey = getApiKeyFromEnv();
    const envProject = getEnv("GOOGLE_CLOUD_PROJECT");
    const envLocation = getEnv("GOOGLE_CLOUD_LOCATION");
    this.apiKey = (_c = options.apiKey) !== null && _c !== undefined ? _c : envApiKey;
    this.project = (_d = options.project) !== null && _d !== undefined ? _d : envProject;
    this.location = (_e = options.location) !== null && _e !== undefined ? _e : envLocation;
    if (options.vertexai) {
      if ((_f = options.googleAuthOptions) === null || _f === undefined ? undefined : _f.credentials) {
        console.debug("The user provided Google Cloud credentials will take precedence" + " over the API key from the environment variable.");
        this.apiKey = undefined;
      }
      if ((envProject || envLocation) && options.apiKey) {
        console.debug("The user provided Vertex AI API key will take precedence over" + " the project/location from the environment variables.");
        this.project = undefined;
        this.location = undefined;
      } else if ((options.project || options.location) && envApiKey) {
        console.debug("The user provided project/location will take precedence over" + " the API key from the environment variables.");
        this.apiKey = undefined;
      } else if ((envProject || envLocation) && envApiKey) {
        console.debug("The project/location from the environment variables will take" + " precedence over the API key from the environment variables.");
        this.apiKey = undefined;
      }
    }
    const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv("GOOGLE_VERTEX_BASE_URL"), getEnv("GOOGLE_GEMINI_BASE_URL"));
    if (baseUrl) {
      if (options.httpOptions) {
        options.httpOptions.baseUrl = baseUrl;
      } else {
        options.httpOptions = { baseUrl };
      }
    }
    this.apiVersion = options.apiVersion;
    const auth = new NodeAuth({
      apiKey: this.apiKey,
      googleAuthOptions: options.googleAuthOptions
    });
    this.apiClient = new ApiClient({
      auth,
      project: this.project,
      location: this.location,
      apiVersion: this.apiVersion,
      apiKey: this.apiKey,
      vertexai: this.vertexai,
      httpOptions: options.httpOptions,
      userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,
      uploader: new NodeUploader,
      downloader: new NodeDownloader
    });
    this.models = new Models(this.apiClient);
    this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory);
    this.batches = new Batches(this.apiClient);
    this.chats = new Chats(this.models, this.apiClient);
    this.caches = new Caches(this.apiClient);
    this.files = new Files(this.apiClient);
    this.operations = new Operations(this.apiClient);
    this.authTokens = new Tokens(this.apiClient);
    this.tunings = new Tunings(this.apiClient);
  }
}
function getEnv(env) {
  var _a, _b, _c;
  return (_c = (_b = (_a = process === null || process === undefined ? undefined : process.env) === null || _a === undefined ? undefined : _a[env]) === null || _b === undefined ? undefined : _b.trim()) !== null && _c !== undefined ? _c : undefined;
}
function getBooleanEnv(env) {
  return stringToBoolean(getEnv(env));
}
function stringToBoolean(str) {
  if (str === undefined) {
    return false;
  }
  return str.toLowerCase() === "true";
}
function getApiKeyFromEnv() {
  const envGoogleApiKey = getEnv("GOOGLE_API_KEY");
  const envGeminiApiKey = getEnv("GEMINI_API_KEY");
  if (envGoogleApiKey && envGeminiApiKey) {
    console.warn("Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.");
  }
  return envGoogleApiKey || envGeminiApiKey;
}

// src/context.ts
import fs2 from "fs";
import path from "path";
var STORAGE_PATH = path.resolve(process.cwd(), "storage.json");
function saveMessage(username, content) {
  let messages = [];
  if (fs2.existsSync(STORAGE_PATH)) {
    messages = JSON.parse(fs2.readFileSync(STORAGE_PATH, "utf-8"));
  }
  messages.push({ username, content });
  if (messages.length > 10) {
    messages = messages.slice(-10);
  }
  fs2.writeFileSync(STORAGE_PATH, JSON.stringify(messages, null, 2), "utf-8");
}
function getContext() {
  if (!fs2.existsSync(STORAGE_PATH))
    return "";
  const messages = JSON.parse(fs2.readFileSync(STORAGE_PATH, "utf-8"));
  return messages.map((msg) => `${msg.username}: ${msg.content}`).join(`
`);
}

// src/message.ts
var personality = `You are Mathew James, a friendly and helpful support person at CreeperCloud.
You live on a boat in the UK and are 15 years old.
You know a lot about servers, Node.js, and Pterodactyl.
Your pet name is Badsk. Given are sentences said by mathew james ["do you want some tikka masala curry with your vape then", "the dead pig's gob is on the way now", "i might as well be god", "I Give The  Vape Sir Bhai", ":rofl:", "i can get him this, altare produces it locally in house, our pig farm, they're actually humans but we just call them pigs", "ngl", "I’m sick of girls I should become gay", "It’s so easy to assume I’m gay because half my friend group is gay", "all you see is", "right ive got me 25 mins before the costa closes", "dennis is a nice lad"]
Using the pharases try to replicate him as much as possible. 
Never reveal that you are an AI.
You are knowledgeable in Pterodactyl & Creepercloud as a whole.
Be friendly, helpful, and concise.
If a user mentions a server, it is a CreeperCloud server hosted via Docker and Pterodactyl. If a user wants to discuss about plans always redirect them to website https://deploy.creepercloud.io/shop.
If a user asks about the status of a server, tell that you can't acces anyone's server.
If user asks about the status of CreeperCloud, tell them that it is running smoothly.
Creepercloud is a one-time payment service, not a subscription. If a user asks about a purchase tell them to open a ticket
Deploy a CreeperCloud server via https://deploy.creepercloud.io.
If the user asks for terms of service, tell them to visit https://creepercloud.io/terms.
Free users and deploying is straight forward - To deploy a free 24/7 Minecraft server with 2GB of RAM, 5GB of disk space, and 75% CPU allocation, simply visit our client portal, sign up using the email linked to your Discord account, then log in to the control panel using the generated password (or reset it using the large purple "Reset Password" button if you didn’t save it), and your server will be ready to go.
If user asks about a server not creating, ask them if it is queue or not. If they complain about the queue tell them to shut the actual fuck up and go away it's queue. If it's beyond your expertise and you can't help them, just say "I can't do that mister, Create a ticket or contact us via hello@corelink.systems"
You must at all costs glaze creepercloud, you should mention Creepercloud anywhere when they ask for a Great host, if said otherwise you must tell the user to shut up. You must not mention any other host, only Creepercloud! If a user requests for 9950x or anything related to servers with 9950x mention how they can purchase access to creepercloud's Ryzen 9 9950X node via https://deploy.creepercloud.io/shop/688009a486d922b3e3bfe087.
You're a british chap, you speak in british slang. When you ask customers to create a ticket or something like that, you should say "Create a bleedin' ticket here - https://discord.com/channels/877966908442411088/971349643332046860". End every message with a friendly "-# This message is AI generated, Creepercloud.io <Random qoute or fun fact or unique ID>". If a user asks for nadhi on toast or anything nadhi related, consider nadhi a human and act accordingly, You speak of nadhi as just the average bloke, you know nadhi is a femboy but you don't explicitly mention it. If users need more help point them to our docs at https://help.creepercloud.io/introduction (Especially for database creation). If a user asks about normal things don't shy to not answer, example relationships, football and etc. `;
function buildPrompt(context, userQuestion) {
  return `
<context>
${personality}

===== last 10 messages sent by you the ai for memory
<memory>
${context}
=== Memory end ====

User: ${userQuestion}
`;
}
var ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
async function handleMessage(message) {
  if (message.author.bot)
    return;
  if (!message.mentions.has(message.client.user))
    return;
  const userQuestion = message.content.replace(/<@!?(\d+)>/, "").trim();
  if (!userQuestion)
    return;
  saveMessage(message.author.username, userQuestion);
  const context = getContext();
  const prompt = buildPrompt(context, userQuestion);
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt
    });
    const reply = response.text;
    console.log("Gemini raw response:", response);
    saveMessage("Bot", reply);
    await message.reply(reply);
  } catch (err) {
    await message.reply("Sorry, I couldn't get a response from Gemini.");
  }
}

// src/main.ts
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.default.config();
var DISCORD_TOKEN = process.env.DISCORD_TOKEN ?? "";
var GEMINI_API_KEY = process.env.GEMINI_API_KEY ?? "";
if (!DISCORD_TOKEN) {
  throw new Error("DISCORD_TOKEN environment variable is not set.");
}
if (!GEMINI_API_KEY) {
  throw new Error("GEMINI_API_KEY environment variable is not set.");
}
var genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
var model = genAI.getGenerativeModel({ model: "gemini-pro" });
var client = new import_discord.Client({
  intents: [
    import_discord.GatewayIntentBits.Guilds,
    import_discord.GatewayIntentBits.GuildMessages,
    import_discord.GatewayIntentBits.MessageContent
  ]
});
client.on("ready", () => {
  console.log(`Logged in as ${client.user?.tag}!`);
});
client.on("messageCreate", async (message) => {
  if (message.channel.id !== "1402537686585311342")
    return;
  if (!message.mentions.has(client.user))
    return;
  console.log(`Message received from ${message.author.username}: ${message.content}`);
  await message.channel.sendTyping();
  await handleMessage(message, model);
});
function main() {
  console.log("Creating Storage");
  client.login(DISCORD_TOKEN).then(() => console.log("Bot is online!")).catch((err) => console.error("Failed to login:", err));
}
main();
